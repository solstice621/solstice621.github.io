[{"title":"力扣763 划分字母区间","url":"/2023/05/10/3fc47803c6a3/","content":"\n![image-20230510215058203](/images/typora/image-20230510215058203.png)\n\n思路：\n\n先算出所有字母的最后位置$last[i](0\\le i\\le 25)$\n\n然后开始遍历字符串$s$，对于每个位置$i$更新这一段可能的最后位置(每一段可能的最后位置取决于这一段所有字母中最后位置最后的位置)\n\n当遍历的位置$i$达到了这一段可能的最后位置$end$，就可以开始更新下一个段。\n\n在这个过程中我们维护两个变量$start$和$end$，起初都默认为$0$，在更新的过程中$end=max(end，last[s[i]-'a')$，当$i==end$时，需要更新下一段，把长度$end-start+1$加入答案数组，更新$start=end+1$。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> partitionLabels(string s) {\n        vector<int> last(26,0);\n        int len=s.size();\n        for(int i=0;i<len;++i){\n            last[s[i]-'a']=max(last[s[i]-'a'],i);\n        }\n        vector<int> partition;\n        int start=0,end=0;\n        for(int i=0;i<len;++i){\n            end=max(last[s[i]-'a'],end);\n            if(i==end){\n                partition.push_back(end-start+1);\n                start=end+1;\n            }\n        }\n        return partition;\n    }\n};\n```\n\n"},{"title":"力扣502 IPO","url":"/2023/05/10/681c409b5bce/","content":"\n![image-20230510204932840](/images/typora/image-20230510204932840.png)\n\n朴素思想：\n\n先对所有利润排个序，然后每次选择利润最高且满足$capital[i]<=moneyNow$的项目。\n\n```cpp\nclass Solution {\npublic:\n    struct project{\n        int profit;\n        int capital;\n    };\n    static bool cmp(project a,project b)\n    {\n        return a.profit<b.profit;\n    }\n    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n        int n=profits.size();\n        project Project[n];\n        for(int i=0;i<n;++i)\n        {\n            Project[i].profit=profits[i];\n            Project[i].capital=capital[i];\n        }\n        std::sort(Project,Project+n,cmp);//对利润排序\n        int moneyNow=w;\n        bool flag[n];\n        memset(flag,false,sizeof flag);\n        for(int i=0;i<k;++i)\n        {\n            for(int j=n-1;j>=0;--j)//每次从上到下选择利润最大的项目\n            {\n                if(moneyNow>=Project[j].capital && flag[j]==false)//检查是否小于现在有的钱\n                {\n                    moneyNow+=Project[j].profit;\n                    flag[j]=true;\n                    break;\n                }\n            }\n        }\n        return moneyNow;\n    }\n};\n```\n\n不难发现时间复杂度为$O(n^2)$，在大规模数据下会超出时间限制\n\n优化思路：\n\n对所有$captial$进行从小到大的排序，每次只将小于$moneyNow$的项目加入待选的项目。同时。可以把待选的所有项目加入一个堆，这样堆顶就始终是$capital<=moneyNow$且利润最大的项目。\n\n```cpp\nclass Solution {\npublic:\n    struct project{\n        int profit;\n        int capital;\n    };\n    static bool cmp(project a,project b){\n        return a.profit<b.profit;\n    }\n    static bool cmp_capital(project a,project b){\n        return a.capital<b.capital;\n    }\n    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n        int n=profits.size();\n        vector<project> Project(n);\n        for(int i=0;i<n;++i){\n            Project[i].profit=profits[i];\n            Project[i].capital=capital[i];\n        }\n        std::sort(Project.begin(),Project.end(),cmp_capital);\n        int moneyNow=w;\n        int j=0;\n        std::priority_queue<project,std::vector<project>,decltype(&cmp)> q(cmp);\n        q.push({0,0});\n        while(!q.empty() && k--){\n             while(j<n && Project[j].capital<=moneyNow){\n                q.push(Project[j]);\n                j++;\n            }\n            project maxProfitProject=q.top();\n            q.pop();\n        }\n        return moneyNow;\n    }\n};\n```\n\n语法小贴士：\n\n```cpp\n while(j<n && Project[j].capital<=moneyNow)\n```\n\n两个条件不能互换，否则在$j=n$时，数组会越界引发报错。\n","tags":["贪心"],"categories":["题解"]},{"title":"CSAPP CHAP7 链接","url":"/2023/05/08/30742316d925/","content":"\n# 链接\n\n链接是将各种代码和数据片段收集并合并成一个单一文件的过程，这个文件可被加载(复制)到内存中执行。\n\n链接可以执行于编译时，也可以执行于加载时，甚至执行于运行时。\n\n连接器使得分离编译成为可能，意味着不用将一个大型的应用程序组织称一个巨大的源文件，而是可以把它分解为更小，更好管理的模块，可以独立地修改和变异这些模块。\n\n## 静态链接\n\nLinux LD程序这样的静态连接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接、可以加在和运行的可执行目标文件作为输出。\n\n输入的目标文件由代码和数据节构成，每一节都是一个连续的字节序列。\n\n为了构造可执行文件，链接器必须完成两个主要任务：\n\n1. 符号解析\n\n   目标文件定位、引用符号，每个符号对应于一个函数、全局变量或一个静态变量，符号解析**将每个符号引用和一个符号定义关联起来**。\n\n2. 重定位\n\n   编译器和汇编器生成从地址0开始的代码和数据节。链接器通过符号把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后**修改所有对这些符号的引用**，**使它们指向这个内存位置**。\n\n## 目标文件\n\n目标文件有三种形式：\n\n1. 可重定位目标文件：其形式可以**在编译时与其他可重定位的目标文件合并起来**，创建一个可执行目标文件。\n2. 可执行目标文件：可以被**直接复制到内存并执行**。\n3. 共享目标文件：一种特殊类型的可重定位目标文件，可以**在加载或者运行时被被动态地加载进内存并链接**。\n\n编译器和汇编器生成可重定位目标文件(包含共享目标文件)，链接器生成可执行目标文件。\n\n## 可重定位目标文件\n\n![image-20230510181641969](/images/typora/image-20230510181641969.png)\n\n这是一个典型的ELF(*Executable and Linkable Format*，*可执行可连接格式*)可重定位目标文件的格式。\n\nELF头以一个16字节的序列开始，描述了**生成该文件的系统的字的大小和字节顺序**。ELF头剩下的部分包含**帮助链接器语法分析和解释目标文件的信息**。其中包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量。\n\n不同节的位置和大小是由节头部表描述的。目标文件中每个节有一个固定大小的条目。\n\n夹在ELF头和节头部表中间的都是节。\n\n`.text`已编译程序的机器代码。\n\n`.rodata`只读数据，比如`printf`语句中的格式串和开关语句的跳转表。\n\n`.data`已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在`.data`节中，也不出现在`.bss`节中。\n\n`.bss`未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。目标文件中这个节不占据实际空间，仅仅是一个占位符。这样提供空间效率：未初始化变量不需占据任何磁盘空间，在运行时在内存中分配这些变量，初始值为0。\n\n`.symtab`一个符号表，存放程序中定义和引用的函数和全局变量的信息。\n\n`.rel.text`一个`.text`节中位置的列表。当链接器把这个目标文件和其他文件组合事，需要修改这些位置。**可执行目标文件中不需要重定位信息，通常省略**。\n\n`.rel.data`被模块引用或定义的所有全局变量的重定位信息。\n\n`.debug`一个调试符号表，条目是程序中定义的局部变量和类型定义，程序中定义和你用的全局变量以及原始的C源文件。\n\n`.line`C源程序的行号和`.text`节中机器指令之间的映射。\n\n`.strtab`一个字符串表，内容包括`.symtab`和`.debug`节中的符号表，以及节头部中的节名字。字符串表是以`null`结尾的字符串的序列。\n\n\n\n## 符号和符号表\n\n每个可重定位目标模块$m$都有一个符号表,包含$m$定义和引用的信息.\n\n在链接器上下文中,有三种不同的符号:\n\n1. 全局符号: 由模块$m$定义并能被其他模块引用的全局符号,对应**非静态C函数和全局变量**\n2. 外部符号: 由其他模块定义并被$m$引用的全局符号,对应**在其他模块中定义的非静态C函数和全局变量**\n3. 局部符号: 只被模块$m$定义和引用的符号,对应**带static属性的C函数和全局变量**,在模块$m$中任何位置都可见,但不能被其他模块引用\n\n`.symtab`符号表中不包含**对应于本地非静态程序变量的任何符号**,这些符号运行时在栈中被管理\n\n(静态程序变量: 具有静态存储期的变量: 静态局部变量与全局变量(默认静态))\n\n定义为带有C static属性的本地过程变量不在栈中管理,编译器在`.data`或`.bss`中为每个定义分配空间,并在符号表中创建一个唯一名字的本地链接器符号,如:\n\n```c\nint f()\n{\n    static int x=0;\n    return x;\n}\nint g()\n{\n    static int x=1;\n    return x;\n}\n```\n\n这种情况中,编译器向汇编器输出两个不同名字的局部链接器符号,比如用`x.1`表示$f$中的定义,用`x.2`表示$g$中的定义\n\n\n\n符号表由汇编器构造,使用编译器输出到汇编语言`.s`文件中的符号\n\n`.symtab`节中包含ELF符号表,这张符号表包含一个条目的数组\n\n```c\ntypedef struct{\n    int name;//字符表(.strtab)中字节偏移,指向符号名字(是一个以null结尾的字符串)\n    char type:4,//符号类型:数据/函数\n    \t binding:4;//符号类型:本地/全局\n    char reserved;//Unused\n    short section;//位于哪个节中,到节头部表索引\n    long value;//可重定位文件-距定义的节的起始位置的偏移,可执行文件-运行时的绝对地址\n    long size;//对象的大小\n}Elf64_Symbol;\n```\n\n有三个特殊的*伪节*,在节头部表中没有条目:\n`ABS`代表不该被重定位的符号\n\n`UNDEF`表示未定义的符号:在**本目标模块中引用,但是其他地方定义的符号**\n\n`COMMON`表示还未被分配位置的未初始化的数据模板\n\n**只有可重定位目标文件中才有这些伪节,可执行目标文件中没有**\n\n`COMMON`和`.bss`的区别:\n\n```\nCOMMON 未初始化的全局变量\n  .bss 未初始化的静态变量,以及初始化为0的全局或静态变量\n```\n\n## 符号解析\n\n链接器解析符号引用的方法: 将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来.\n\n和引用定义在相同模块中的局部符号的引用: 编辑器只允许每个模块中每个局部符号有一个定义.\n\n静态局部变量也会有本地链接器符号,编译器要确保他们拥有唯一名字.\n\n对全局符号的引用解析: 当编译器遇到一个不是在当前模块中定义的符号,会**假设**该符号在其他某个模块中定义的,生成一个链接器符号表条目,并把它交给链接器处理.如果链接器在它的任何输入模块中都找不到这个被引用符号的定义,就输出一条错误信息并停止.\n\n### 链接器如何解析多重定义的全局符号\n\n链接器的输入是一组可重定位目标模块.如果多个模块定义同名的全局符号,Linux系统采用以下方法:\n\n编译时,编译器向汇编器输出每个全局符号(强/弱)\n\n函数和已初始化的全局变量是**强符号**\n\n未初始化的全局变量是**弱符号**\n\n1. 不允许有多个同名的强符号\n2. 如果一个强符号和多个弱符号同名,选择强符号\n3. 如果多个弱符号同名,从这些弱符号中任选一个\n\n### 与静态库链接\n\n将所有相关目标模块打包为一个单独的文件,称为静态库,可用作链接器的输入\n\n当链接器构造一个输出的可执行文件时,只复制静态库里被应用程序引用的模块\n\n例如`ISO C99`定义了一组广泛的标准I/O,字符串操作和证书数学函数,对每个C程序都可用\n\n\n\n如果不使用静态库,编译器开发人员如何向用户提供函数:\n\n1. 让编译器辨认出对标准函数的调用,并直接生成相应代码(Pascal),对C语言不合适,因为C标准定义了大量标准函数,会给编译器增加显著复杂性.每次添加,修改,删除标准函数都需要一个新的编译器版本.\n\n2. 将所有标准C函数放在一个单独的可重定位模块中,应用程序员把这个模块链接到他们的可执行文件中.\n\n   优点: 将编译器的实现与标准函数分开\n\n   缺点:\n\n   1. 每个可执行文件都包含一份标准函数的完全副本,**浪费很大磁盘空间**.\n\n   2. 每个正在运行的程序都把这些函数的副本放在内存中,**浪费很大内存**.\n\n   3. 对标准函数的任何改变,无论多小,都要求库的开发人员**重新编译整个源文件**.\n\n3. 为每个标准函数创建一个独立的可重定位文件.要求应用程序员**显式地链接**合适的目标模块到它们地可执行文件中,容易出错且耗时.\n\n静态库: 相关函数可以被编译为独立的目标模块,然后封装成一个单独的静态库文件.\n\n在链接时,链接器只复制被程序引用的目标模块,减小了可执行文件在磁盘和内存中的大小.\n\n## 重定位\n\n链接器完成了符号解析, 知道它的输入目标模块中的代码节和数据节的确切大小,就可以开始重定位步骤:\n\n1. 重定位节和符号定义: 在这一步中,链接器将**所有相同类型的节合并为同一类型的新的聚合节**(例如将所有输入模块的`.data`节合并成一个`.data`节),然后将运行时的内存地址赋给新的聚合节,赋给输入模块定义的每个节,以及赋给模块定义的每个符号,完成后程序中的每条指令和全局变量都有**唯一的运行时的内存地址**.\n2. 重定位节中的符号引用: 链接器修改代码节和数据节中每个符号的引用,使他们指向正确的运行时地址.这一步依赖于可重定位目标模块中的**重定位条目**.\n\n### 重定位条目\n\n汇编器生成一个目标模块时,并不知道数据和代码最终放在内存中的什么位置,也不知道模块引用的任何外部定义的函数或全局变量的位置.任何时候汇编器遇到最终位置未知的目标引用,就生成一个重定位条目,告诉链接器在将目标文件合并成可执行文件时如何修改这个引用.\n\n代码的重定位条目放在`.rel.text`中,已初始化数据的重定位条目放在`.rel.data`中\n\n```c\ntypedef struct{\n    long offset;    //需要被修改的引用的节偏移（即该符号引用距离所在节的初始位置的偏移）\n    long type:32;   //重定位类型，不同的重定位类型会用不同的方式来修改引用\n    \t symbol:32; //symbol table index,指向被修改引用应该指向的符号\n    long addend;    //一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整     \n}Elf64_Rela;\n```\n\nELF定义了32种不同的重定位类型,我们只关心最基本的两种:\n\n1. `R_X86_64_PC32` 重定位一个使用**32位PC相对地址**的引用\n\n   一个PC相对地址就是距程序计数器(PC)的当前运行时值的偏移量,当CPU执行一条PC相对寻址的指令时,它就将在指令中编码的32位值加上PC的当前运行时的值,得到有效地址.PC值通常是吓一跳指令在内存中的地址.\n\n2. `R_X86_64_32` 重定位一个使用32位绝对地址的引用\n\n## 可执行目标文件\n\n![image-20230509135411357](/images/typora/image-20230509135411357.png)\n\nELF头描述文件的**总体格式**,还包含程序的**入口点**(程序运行时要执行的第一条指令的地址)\n\n`.text`,`.rodata`,`.data`与可重定位目标文件中的节相似\n\n`.init`节定义了一个小函数,叫做`_init`,用于程序初始化代码\n\n可执行文件是**完全链接**(已被重定位)的,因此不再需要`rel`节\n\n## 加载可执行目标文件\n\nLinux shell 中运行可执行目标文件的方式：**在命令行中输入文件的名字**（用带 ./ 的相对路径表示）。\n\n```shell\n>>./prog.o\n```\n\n上面运行了文件 `prog.o`，因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件，通过调用**加载器**（是操作系统中的一个程序）来运行它。\n\n**加载**：加载器将可执行目标文件的代码和数据从磁盘复制到内存，然后跳转到程序的第一条指令或入口点来运行程序。\n\n任何 Linux 程序都可以**通过execve函数来调用加载器**。\n\n每个 Linux 程序都有一个运行时内存映像。**代码段总是从 0x400000 处开始**，后面是**数据段**，然后是**运行时堆段**，通过调用 malloc 库往上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大的用户地址$2^{48}-1$开始,向较小地区增长.栈上区域从地址$2^{48}$开始,**为内核中的代码和数据保留**.**内核就是操作系统驻留在内存的部分**.\n\n**加载器的工作过程**\n\n加载器运行时，创建一个内存映像（虚拟地址空间），在程序头部表的引导下，**将可执行文件的片复制到代码段和数据段**。然后加载器跳转到程序的入口点，即 _start 函数的地址（函数在系统目标文件 ctrl.o 中定义），_start 函数调用系统启动函数 __libc_start_main（定义在 libc.o 中），__libc_start_main 初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并在需要时把控制返回给内核。\n\n![image-20230509141803013](/images/typora/image-20230509141803013.png)\n\n```\n用户栈（User Stack）和运行时堆（Runtime Heap）都是计算机程序在运行时用于存储数据的内存区域，但它们的用途和管理方式有所不同。以下是主要的区别：\n\n管理方式：\n\n堆（Heap）：堆是由程序在运行时动态管理的内存区域。当你需要在运行时分配内存（例如，使用 C++ 的 new 或 C 的 malloc()）时，这部分内存就来自堆。这种内存的分配和释放需要程序员手动进行，也就是说，你需要显式地释放你申请的内存，否则可能会导致内存泄漏。\n\n栈（Stack）：栈是由程序自动管理的内存区域。当你调用函数时，函数的局部变量和返回地址都会被自动压入栈中，当函数返回时，这些信息会被自动弹出。因此，你无需手动分配或释放栈内存，这些都由编译器和运行时系统自动处理。\n\n存储内容：\n\n堆（Heap）：堆用于存储程序运行时动态分配的数据。这些数据的大小和生存期在编译时并不确定，而是在运行时决定。\n\n栈（Stack）：栈用于存储函数调用的上下文信息，包括函数的局部变量、返回地址和参数等。栈的特点是支持后进先出（LIFO）的数据访问模式，即最后压入栈的元素首先被弹出。\n\n生命周期：\n\n堆（Heap）：堆上的数据在手动释放之前都会保留。这意味着，除非你显式地释放内存，否则堆上的数据将在程序的整个运行期间都存在。\n\n栈（Stack）：栈上的数据只在函数调用期间存在。当函数返回时，其在栈上的数据就会被自动清除。\n\n空间大小：\n\n堆（Heap）：堆的大小通常比栈大得多，因为堆需要存储程序运行时可能需要的所有动态分配的数据。\n\n栈（Stack）：栈的大小通常比堆小，因为栈只需要存储当前活动函数调用的数据。如果程序的函数调用深度过大或者函数的局部变量过多，可能会导致栈溢出。\n\n总的来说，堆和栈的主要区别在于管理方式、存储内容、生命周期和空间大小。堆用于存储动态分配的数据，由程序员管理，而栈用于存储函数调用的上下文信息，由程序自动管理。\n```\n\n## 动态链接共享库\n\n静态库仍然有一些明显的缺点\n\n1. 静态库和其他所有软件一样,需要定期维护.如果程序员要使用一个库的最新版本,需要以某种方式了解到该库的更新情况,然后**显式的将他们的程序与更新的库重新连接**\n2. 每个C程序都会使用I/O函数,比如`printf`和`scanf`,在运行时这些函数的代码会被复制到每个运行进程的文本段.在运行上百个进程的典型系统上,这将是**对稀缺内存系统资源的极大浪费**.\n\n共享库是一个目标模块,在运行和加载时,**可以加载到任意的内存地址**,并和一个在内存中的程序链接起来,这个过程称为动态链接,是由一个叫做动态链接器的程序来执行的.共享库也称为共享目标,在Linux系统中通常用`.so`后缀来表示.微软的操作系统大量的使用了共享库,称为`DLL`(动态链接库)\n\n共享库以两种不同的方式来\"共享\"\n\n1. 在给定的文件系统中,对于一个库只有一个`.so`文件,所有引用该库的可执行目标文件**共享**这个`.so`**文件中的代码和数据**,而不是像静态库的内容那样**被复制和嵌入**到他们的可执行文件中.\n\n2. 在内存中,一个共享库的`.text`节的一个副本可以**被不同的正在运行的进程共享**.\n\n![image-20230509150652630](/images/typora/image-20230509150652630.png)\n\n↑创建一个可执行文件`prog21`,此文件的形式使得它在运行时可以和`libvector.so`链接.\n\n基本思路是创建可执行文件时,静态执行一些链接.\n\n然后**在程序加载时**,**动态完成链接过程**.此时,没有任何`libvector.so`的代码和数据节真的被复制到可执行文件`prog21`中.**链接器复制了一些重定位和符号表信息**,使得运行时可以解析对`libvector.so`中代码和数据的引用.\n\n\n\n当加载器加载和运行可执行文件`prog21`时,利用`7.9节`中讨论过的技术,加载部分链接的可执行文件`prog21`,接着注意到`prog21`包含一个`.interp`节(包含一个动态链接器的路径名),动态链接器本身就是一个共享目标.\n\n加载器加载和运行这个动态链接器,动态链接器执行以下**重定位**完成链接任务:\n\n1. 重定位`lib.so`的文本和数据到某个内存段\n2. 重定位`libvector.so`的文本和数据到另一个内存段\n3. 重定位`prog21`中所有对由`lib.so`和`libvector`定义的符号的引用\n\n最后动态链接器将控制传递给应用程序.此时共享库位置固定,并且在程序执行过程中不会改变.\n\n## 从应用程序中加载和链接共享库\n\n**动态链接**：应用程序在**运行时**要求动态链接器加载和链接某个共享库（共享库即动态链接库）。\n\n动态链接的应用：\n\n1. **分发软件**。软件开发者常利用共享库来分发软件更新，它们生成共享库的新版本，用户只需要下载共享库并替代当前版本，下一次运行应用程序时，应用将自动链接和加载新的共享库。\n2. **构建高性能 Web 服务器**：许多 Web 服务器使用基于动态链接的方法来生成动态内容。将每个生成动态内容的函数打包在共享库中，当一个浏览器请求达到时，服务器就动态加载并链接相应函数，然后直接调用它，而非创建新的进程来运行函数。\n\n## 位置无关代码\n\n多个进程如何共享程序的一个副本?\n\n现代系统以一种方式编译共享模块的代码段,使得它们**加载到内存的任何位置而无需链接器修改**.使用这种方法,无限多个进程可以**共享一个共享模块的代码段的单一副本**.\n\n可以加载而无需重定位的代码称为**位置无关代码**\n","tags":["CSAPP"],"categories":["笔记"]},{"title":"力扣435 无重叠区间","url":"/2023/05/06/9934737015eb/","content":"\n![image-20230506211632306](/images/typora/image-20230506211632306.png)\n\n思路:贪心\n\n对每个区间的右区间进行排序,从小到大取右区间最小的区间(贪心思想:为了为之后留出最多的区间)\n\n保存一个当前的区间$currentInterval$,如果每个遍历的区间的左区间小于此区间的右区间,说明区间重叠,该区间舍去,并且移除区间数$removedNums++$\n\n```cpp\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int len=intervals.size();\n        std::sort(intervals.begin(),intervals.end(),[](const std::vector<int>& a,const std::vector<int>& b)\n        {\n            return a[1]<b[1];\n        });\n        std::vector current_interval=intervals[0];\n        int num_removed=0;\n        for(int i=1;i<len;++i)\n        {\n            if(current_interval[1]>intervals[i][0])\n            {\n                ++num_removed;\n            }\n            else\n            {\n                current_interval=intervals[i];\n            }\n        }\n        return num_removed;\n    }\n};\n```\n\n","tags":["贪心"],"categories":["题解"]},{"title":"力扣3 无重复字符的最长子串","url":"/2023/05/03/235cc428ed01/","content":"\n![image-20230503215048135](/images/typora/image-20230503215048135.png)\n\n用滑动窗口+哈希表解决,哈希表记录当前的子串中是否包含字符$x$:\n\n遍历右边界$right$\n\n1. 如果$HashMap[s[right]]=0$(即当前子串中不包含该字符)\n\n   $ans=max(ans,right-left+1)$(更新最大长度)\n\n2. 如果$HashMap[s[right]]=1$(当前子串中已经包含该字符)\n\n   那么开始更新左边界,\n\n   1. 对于每个遍历的$left$值,如果$s[left]=s[right]$,说明已经找到了与右边界字符重复的左边界,重新设置$HashMap$使得$Hashmap[s[left]]=0$,然后$left++$,直接退出循环遍历\n   2. 如果$s[left]!=s[right]$,说明还没找到与右边界字符重复的左边界,要继续找.因为如果不找到这个字符,右边界就没法继续遍历下去\n\n​\t最后$HashMap[s[right]]=1$(右边界加入了当前子串)\n\n​\t$right++$\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n=s.size();\n        unordered_map<char,int> hashtable;\n        int left=0,right=0;\n        int ans=0;\n        while(right<n)\n        {\n            if(hashtable[s[right]]==0)\n            {\n                ans=max(ans,right-left+1);\n            }\n            else\n            {\n                while(left<=right)\n                {\n                    if(s[left]==s[right])\n                    {\n                        --hashtable[s[left]];\n                        ++left;\n                        break;\n                    }\n                    else\n                    {\n                        if(hashtable[s[left]]==1)\n                        {\n                            --hashtable[s[left]];\n                            ++left;\n                        }\n                        else ++left;\n                    }\n                }\n            }\n            ++hashtable[s[right]];\n            ++right;\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["滑动窗口"],"categories":["题解"]},{"title":"力扣209 长度最小的子数组","url":"/2023/05/01/d3082bc609a6/","content":"\n![image-20230501183814343](/images/typora/image-20230501183814343.png)\n\n思路:\n\n对于左边界$left$和右边界$right$,维护两边界前缀和之差$sum$\n\n然后对$sum$做减法,如果$sum-nums[left]\\ge target$,那么说明左边界可以增加以缩小边界值\n\n如果当前$sum\\ge target$,那么就将此时的左右边界之差和目前的$ans$做比较,小于则刷新最小$ans$值\n\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int left=0,right=0;\n        int len=nums.size();\n        int ans=114514,sumNow=0;\n        while(right<len)\n        {\n            sumNow+=nums[right];\n            ++right;\n            if(sumNow>=target)\n            {\n                while(sumNow-nums[left]>=target && left<right)\n                {\n                    sumNow=sumNow-nums[left];\n                    ++left;\n                }\n                ans=min(ans,right-left);\n            }\n        }\n        return ans==114514?0:ans;\n    }\n};\n```\n\n","tags":["题解"],"categories":["滑动窗口"]},{"title":"CSAPP3e 练习题6.17图解","url":"/2023/05/01/b05603f2f8db/","content":"\n蓝色代表cache中存的状态,红色代表这次存进cache的内容,粉红色代表M/H且引起M的原因\n\n![](/images/typora/3KF9HS%5D@%5DBT6P_14QA5DZ3O.jpg)\n\n","tags":["笔记"],"categories":["CSAPP"]},{"title":"计算机组成原理 中央处理器 概念整理","url":"/2023/04/29/89405a8c2927/","content":"\n1. 什么是指令周期,机器周期和时钟周期?他们之间有什么关系?\n\n   指令周期、机器周期和时间周期是计算机处理器（CPU）在执行指令时涉及的不同时间概念。它们之间存在层次关系，反映了处理器执行指令的不同阶段和时间粒度。\n\n   1. 时间周期（Clock Cycle）：时间周期是**处理器的基本时间单位**，通常由处理器的时钟信号决定。处理器的时钟频率衡量了每秒钟内可以产生的时钟周期数，例如，一个$1G\\ Hz$（千兆赫兹）的处理器每秒钟可以产生$10^9$个时钟周期。在一个时钟周期内，处理器可以执行一些基本的操作，如寄存器传输、简单逻辑运算等。\n\n   2. 机器周期（Machine Cycle）：机器周期是指处理器**执行一个最基本的内存操作所需的时间周期数**，如从内存中读取一个字（word）或向内存中写入一个字。机器周期通常由多个时钟周期组成，其具体长度取决于处理器的设计和内存性能。在一个机器周期内，处理器可以**完成一次内存访问，如读取一个指令、读取数据或写入数据等**。\n\n   3. 指令周期（Instruction Cycle）：指令周期是指**处理器执行一条指令所需的时间周期数**。指令周期通常由多个机器周期组成，其长度取决于指令的复杂性和处理器的设计。在一个指令周期内，处理器需要**完成指令的取出、译码、执行和结果写回等操作**。\n\n   这三个概念之间的关系可以概括为：一个指令周期由多个机器周期组成，而一个机器周期由多个时钟周期组成。换句话说，**时钟周期是最基本的时间单位，机器周期是处理器与内存交互的基本时间单位，而指令周期则是处理器执行一条指令所需的总时间单位**。\n\n   在现代处理器中，由于流水线技术、超标量执行、乱序执行等高级优化技术的应用，指令周期、机器周期和时钟周期之间的关系可能变得更加复杂。不过，这三个概念仍然有助于理解处理器执行指令的基本过程和时间开销。\n\n2. 什么是微指令?它和指令有什么关系\n\n   微指令（Microinstruction）是一种用于**描述CPU内部控制逻辑的低级指令**。微指令被用于**实现处理器的控制逻辑**，从而驱动各种功能单元来执行指令。与机器指令（Machine Instruction）不同，**机器指令是由程序员或编译器生成的高级指令**，用于描述处理器应执行的具体任务。微指令和机器指令之间存在层次关系，处理器在**执行机器指令时需要将其转换为一系列微指令**。\n\n   当处理器执行一条机器指令时，**指令译码器**（Instruction Decoder）将机器指令分解为一系列微指令，这些微指令代表了指令的具体实现细节。微指令包括**对寄存器的操作、数据传输、算术逻辑运算以及控制信号的生成等**。通过组合和执行这些微指令，处理器可以完成机器指令所描述的任务。\n\n   微指令的设计和实现因处理器架构的不同而有所差异。**在精简指令集计算机（RISC）架构中，机器指令通常较为简单且规整，每条机器指令通常对应一次微指令。在复杂指令集计算机（CISC）架构中，机器指令相对复杂，每条机器指令可能对应多个微指令。**\n\n   总之，微指令是处理器内部用于实现控制逻辑的低级指令，它们与机器指令存在层次关系。处理器通过将机器指令转换为一系列微指令，然后执行这些微指令来完成指定任务。\n\n3. 什么是指令流水线?指令流水线相对于传统体系结构的优势是什么?\n\n   指令流水线（Instruction Pipeline）是一种处理器设计技术，旨在提高指令执行的并行度和处理器的性能。在流水线设计中，**处理器将指令执行过程划分为多个阶段，每个阶段负责执行一部分指令任务**。这些阶段可以同时处理不同指令的不同部分，从而实现指令执行的并行化。\n\n   传统非流水线体系结构（即顺序执行体系结构）中，处理器在执行指令时，需要**按顺序**完成指令的取出、译码、执行和结果写回等操作。只有在完成一条指令的所有操作后，处理器才能开始执行下一条指令。这样的执行方式可能导致处理器的资源利用率不高，从而影响性能。\n\n   相比之下，指令流水线设计具有以下优势：\n\n   1. 并行性：通过将指令执行过程划分为多个阶段，流水线设计允许处理器同时处理不同指令的不同部分。这种并行性可以提高处理器的吞吐量，从而提高性能。(传统处理器:完成一条指令的所有操作后，处理器才能开始执行下一条指令)\n\n   2. 资源利用率：在流水线设计中，每个阶段可以独立使用处理器的不同资源，从而实现资源的有效利用。这有助于减少资源闲置时间，并提高处理器的性能。(传统处理器:利用率不高)\n\n   3. 高频率操作：由于指令执行被划分为多个较短的阶段，处理器可以在较高的时钟频率下运行，从而进一步提高性能。\n\n   然而，指令流水线设计也存在一些挑战，如流水线冒险（如结构冒险、数据冒险和控制冒险等），它们可能导致流水线暂停或延迟。为了解决这些问题，现代处理器采用了许多高级优化技术，如分支预测、乱序执行、寄存器重命名和乱序执行等。\n\n   总之，指令流水线相对于传统体系结构的优势在于提高了指令执行的并行度和处理器的性能，通过有效利用资源和实现高频率操作。然而，指令流水线设计也面临一些挑战，需要采用高级优化技术来克服。\n\n4. 数据总线,控制总线,地址总线\n\n   数据总线、地址总线和控制总线是计算机系统中用于实现组件间通信的三种主要总线类型。它们各自承担不同的职责，如数据传输、地址指示和控制信号传递等，从而协调和支持计算机系统的正常运行。以下是对它们的简要介绍：\n\n   1. 数据总线（Data Bus）：数据总线用于在处理器、内存和外设之间传输数据。其宽度（位数）**决定了每次传输的数据量**。例如，一个32位数据总线一次可以传输32位（4字节）的数据。数据总线的宽度直接影响计算机系统的数据传输速度。\n   2. 地址总线（Address Bus）：地址总线用于传输内存地址，从而指示数据总线从哪个地址读取数据或将数据写入哪个地址。地址总线的宽度决定了**处理器可以访问的最大内存容量**。例如，一个32位地址总线可以访问$2^{32}$（4GB）的地址空间。\n   3. 控制总线（Control Bus）：控制总线用于在处理器、内存和外设之间传输控制信号。这些控制信号用于协调各组件的操作，例如读写请求、时钟信号、总线仲裁信号等。控制总线的复杂性取决于系统的功能需求和设计。\n\n   **处理器位数是指处理器在一次操作中能处理的数据位数**。处理器位数**通常与数据总线的宽度相关**。例如，一个32位处理器通常有一个32位宽的数据总线，这意味着处理器可以一次处理32位（4字节）的数据。数据总线的宽度直接影响计算机系统的数据传输速度。\n\n5. CPU中有哪些专用寄存器\n\n   CPU中的专用寄存器是**为特定目的而设计**的寄存器，它们在计算机系统中负责处理和执行各种任务。以下是一些常见的专用寄存器：\n\n   1. 程序计数器（PC，Program Counter）：程序计数器存储了下一条指令的内存地址。当CPU执行一条指令时，程序计数器会自动递增，以指向下一条待执行的指令。\n\n   2. 指令寄存器（IR，Instruction Register）：指令寄存器用于存储当前正在执行的指令。指令从内存加载到指令寄存器，然后解码并执行。\n\n   3. 栈指针（SP，Stack Pointer）：栈指针用于指向当前调用栈顶部的内存地址。当发生函数调用或返回时，栈指针会相应地增加或减少。\n\n   4. 基址寄存器（Base Register）：基址寄存器用于存储内存中某个段（如数据段或堆栈段）的起始地址。基址寄存器与其他寄存器（如索引寄存器）结合使用，可以计算出内存中特定位置的有效地址。\n\n   5. 索引寄存器（Index Register）：索引寄存器用于存储数组或数据结构中的索引。它可以与基址寄存器结合使用，用于计算内存中特定元素的地址。\n\n   6. 状态寄存器/标志寄存器（SR/FR，Status Register/Flag Register）：状态寄存器存储了有关最近执行的指令结果的信息，如结果为零、结果为负数、溢出等。这些信息（标志位）可用于条件分支、循环等操作。\n\n   以上是一些常见的专用寄存器。需要注意的是，不同的CPU架构可能具有不同的寄存器集和命名。此外，某些寄存器（如通用寄存器）可以用于多种目的，而不仅限于单一功能。\n\n6. 指令和数据均存放在内存中,计算机如何从时间和空间上区分他们是指令还是数据?\n\n   从时间上讲,取指令事件发生在\"取指周期\",取数据时间发生在\"执行周期\"\n\n   从空间上讲,从内存流出的指令流流向控制器(指令寄存器),从内存独处的数据流流向运算器(通用寄存器)\n","tags":["计算机组成原理"],"categories":["笔记"]},{"title":"力扣11 盛最多水的容器","url":"/2023/04/28/8e0ab8bc9aa4/","content":"\n![image-20230428173754739](/images/typora/image-20230428173754739.png)\n\n暴力算法:二重循环每个点取最大值\n数据范围:\n\n![image-20230428173820634](/images/typora/image-20230428173820634.png)\n\n一定不可行\n\n采用双指针:\n\n用$left$代表左边界,$right$代表右边界\n\n如何移动双指针呢?\n\n注意到$left$和$right$所代表的属性:$height[k]$表示线的高度,就根据高度的性质来判断移动哪个指针\n\n目前的$left$和$right$分别代表的高度$h_1,h_2$,则目前能容纳水的量为$min(h_1,h_2)\\times (right-left)$,\n\n移动较高的指针,则:\n\n当$h_{new}>h$时,$min(h_1,h_2)$与原先相同,$right-left$比原先小$1$,必小于原容量\n\n当$h_{new}<h$时,$min(h_1,h_2)$可能比原先小$h<h_{min}$,可能和原先一样,$right-left$比原先小$1$,新容量必小于原容量\n\n移动较低的指针,则:\n\n当$h_{new}>h$时,$min(h_1,h_2)$可能与原先一样,也可能大于原先的$(h_{new}>min(h_1,h_2))$,新的盛水量与原先盛水量大小不能确定\n\n当$h_{new}<h$时,$min(h_1,h_2)$小于原先的$h_{min}$,新盛水量必比原盛水量小\n\n总结:\n\n移动较高的指针,新的盛水量一定比原先的盛水量小\n\n移动较低的指针,新的盛水量可能比原先的盛水量大\n\n因此,每次移动指针的时候,只需比较两边高度然后移动较低的指针即可.\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left=0,right=height.size()-1;\n        int ans=0;\n        while(left<right)\n        {\n            int h=min(height[left],height[right]);\n            ans=max(ans,h*(right-left));\n            if(height[left]<height[right])++left;\n            else --right;\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["题解"],"categories":["双指针"]},{"title":"力扣134 加油站","url":"/2023/04/24/f1ed81fcae40/","content":"\n![image-20230424183244302](/images/typora/image-20230424183244302.png)\n\n思路:\n\n贪心,对每个位置的当前剩余油量$curOil$进行维护,如果当前位置$i$的剩余油量$curOil<0$,那么说明从之前的位置出发无法行驶完(因为行驶到$i$就没油了),需要从下个位置开始行驶,$start=i+1$\n\n为什么$start\\sim i$的位置是不能选择的呢?(即,从当前$start$行驶到$i$无法行驶完为什么代表任意$start\\le k\\le i$的位置开始行驶都不能行驶完)\n\n考虑一个序列:`5000,-5001,1,1,1,1,1,1,-10000,1,1,1,1,...,1`(为$gas[i]-cost[i]$)\n\n模拟贪心过程:\n\n$i=0,curOil=5000$\n\n$i=1,curOil=-1$,小于$0$,$start=i+1=2$\n\n$i=2,curOil=1$\n\n$...$\n\n$i=7,curOil=5$\n\n$i=8,curOil=-9995,start=i+1=9$\n\n可以发现,如果位置$i$时当前油量小于$0$,那么$start\\sim i$的任何位置累加的剩余油量都是小于$0$的,因此这些位置都不能选择\n\n继续模拟:\n\n$i=9,curOil=1$\n\n$...$\n\n$i=10009,curOil=10000,sumOil=0$,此时可以发现从$start=9$出发可以完成遍历\n\n如果总的消耗油量大于总加油量,那么不能完成(显而易见,无论哪个位置出发最后都会缺油)\n\n```cpp\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int length=gas.size();\n        int curOil=0,sumOil=0;\n        int start=0;\n        for(int i=0;i<length;++i)\n        {\n            curOil+=gas[i]-cost[i];\n            sumOil+=gas[i]-cost[i];\n            if(curOil<0)\n            {\n                start=i+1;\n                curOil=0;\n            }\n        }\n        return sumOil<0?-1:start;\n    }\n};\n```\n\n","tags":["数组"],"categories":["题解"]},{"title":"计算机组成原理(六)中央处理器","url":"/2023/04/22/2a97cf6ad2c0/","content":"\n## 中央处理器\n\n### CPU的功能和基本结构\n\nCPU由运算器和控制器组成\n\n控制器的功能是**负责协调**并**控制**计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令  \n\n运算器的功能是对数据进行**加工**  \n\n**CPU的具体功能:**\n\n1. 指令控制  取指令、分析指令和执行指令  \n\n2. 操作控制  CPU管理并产生由内存去除的每条指令的操作信号,把各种操作送往相应部件,控制这些部件按指令要求动作\n3. 时间控制  对各种操作加以时间上的控制  \n4. 数据加工。对数据进行算术和逻辑运算。  \n5. 中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。  \n\n### CPU的基本结构\n\n![image-20230422201235640](/images/typora/image-20230422201235640.png)\n\n### 运算器\n\n运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理  \n\n1. 算术逻辑单元。主要功能是进行算术/逻辑运算。  \n2. 暂存寄存器。用于暂存从主存读来的数据  \n3. 累加寄存器(ACC)。它是一个通用寄存器，用于暂时存放 ALU 运算的结果信息  \n4. 通用寄存器组。如 AX、BX、CX、DX、SP 等，用于存放操作数和各种地址信息等。SP 是堆栈指针，用于指示栈顶的地址  \n5. 程序状态字寄存器  溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等  \n6. 移位器。对操作数或运算结果进行移位运算。  \n7. 计数器。控制乘除运算的操作步数。  \n\n### 数据通路\n\n#### 数据通路的功能\n\n数据在功能部件之间传送的路径被称为**数据通路**\n\n数据通路包括流经的部件,如`ALU,通用寄存器,状态寄存器`等等\n\n数据通路描绘了信息从什么地方开始,经过了哪个寄存器或多路开关,最后传送到哪个寄存器\n\n数据通路由控制部件控制,控制部件根据每条指令功能的不同生成对数据通路的控制信号\n\n数据通路的功能是**实现CPU内部的运算器与寄存器及寄存器之间的数据交换**\n\n#### 数据通路的基本结构\n\n1. CPU内部单总线方式\n\n   将所有寄存器的输入端和输出端连接到一条公共通路上.\n\n   优点:结构简单\n\n   缺点:数据传输存在较多冲突现象,性能较低\n\n2. CPU内部三总线方式:将所有的寄存器的输入端和输出端连接到多条公共通路上,可以在多个总线上传输不同的数据,提高效率\n\n3. 专用数据通路方式:根据指令执行过程的数据和地址的流动方向安排连接线路,避免使用共享总线,性能较高,但硬件量大\n\n![image-20230510123814368](/images/typora/image-20230510123814368.png)\n\n上图中,各部件用大写字母表示,字母+`in`表示该部件的允许输入控制信号;字母+`out`表示该部件的允许输出控制信号\n\n1. 寄存器之间的数据传送\n\n   通过CPU内部总线完成.以PC寄存器为例,实现传送操作的流程及控制信号:\n\n   ```\n   PC->Bus \tPCout有效,PC内容送总线\n   Bus->MAR\tMARin有效,总线内容送MAR\n   ```\n\n2. 主存和CPU之间的数据传送\n\n   以CPU从主存读取指令为例\n\n   ```\n   PS->Bus->MAR\tPCout和MARin有效,现行指令地址->MAR\n   1->R\t\t\tCU发读命令\n   MEM(MAR)->MDR\tMDRin有效\n   MDR->BUS->IR\tMDRout和IRin有效,现行指令->IR\n   ```\n\n3. 执行算术或逻辑运算\n\n   ALU本身是没有内部存储功能的组合电路,在执行加法运算时相加的两个数必须在ALU的两个输入端同时有效.\n\n   先把一个操作数经CPU内部总线送入暂存器Y保存,Y的内容在ALU的左输入端始终有效,再将另一个操作数经总线直接送到ALU的右输入端,这样两个数都送入了ALU,运算结果暂存在暂存器Z中\n\n   ```\n   Ad(IR)->Bus->MAR\tMDRout和MDRin有效\n   1->R\t\t\t\tCU发读命令\n   MEM->数据线->MDR\t  操作数从存储器->数据线->MDR\n   MDR->Bus->Y\t\t\tMDRout和Yin有效,操作数->Y\n   (ACC)+(Y)->Z\t\tACCout和ALUin有效,CU向ALU发加命令,结果->Z\n   Z->ACC\t\t\t\tZout和ACCin有效,结果->ACC\n   ```\n\n### 控制器\n\n控制器是整个系统的指挥中枢  \n\n基本功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的  \n\n控制器由程序计数器（PC）、指令寄存器（IR）、指令译码器、存储器地址寄存器(MAR),存储器数据寄存器（MDR）、时序系统和微操作信号发生器等组成。  \n\n1. 程序计数器。用于指出下一条指令在主存中的存放地址  \n2. 指令寄存器。用于保存当前正在执行的那条指令  \n3. 指令译码器。仅对操作码字段进行译码，向控制器提供特定的操作信号。  \n4. 存储器地址寄存器。用于存放要访问的主存单元的地址。  \n5. 存储器数据寄存器。用于存放向主存写入的信息或从主存读出的信息。  \n6. 时序系统。用于产生各种时序信号，它们都由统一时钟（CLOCK）分频得到。  \n7. 微操作信号发生器  根据 IR 的内容（指令）、PSW 的内容（状态信息）及时序信号产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种  \n\n### 控制器的功能和基本原理\n\n#### 控制器的结构和功能\n\n![image-20230422211428245](/images/typora/image-20230422211428245.png)\n\n通过数据总线,地址总线和控制总线连接在一起,虚线框内是控制器部件\n\n### 控制器的主要内容\n\n1. 从主存中取出一条指令，并指出下一条指令在主存中的位置  \n2. 对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作  \n3. 指挥并控制CPU、主存、输入和输出设备之间的数据流动方向 \n\n根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制,两类控制器中的 PC 和 IR 是相同的  \n\n### 硬布线控制器\n\n硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态,按时间的顺序发送一系列微操作控制信号.\n\n硬布线控制器由复杂的组合逻辑们电路和一些触发器构成,又称为**组合逻辑控制器**.\n\n#### 硬布线控制器单元图\n\n指令操作码决定控制单元发出不同操作命令,为了简化控制单元(CU)的逻辑,将指令的操作码译码和节拍发生器从CU分离,得到简化的控制单元图:\n\n![image-20230510141937969](/images/typora/image-20230510141937969.png)\n\nCU的输入信号来源:\n\n1. 经指令译码器译码产生的指令信息.\n\n   现行**指令操作码决定了不同指令在执行周期完成的不同操作**,因此**指令的操作码字段是控制单元的输入信号**,与时钟配合产生不同的控制信号\n\n2. 时序系统产生的机器周期和节拍信号.\n\n   为了使控制单元**按一定先后顺序和节奏发出控制信号**,控制单元必须受时钟控制.\n\n3. 来自执行单元的反馈信息(标志)\n\n#### 硬布线控制器的时序系统及微操作\n\n1. 时钟周期\n2. 机器周期\n3. 指令周期\n4. 微操作命令分析: 控制单元具有发出操作命令(控制信号)序列的功能.这些命令与指令有关,且需要按照一定次序发出,才能使机器有序工作.\n\n一执行程序过程中,对于不同指令,控制单元需发出各种不同的微操作命令.\n\n一条指令分为3个工作周期:\n\n1. 取值周期\n\n   ```\n   PC->MAR\t\t\t现行指令地址->MAR\n   1->R\t\t\t命令存储器读\n   M(MAR)->MDR\t\t现行指令从存储器读至MDR\n   MDR->IR\t\t\t现行指令->IR\n   OP(IR)->CU\t\t指令的操作码->CU译码\n   (PC)+1->PC\t\t形成下一条指令地址\n   ```\n\n\n2. 间址周期\n\n   ```\n   Ad(IR)->MAR\t\t将指令字中的地址码(形式地址)->MAR\n   1->R\t\t\t命令存储器读\n   M(MAR)->MDR\t\t将有效地址从存储器读至MDR\n   ```\n\n3. 执行周期\n\n   a. 非访存指令\n\n   ```\n   CLA\t\t清ACC\n   COM\t\t取反\n   SHR\t\t算术右移\n   CSL\t\t循环左移\n   STP\t\t停机指令\n   ```\n\n   b. 访存指令\n\n   ```\n   ADD X\t加法指令\n   Ad(IR)->MAR,1->R\n   M(MAR)->MDR\n   (ACC)+(MDR)->ACC\n   ```\n\n   该过程执行一个加法指令（ADD X），将内存中的某个值（位于地址 X）加到累加器（ACC）中的值上。以下是对每一步的详细解释：\n\n   1. `ADD X`：这是一条加法指令，表示将累加器（ACC）中的值与存储在内存地址 X 中的值相加。\n   2. `Ad(IR)->MAR,1->R`：这一步执行两个操作。首先，将指令寄存器（IR）中的地址部分（Ad(IR)，即上一步中的 X）加载到内存地址寄存器（MAR）中。这个地址是即将被读取的内存地址。然后，控制单元向存储器发送读取（R）命令。\n   3. `M(MAR)->MDR`：这一步是从内存（M）的 MAR 指定的地址读取数据，然后将数据存入内存数据寄存器（MDR）。简单来说，就是把地址 MAR 中的内存内容读到 MDR 中。\n   4. `(ACC)+(MDR)->ACC`：这一步是将 ACC（累加器）和 MDR 中的值相加，并将结果存入 ACC。这个操作由算术逻辑单元（ALU）执行。\n\n   ```\n   STA X\t存数指令\n   Ad(IR)->MAR,1->W\n   ACC->MDR\n   MDR->M(MAR)\n   ```\n\n   这是一个执行 `STA X`（将累加器内容存储到地址 X）指令的微指令序列。这条指令的功能是将累加器（ACC）中的值存储到内存地址 X 的位置。下面是这个过程的详细步骤：\n\n   1. `Ad(IR)->MAR`：这条微指令将指令寄存器（IR）中的地址部分（Ad(IR)，即 X）加载到内存地址寄存器（MAR）中。这个地址是即将写入数据的内存地址。\n\n   2. `1->W`：这条微指令是控制单元向存储器发送写入（W）命令，这将触发存储器在 MAR 中指定的地址写入数据。\n\n   3. `ACC->MDR`：这条微指令是从 ACC（累加器）读取数据，然后将数据存入内存数据寄存器（MDR）。简单来说，就是把 ACC 中的内容读到 MDR 中。\n\n   4. `MDR->M(MAR)`：这条微指令是将 MDR 中的数据写入到内存（M）的 MAR 指定的地址。这就完成了将 ACC 中的数据存储到内存的过程。\n\n   总的来说，这些微指令描述了 `STA X` 指令的执行过程，即将 ACC 中的值存储到内存地址 X 的位置。这个过程涉及了许多计算机硬件的基本组件，包括 IR、MAR、ACC、MDR 等。\n\n   ```\n   LDA X\t取数指令\n   Ad(IR)->MAR,1->R\n   M(MAR)->MDR\n   MDR->ACC\n   ```\n\n   这些操作是执行 `LDA X`（Load ACC with X）指令的微指令序列。这条指令的功能是将内存地址 X 中的值加载到累加器（ACC）中。下面是这个过程的详细步骤：\n\n   1. `Ad(IR)->MAR`：这条微指令将指令寄存器（IR）中的地址部分（Ad(IR)，即 X）加载到内存地址寄存器（MAR）中。这个地址是即将被读取的内存地址。\n   2. `1->R`：这条微指令是控制单元向存储器发送读取（R）命令，这将触发存储器从 MAR 中指定的地址读取数据。\n   3. `M(MAR)->MDR`：这条微指令是从内存（M）的 MAR 指定的地址读取数据，然后将数据存入内存数据寄存器（MDR）。简单来说，就是把地址 MAR 中的内存内容读到 MDR 中。\n   4. `MDR->ACC`：这条微指令是将 MDR 中的数据加载到 ACC（累加器）。这就完成了将内存中的数据加载到 ACC 的过程。\n\n   所以，是的，这些微指令组成了 `LDA X` 指令的执行过程。首先，从内存中获取位于 X 地址的值，然后将这个值加载到 ACC 中。这个过程涉及了许多计算机硬件的基本组件，包括 IR、MAR、ACC、MDR 等。\n\n   c. 转移指令\n\n   ```\n   JMP X\t无条件转移\tAd(IR)->PC\n   BAN X\t条件转移\n   ```\n\n#### CPU的控制方式\n\n控制单元控制一条指令执行的过程,是依次执行一个确定的微操作序列的过程.\n\n不同指令对应的微操作数和复杂程度不同,因此每条指令和每个微操作所需时间也不同.\n\n主要有3种控制方式:\n\n1. 同步控制方式\n\n   系统有一个统一时钟,**所有控制信号均来自这个统一的时钟信号**(通常以最长的微操作序列和最繁琐的微操作作为标准)\n\n   采用**完全统一的**,**具有相同时间间隔和相同数目的节拍**作为机器周期来运行不同的指令\n\n   优点: 控制电路简单\n\n   缺点: 运行速度慢\n\n2. 异步控制方式\n\n   不存在基准时标信号,各部件按照自身固有速度工作,通过应答方式联络\n\n   优点: 运行速度快\n\n   缺点: 控制电路复杂\n\n3. 联合控制方式\n\n   介于同步与异步的折中,对不同的指令微操作采用大部分同步,小部分异步的方法\n\n### 微程序控制器\n\n微程序控制器采用存储逻辑实现,即**微操作信号代码化**,使**每条机器指令转化成为一段微程序并存入一个专门的存储器**(控制存储器)中.微操作控制信号由微指令产生.\n\n#### 微程序控制基本概念\n\n微程序设计思想: 把**每条机器指令编写成一个微程序,每个微程序包含若干微指令,每条微指令对应一个或几个微操作命令**.\n\n这些微程序可以**存到一个控制存储器**中,用**寻址用户程序机器指令**的办法来寻址每个为程序中的微指令\n\n一些基本术语:\n\n1. 微命令与微操作\n\n   一条机器指令可以分解成一个微操作序列\n\n   微操作是计算机中最基本,**不可分解**的操作\n\n   微程序控制计算机中,控制部件向执行部件发出的各种控制命令称为微命令,它是**构成控制序列的最小单位**\n\n2. 微指令与微周期\n\n   **微指令是若干微命令的集合**\n\n   **存放微指令的控制存储器的单元地址称为微地址**\n\n   微指令通常至少包含两部分信息:\n\n   1. 操作控制字段(**微操作码**字段): 产生某一步操作所需的各种**操作控制信号**.\n   2. 顺序控制字段(**微地址码**字段): 控制产生**下一条要执行的微指令地址**.\n\n3. 主存储器与控制存储器\n\n   主存储器: 存放程序和数据,在CPU外部用RAM实现.\n\n   控制存储器(CM): 存放微程序,在CPU内部用ROM实现.\n\n4. 程序与微程序\n\n   程序是指令的有序集合,用于完成特定功能.\n\n   微程序是**微指令的有序集合**,**一条指令的功能由一段微程序实现**.\n\n总结:  微程序是**由微指令组成的序列**，其主要目的是**描述和实现机器指令的功能**。微程序可以被视为机器指令的实时解释器。微程序通常**由计算机的设计者编制**，并**存储在控制存储器**（通常是固定的、不可修改的存储器）中。\n\n#### 微程序控制器组成和工作过程\n\n##### 微程序控制器的基本组成\n\n![image-20230510155452829](/images/typora/image-20230510155452829.png)\n\n1. 控制存储器(CM)：微程序控制器的核心部件，用于**存放各指令对应的微程序**。\n1. 微指令寄存器：用于存放从CM中取出的微指令。它的位数同微指令字长相等。\n1. 微地址形成部件：用于产生初始微地址和后继微地址，以保证微指令的连续执行。\n1. 微地址寄存器：接受微地址形成部件送来的微地址，为在CM中读取微指令作准备。\n\n##### 微指令控制器的工作过程\n\n1. **执行取微指令公共操作**：在机器开始运行时，微程序控制器会自动将取指微程序的入口地址（通常为控制存储器（CM）的 0 号单元）送入微程序计数器（CMAR），然后从 CM 中读出相应的微指令送入微指令寄存器（CMDR）。取指微程序执行完后，主存中的机器指令就已存入指令寄存器中。\n2. **产生微程序的入口地址**：然后，机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入 CMAR。\n3. **执行微指令**：从 CM 中逐条取出对应的微指令并执行。\n4. **回到取指微程序的入口地址**：执行完对应于一条机器指令的一个微程序后，控制器又回到取指微程序的入口地址，继续第一步，完成取下一条机器指令的公共操作。\n\n这个过程会一直循环，直到整个程序执行完毕。每一条机器指令的执行都是通过执行一系列的微指令来完成的，这些微指令是由微程序控制器控制的。\n\n##### 微程序和机器指令\n\n通常，一条机器指令对应一个微程序。\n\n任何一条机器指令的取指令操作相同，因此可**将取指令操作的微命令统一编成一个微程序**。\n\n*如果指令系统中有n中机器指令，则控制存储器中的微程序数至少是n+1*\n\n#### 微指令的编码方式\n\n又称微指令的**控制方式**，是指如何对微指令的控制字段进行编码，以形成控制信号\n\n目标：**在保证速度的情况下，尽量缩短微指令字长**。\n\n1. 直接编码(直接控制)方式\n\n   无需译码，微指令的微命令字段中的每位都代表一个微命令。\n\n   选用或者不选用某个微指令，只需将该微命令的对应位设置成0或1即可。\n\n   每个微命令对应并控制数据通路中的一个微操作。\n\n   优点：简单，直观，执行速度快，操作并行性好。\n\n   缺点：字长过长，n个微指令要求操作字段有n位，造成控制存储器容量极大。\n\n![image-20230510163414184](/images/typora/image-20230510163414184.png)\n\n2. 字段直接编码方式\n\n   将微命令字段分为若干小字段，把互斥微命令组合在同一字段中，相容微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关。\n\n   ![image-20230510163528949](/images/typora/image-20230510163528949.png)\n\n   优点：可以缩短指令字长\n\n   缺点：通过译码电路后再发出微命令，比直接编码方式慢。\n\n   微命令字段分段原则：\n\n   1. 互斥性微命令在同一段内；相容性微命令分在不同段内。\n   2. 每个小段包含的信息位不能太多，否则将**增加译码线路复杂性和译码时间**。\n   3. 每个小段要**留出一个状态**，表示本字段不发出任何微命令。\n\n3. 字段间接编码方式\n\n   字段间接编码，也称为隐式编码。在这种编码方式中，一个字段的微命令**需要通过另一个字段中的微命令来解释**，而不是直接通过字段本身来解释。虽然这种方式可以缩短微指令字长，但是它会削弱微指令的并行控制能力，通常作为字段直接编码方式的一种**辅助手段**使用。\n","tags":["计算机组成原理"],"categories":["笔记"]},{"title":"力扣416 分割等和子集","url":"/2023/04/20/fc18d8a43620/","content":"\n![image-20230420194016218](/images/typora/image-20230420194016218.png)\n\n## 前置知识:0-1背包\n\n有$N$件物品和一个容量为$V$的背包,放入第$i$件物品耗费的容量是$C_i$,得到的价值是$W_i$,求解将哪些物品放进背包得到的价值总和最大.\n\n### 基本思路:\n\n这是最基本的背包问题,每个物只有一件,有两种选择:放,或者不放\n\n有状态转移方程:\n$$\nF[i,v]=max\\lbrace F[i-1,v],F[i-1,v-C_i]+W_i\\rbrace\n$$\n其中,$i$表示当前放的是第$i$件物品,$v$表示背包的剩余容量,这个方程可以解释为:\n\n对于一个状态:正在放第$i$件物品,剩余$v$容量的背包能取得的价值,有两种选择:\n\n1. 不放第$i$件物品,容量不会减小,相同的价值也不会增多,其价值等于放第$i-1$件物品,容量为$v$时的价值$F[i-1,v]$(容量没有变化)\n\n   问题转化为:`前i-1件物品放进容量为v的背包中`\n\n2. 放第$i$件物品,相比于上一个放$i-1$件物品,剩余容量为$v$的状态,他的容量要再减去第$i$件物品耗费的容量$C_i$,并且得到$W_i$的价值,即$F[i-1,v-C_i]+W_i$\n\n   问题转化为`前i-1件物品放进容量为v-Ci的背包中`\n\n可以发现:\n\n1. 对于每个物品$i$的状态取决于之前$i-1$个物品的状态,因此物品$i$是从小往上递推的\n2. 对于每个容量$v$的状态也取决于之前$v-k$的容量的状态,因此容量$v$也是从小往上递推的\n\n先进行初始状态定义:\n\n1. 当背包容量为0时，$dp[i][0]=0$因为在这种情况下，背包没有容量，无法放入任何物品，所以价值始终为0。\n2. 当没有物品可以选择时，$dp[0][j]=0$在这种情况下，由于没有物品可供选择，所以背包的价值也始终为0。\n\n如何进行循环?\n\n第一层循环是先遍历物品个数$i$还是先遍历容量$v$?\n\n如果先遍历容量$v$,那么对于每个不同的$v$,物体个数$i$都会从第一个$i$开始遍历.但是在之前的$i-1,i-2,...,1$状态中,第$k(0\\le k \\le i-1)$个物品可能已经被考虑在$F[k,v]$个状态中,在第$i$个状态中又取了一次物品$k$,导致物品的重复,从而出现错误的递推\n\n(简单讲,会导致物品被重复考虑而不是只放一次)\n\n如果遍历物品个数$i$,那么递推到第$i$个物品时,不会再考虑$i$之前的物品,即我们在当前的状态$F[i,v]$只考虑如何加入第$i$个物品以获得最大价值,而如果遍历容量$v$会加入$i$即之前的所有物品\n\n因此可以写出伪代码:\n\n```\nfor i=1 to n:\n\tfor v=Ci to V\n\t\tF[i,v]=max(F[i-1,v],F[i-1,v-Ci]+Wi)\n```\n\n### 优化空间复杂度\n\n由于每个状态$F[i,v]$都是由$F[i-1,v]$和$F[i-1,v-C_i]$两个状态递推而来,能否简化状态$F[i,v]$成为$F[v]$使得$F[v]$能从$F[i-1,v]$和$F[i-1,v-C_i]$递推而来\n\n可以倒序遍历容量$v$:这样遍历时,$F[v]$和$F[v-C_i]$实际上分别是$F[i,v]$和$F[i,v-C_i]$(因为倒序遍历,此时还没有遍历到和$v$相等/比$v$小的状态,这些状态此时还属于$i-1$时的状态)\n\n如果正序遍历呢?可以发现$F[v-C_i]$在遍历到$F[v]$之前已经被遍历过了,实际上$F[v]$是从$F[i,v-C_i]$递推而来,这是错误的\n\n有伪代码:\n\n```\nfor i=1 to n\n\tfor v=V to Ci\n\t\tF[v]=max(F[v],F[v-Ci]+Wi)\n```\n\n\n\n## 分割等和子集\n\n现在来看这道题:\n\n两个子集的元素和相等,即每个子集的元素和是整个数组和的一半\n\n背包价值-整个数组和$sum$的一半\n\n每个物品的容量$C_i=nums[i]$\n\n背包容量的上限$V=nums.size()$\n\n要获得的价值:$W=sum/2$\n\n先去掉一些情况:\n\n如果$\\sum nums[i]\\% 2=1$,即和为奇数,显然不可能分为两个子集,使得每个子集的元素是和的一半,可以直接$return\\ false$\n\n定义状态:\n\n$dp[i][j]$,其中$i$表示取第$i$个数(0-1背包中是第$i$个物品),$j$表示当前数的和(0-1背包中是物品的容量)\n\n$dp[i][j]$表示取到第$i$个物品,能否使得和为$j$的情况存在,如果存在为$true$,不存在为$false$\n\n因此,最后要返回的是$dp[n][sum]$,即由$n$个数相加能否获得和为$sum$的情况,情况存在则为$true$,不存在则为$false$\n\n讨论初始情况:\n\n不选取任何整数使得和为$0$,即$dp[i][0]=true$\n\n$dp[0][nums[0]]=true$,因为取前$0$个数只能取到$nums[0]$\n\n讨论状态转移方程:\n\n如果$j\\ge nums[i]$,那么有两种情况:\n\n1. 取第$i$个数,$dp[i][j]=dp[i-1][j-nums[i]]$\n\n   把第$i$个数容量为$j$的问题转移成取$i-1$个数,容量为$j-nums[i]$的问题.如果之前的和可以满足$j-nums[i]$,那么此时取第$i$个数可以得到\"取前$i$个数满足和为$j$\"的情况.相反,如果不满足,那么也无法通过原来的和加上$nums[j]$凑出和为$j$的情况\n\n2. 不取第$i$个数,$dp[i][j]=dp[i-1][j]$\n\n因此当$j\\ge nums[i]$时,状态转移方程有:\n$$\ndp[i][j]=dp[i-1][j]\\ |\\ dp[i-1][j-nums[i]]\n$$\n如果$j<nums[i]$,那么无法取第$i$个数,只能从\"不取第$i$个数\"的状态转移,即$dp[i][j]=dp[i-1][j]$\n\n```cpp\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1)return false;//只有一个数,显然不能分割\n        int sum=0;\n        for(int i=0;i<n;++i)\n            sum+=nums[i];\n        if(sum%2!=0)return false;//和是奇数,显然也不能分割\n        bool dp[n][sum];//不然可能会溢出(先sum/=2)\n        sum/=2;\n        memset(dp,0,sizeof dp);\n        for(int i=0;i<n;++i)\n            dp[i][0]=1;\n        dp[0][nums[0]]=1;\n        for(int i=1;i<n;++i)\n        {\n            for(int j=0;j<=sum;++j)\n            {\n                if(j>=nums[i])\n                {\n                    dp[i][j]=dp[i-1][j]|dp[i-1][j-nums[i]];\n                }\n                else\n                    dp[i][j]=dp[i-1][j];\n            }\n        }\n        return dp[n-1][sum];\n    }\n};\n```\n\n### 空间优化:\n\n```cpp\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int n=nums.size();\n        int sum=0;\n        for(int i=0;i<n;i++)\n            sum+=nums[i];\n        if(sum%2==1)return false;\n        bool dp[sum+1];\n        memset(dp,0,sizeof dp);\n        sum/=2;\n        dp[0]=1;\n        dp[nums[0]]=1;\n        for(int i=1;i<n;i++)\n        {\n            for(int j=sum;j>=nums[i];j--)//倒序递推\n            {\n                dp[j]=dp[j]|dp[j-nums[i]];\n            }\n        }\n        return dp[sum];\n    }\n};\n```\n\n\n\n\n\n\n\n","tags":["动态规划","背包问题"],"categories":["题解"]},{"title":"力扣5 最长回文子串","url":"/2023/04/19/0270b148674c/","content":"\n![image-20230419214114626](/images/typora/image-20230419214114626.png)\n\n对于字符串中每两个位置$i,j$中的字符,如果$s[i]=s[j]$:\n\n$dp[i][j]=true,i=j$,因为单个字符是回文字符串\n\n$dp[i][j]=true,i+1=j$,因为一对相同的字符构成的字符串是回文字符串\n\n$dp[i][j]=dp[i+1][j-1],i\\ne j$,因为最边上两个字符相等,如果中间的字符串是回文字符串,那么拓展的字符串是回文字符串;如果中间的字符串不是回文字符串,那么拓展的字符串也不是回文字符串\n\n对于每一对$i,j$,可以很容易的发现该字符串的长度为$j-i+1$,与目前已知(维护)的最大长度$maxLen$比大小,如果大于$maxLen$,那么找到了新的最长回文子串,并记录首个字符的位置$start$\n\n\n\n初始化:\n\n对于每个$dp[i][i]=1$,这是显然的\n\n```cpp\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n=s.size();\n        int maxlen=1;\n        int start=0;\n        int dp[1010][1010];\n        memset(dp,0,sizeof dp);\n        for(int i=0;i<=n;i++)dp[i][i]=1;\n        for(int len=2;len<=n;len++)//从长度为2的区间开始dp\n        {\n            for(int i=0;i<n;i++)\n            {\n                int j=i+len-1;\n                if(j>=n)break;\n                if(s[i]!=s[j])//不等则不是\n                {\n                    dp[i][j]=false;\n                }\n                else//s[i]==s[j]\n                {\n                    if(j-i<3)//长度为2,字符相等那么是回文字符串\n                    {\n                        dp[i][j]=true;\n                    }\n                    else//长度大于2,取决于中间的字符串是不是回文字符串\n                    {\n                        dp[i][j]=dp[i+1][j-1];\n                    }\n                }\n                if(dp[i][j] && j-i+1>maxlen)//是回文字符串,且长度大于目前最长的回文字符串\n                {\n                    start=i;\n                    maxlen=j-i+1;\n                }\n            }\n        }\n        return s.substr(start,maxlen);\n    }\n};\n```\n\n\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣238 除自身以外数组的乘积","url":"/2023/04/19/18a5393952ed/","content":"\n![image-20230419161301117](/images/typora/image-20230419161301117.png)\n\n观察可以发现$answer[i]=Left[i]*Right[i]$,其中$Left[i]$是$i$左侧所有元素的乘积(前缀积),$Right[i]$是$i$右侧所有元素的乘积(后缀积),因此先从前向后计算前缀积,然后从后向前计算后缀积,最后相乘即可\n\n```cpp\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> pre(n,0);//pre初始有n个变量,初始化值为0\n        vector<int> aft(n,0);\n        pre[0]=1,aft[n-1]=1;\n        for(int i=1;i<n;i++)\n        {\n            pre[i]=nums[i-1]*pre[i-1];\n        }\n        for(int i=n-2;i>=0;i--)\n        {\n            aft[i]=nums[i+1]*aft[i+1];\n        }\n        vector<int> ans(n);\n        for(int i=0;i<n;i++)\n        {\n            ans[i]=pre[i]*aft[i];\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["前缀和"],"categories":["题解"]},{"title":"力扣45&55 跳跃游戏","url":"/2023/04/19/13b590e2bf10/","content":"\n![image-20230419154952608](/images/typora/image-20230419154952608.png)\n\n维护一个跳跃可以抵达的最大长度$maxPos$,对于每个位置计算可以抵达的最大长度:\n$$\nmaxPos=max\\lbrace maxPos,i+nums[i]\\rbrace\n$$\n并且,当前的位置需要小于等于目前可以抵达的最大长度$maxPos$(如果当前位置大于$maxPos$,那么原来是无法抵达这个位置的)\n\n```java\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int n=nums.length;\n        int maxPos=0;\n        for(int i=0;i<n;i++)\n        {\n            if(i<=maxPos)maxPos=Math.max(maxPos,i+nums[i]);\n            else return false;\n        }\n        return true;\n    }\n}\n```\n\n![image-20230419160528994](/images/typora/image-20230419160528994.png)\n\n我们需要计算到达$nums[n-1]$的最小步数,维护一个最小步数$step$,以及当前步数下能达到的最远距离$end$.对每个位置计算$maxPos$,如果当前的位置已经到达了第$step$步可以抵达的最大长度,那么$step+1$同时当前步数能到达的最远距离$end=maxPos$\n\n![来源:leetcode题解.png](/images/typora/9d5016c6e660a452991185d23b7b4d98853b7c300453d79715b5e9a206085e44-%E5%9B%BE%E7%89%87-1681891676654-3.png)\n\n```cpp\nclass Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int n=nums.size();\n        int maxPos=0,end=0,step=0;\n        for(int i=0;i<n-1;i++)\n        {\n            maxPos=max(maxPos,nums[i]+i);\n            if(i==end)\n            {\n                end=maxPos;\n                ++step;\n            }\n        }\n        return step;\n    }\n};\n```\n\n","tags":["贪心","动态规划","数组"],"categories":["题解"]},{"title":"力扣274 H指数","url":"/2023/04/18/db31817b1476/","content":"\n![image-20230418115054086](/images/typora/image-20230418115054086.png)\n\n一眼二分,细节在代码中注释\n\n```java\nclass Solution {\n    public int hIndex(int[] citations) {\n        int n=citations.length;\n        int left=0,right=n;\n        while(left<right)\n        {\n            int mid=(left+right+1)/2;//+1防止无限循环\n            if(Judge(mid,citations)==true)\n            {\n                left=mid;\n            }\n            else\n            {\n                right=mid-1;\n            }\n        }  \n        return left;\n    }\n    public boolean Judge(int x,int[] citations)\n    {\n        int n=citations.length;\n        int lesserThan=0,moreThan=0;\n        boolean flag1=false,flag2=true;\n        for(int i=0;i<n;i++)\n        {\n            if(citations[i]>=x)//至少引用x次,可以大于等于x\n            {\n                moreThan++;\n            }\n            if(moreThan>=x)return true;\n        }\n        return false;\n    }\n}\n```\n\n另一种二分方式:\n\n```java\n        while(left<=right)\n        {\n            int mid=(left+right)/2;\n            if(Judge(mid,citations)==true)\n            {\n                left=mid+1;\n            }\n            else\n            {\n                right=mid-1;\n            }\n        }\n        return left-1;//因为left=mid+1   \n```\n\n","tags":["二分"],"categories":["题解"]},{"title":"力扣122 买卖股票的最佳时机II","url":"/2023/04/18/254037cd6c7a/","content":"\n![image-20230418105302795](/images/typora/image-20230418105302795.png)\n\n## 二维动态规划\n\n 每天有两种状态:手上有股票和手上没股票\n\n第$i$天手上有股票的状态记为$dp[i][1]$,他必然是从**没股票,买股票**或者**有股票,没卖股票**转移过来的,即:\n$$\ndp[i][1]=max\\lbrace dp[i-1][1],dp[i-1][0]-prices[i]\\rbrace\n$$\n第$i$天手上没股票的状态记为$dp[i][0]$,必然是从**有股票,卖股票**或者**没股票,没买股票**转移而来的,即:\n$$\ndp[i][0]=max\\lbrace dp[i-1][0],dp[i-1][1]+prices[i]\\rbrace\n$$\n初始状态:第一天没有股票,即没有买也没有卖(第一天也没有之前买的股票可以卖)\n$$\ndp[0][0]=0\n$$\n第一天有股票,即第一天按照第一天的股价买入了一支股票\n$$\ndp[0][1]=-prices[0]\n$$\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int ans=0;\n        int n=prices.length;\n        int[][] dp=new int[n][2];\n        dp[0][0]=0;\n        dp[0][1]=-prices[0];\n        for(int i=1;i<n;i++)\n        {\n            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);\n            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);\n        }\n        return dp[n-1][0];\n    }\n}\n```\n\n## 贪心\n\n由于可以在任意时间买入卖出股票,且只能买一支股票,可以把最大利润看作是数组上升的坡度.只要在之后卖出有利可图,就可以买入并且在之后卖出:\n\n`[7,1,5,3,6,4]`\n\n买入7无利可图,不买\n\n买入1,5卖出去,获利4\n\n买入5,发现之后可以买入3,放弃5买入3\n\n买入3,卖出6,获利3,总获利7\n\n我们要做的是在第$i$天之后维护一个当天之后的最小价格$preMin$,在$prices[j]>preMin$的一天卖出,然后$preMin=prices[j]$(因为之前的价格已经与后面的收益无关了,目前的最小价格就是卖出去的价格)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n=prices.length;\n        int premin=prices[0];\n        int profit=0;\n        for(int i=1;i<n;i++)\n        {\n            if(prices[i]>premin)//价格更高,就卖出\n            {\n                profit+=prices[i]-premin;\n                premin=prices[i];//之后的股票买入最小价格和i之前的价格无关了\n            }\n            if(prices[i]<premin)\n            {\n                premin=prices[i];//股票可以更便宜的买入\n            }\n        }\n        return profit;\n    }\n}\n```\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣2641 二叉树的堂兄弟结点II","url":"/2023/04/17/2be9062be90d/","content":"\n![image-20230417125844326](/images/typora/image-20230417125844326.png)\n\n思路:\n\n对二叉树进行分层的排序,在每层中求出下一层所有结点的和,然后再次遍历该层结点,对于每个结点的$val$减去自身和其亲兄弟结点的$val$\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode replaceValueInTree(TreeNode root) {\n        Queue<TreeNode> tree=new ArrayDeque<>();\n        if(root!=null)tree.add(root);\n        root.val=0;\n        while(!tree.isEmpty())\n        {\n            int nextLevelSum=0;\n            Queue<TreeNode> tmp=tree;\n            tree=new ArrayDeque<>();//用于加入下一层的所有结点\n//如果您尝试一边弹出节点一边添加下一层级的节点，那么当前层级的节点会与下一层级的节点混合在同一个队列中，这将使得很难确定哪些节点属于当前层级，从而导致错误的修改。(来源:ChatGpt)\n            for(TreeNode node : tmp)//求出整层的val\n            {\n                if(node.left!=null)\n                {\n                    tree.add(node.left);\n                    nextLevelSum+=node.left.val;\n                }\n                if(node.right!=null)\n                {\n                    tree.add(node.right);\n                    nextLevelSum+=node.right.val;\n                }\n            }\n            for(TreeNode node : tmp)//减去自己和亲兄弟的val\n            {\n                int childrenSum = (node.left != null ? node.left.val : 0) +\n                                  (node.right != null ? node.right.val : 0);\n                if (node.left != null) node.left.val = nextLevelSum - childrenSum;\n                if (node.right != null) node.right.val = nextLevelSum - childrenSum;\n            }\n        }\n        return root;\n    }\n}\n```\n\n","tags":["二叉树","BFS"],"categories":["题解"]},{"title":"二叉树的层序遍历","url":"/2023/04/17/5fa7d1a994c9/","content":"\n![image-20230417115716391](/images/typora/image-20230417115716391.png)\n\n难点在于需要对二叉树的每层分层输出:如果只要输出一个一维的按二叉树层序遍历的排序,只需建立一个队列$q$,对于每个结点将其儿子结点加入队列即可.\n\n由于需要维护二叉树每一层的结点,考虑一次性处理完每层的结点,即,对于每层的结点个数$n$,用循环将这个节点最左到最右的结点分别加入这层的数组$one\\_level$,并且同时将其左右结点加入队列.在把这个结点的左右结点加入队列后,弹出该节点.\n\n假设这层有$n$个结点,对$n$个结点遍历,加入$2n$个结点,并且把$n$个结点全部弹出,当循环结束时,队列中就剩下了下一层的$2n$(可能不是$2n$,更少)个结点\n\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> tree=new ArrayList<List<Integer>>();\n        Queue<TreeNode> queue=new ArrayDeque<>();\n        if(root!=null)queue.offer(root);\n        while(!queue.isEmpty())\n        {\n            List<Integer> one_level=new ArrayList<>();\n            int n=queue.size();\n            for(int i=0;i<n;i++)//对每层的所有结点遍历\n            {\n                TreeNode node=queue.poll();\n                one_level.add(node.val);//把队首结点加入这一层,并弹出(poll)\n                if(node.left!=null)\n                {\n                    queue.offer(node.left);\n                }\n                if(node.right!=null)\n                {\n                    queue.offer(node.right);\n                }\n            }\n            tree.add(one_level);//把这层结点加入树\n        }\n        return tree;\n    }\n}\n```\n\n","tags":["二叉树","BFS"],"categories":["题解"]},{"title":"力扣80 删除有序数组种的重复项II","url":"/2023/04/15/9788599dc43d/","content":"\n![image-20230415112039585](/images/typora/image-20230415112039585.png)\n\n考虑重复$k$个数的情况:\n\n定义两个指针$left,right$,要保证$right-left\\ge k$.\n\n如果$nums[right]\\ne nums[left]$,因为两者之间的间距大于等于$k$,因此$nums[left]$的重复个数没有超过$k$,$nums[right]$是可以保留的.由于我们最多只要保留$k$个$nums[left]$,因此直接在$nums[left+2]$的地方填上$nums[right]$即可.然后同时移动$left$和$right$.\n\n如果$nums[right]=nums[left]$,两者之间的间距大于等于$k$,说明$nums[left]$的重复个数超过上限$k$,这个数不保存,就移动右指针$right$找到下一个满足$nums[right]\\ne nums[left]$的数,目前的$left$指针保留给下一个满足条件的$right$.\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n=nums.length;\n        int left=0,right=2;//right-left始终>=2\n        while(right<nums.length)\n        {\n            if(nums[left]!=nums[right])\n            {\n                nums[left+2]=nums[right];\n                right++;\n                left++;\n            }\n            else\n            {\n                n--;\n                right++;\n            }\n        }\n        return n;\n    }\n}\n```\n\n","tags":["数组","双指针"],"categories":["题解"]},{"title":"补-2022年的厦门游记","url":"/2023/04/15/1ba3bd88e27c/","content":"\n前情提要:因为不知道什么原因(现在忘了)我并没有和sqy,cxy一行人一起坐高铁\n\n哦,想起来了,因为去厦门前我还去了松溪,然后我自己坐火车(绿皮)从松溪到厦门,他们直接坐高铁从上海到厦门\n\n第一天晚上,这个地方好像叫白城沙滩.对面好像就是鼓浪屿\n\n![IMG_0915](/images/typora/IMG_0915.JPG)\n\n![IMG_0917](/images/typora/IMG_0917.JPG)\n\n![IMG_0918](/images/typora/IMG_0918.JPG)\n\n猪头的腿好粗\n\n![IMG_0921](/images/typora/IMG_0921.JPG)\n\n![IMG_0924](/images/typora/IMG_0924.JPG)\n\n![IMG_0928](/images/typora/IMG_0928.JPG)\n\n远处的浮标是有人在游泳,感觉好危险\n\n![IMG_0931](/images/typora/IMG_0931.JPG)\n\n第二天去鼓浪屿的路上,这是在去码头的桥上\n\n![IMG_0936(20220722-084209)](/images/typora/IMG_0936(20220722-084209).JPG)\n\n已经到了鼓浪屿,刚下船\n\n![IMG_0939](/images/typora/IMG_0939.JPG)\n\n从鼓浪屿回头看厦门岛,好漂亮,有种小hk的感觉\n\n![IMG_0940](/images/typora/IMG_0940.JPG)\n\n鼓浪屿上的海洋馆,体验一般\n\n拍了一些形状奇特的🐟\n\n![IMG_0943](/images/typora/IMG_0943.JPG)\n\n![IMG_0946](/images/typora/IMG_0946.JPG)\n\n海底总动员\n\n![IMG_0949](/images/typora/IMG_0949.JPG)\n\n![IMG_0950](/images/typora/IMG_0950.JPG)\n\n深情对视\n\n![IMG_0952](/images/typora/IMG_0952.JPG)\n\n掉san,有种克苏鲁的感觉\n\n![IMG_0954](/images/typora/IMG_0954.JPG)\n\n![IMG_0955](/images/typora/IMG_0955.JPG)\n\n很多海龟挤在池子里,厦门海洋馆属实不行\n\n![IMG_0958](/images/typora/IMG_0958.JPG)\n\n鲨鱼都摆烂了\n\n![IMG_0960](/images/typora/IMG_0960.JPG)\n\n鼓浪屿上的奶茶店\n\n![IMG_0961](/images/typora/IMG_0961.JPG)\n\ncxy让我给她拍的,腰好粗(bushi)\n\n![IMG_0963](/images/typora/IMG_0963.JPG)\n\n远处的是郑成功像,cxy和lyt好像爬上去了\n\n![IMG_0967](/images/typora/IMG_0967.JPG)\n\n![IMG_0969](/images/typora/IMG_0969.JPG)\n\n![IMG_0971](/images/typora/IMG_0971.JPG)\n\n钢琴博物馆里的施坦威钢琴\n\n![IMG_0975](/images/typora/IMG_0975.JPG)\n\n奇怪的钢琴\n\n![IMG_0976](/images/typora/IMG_0976.JPG)\n\n去坐船,很刺激.jpg\n\n![IMG_0982](/images/typora/IMG_0982.JPG)\n\n![IMG_0985](/images/typora/IMG_0985.JPG)\n\n水里有很小的小鱼\n\n![IMG_0992](/images/typora/IMG_0992.JPG)\n\n上船了\n\n![IMG_0997](/images/typora/IMG_0997.JPG)\n\n感觉像废弃的高档别墅\n\n![IMG_1001](/images/typora/IMG_1001.JPG)\n\n![IMG_1002](/images/typora/IMG_1002.JPG)\n\n从海上看厦门岛\n\n![IMG_1003](/images/typora/IMG_1003.JPG)\n\n![IMG_1007](/images/typora/IMG_1007.JPG)\n\n![IMG_1010](/images/typora/IMG_1010.JPG)\n\n合照,双眼无神\n\n![IMG_1014(20220723-120400)](/images/typora/IMG_1014(20220723-120400).JPG)\n\n蜜雪冰城yyds!\n\n![IMG_1019](/images/typora/IMG_1019.JPG)\n\n外卖,点了炒河粉,海蛎煎,生蚝,好像有点多海蛎煎没吃完\n\n![IMG_1021](/images/typora/IMG_1021.JPG)\n\n被厦大网友叫出去聊润学(我忘了他什么名字)\n\n讨论了很多政治,厦门城市规划的东西,受益良多\n\n![IMG_1023](/images/typora/IMG_1023.JPG)\n\n中山路步行街,厦门南京路\n\n![IMG_1028](/images/typora/IMG_1028.JPG)\n\n![IMG_1029](/images/typora/IMG_1029.JPG)\n\n凌晨的小巷\n\n![IMG_1030](/images/typora/IMG_1030.JPG)\n\n夜晚的厦大\n\n![IMG_1033](/images/typora/IMG_1033.JPG)\n\n他开车送我回宿舍\n\n![IMG_1034](/images/typora/IMG_1034.JPG)\n\n![IMG_1039](/images/typora/IMG_1039.JPG)\n\n厦门园林植物园,好玩\n\n![IMG_1040](/images/typora/IMG_1040.JPG)\n\n![IMG_1041](/images/typora/IMG_1041.JPG)\n\n![IMG_1042](/images/typora/IMG_1042.JPG)\n\n雨林区,挺好看的,但是没有达到我的想象高度\n\n![IMG_1044](/images/typora/IMG_1044.JPG)\n\n![IMG_1048](/images/typora/IMG_1048.JPG)\n\n![IMG_1050](/images/typora/IMG_1050.JPG)\n\n![IMG_1055](/images/typora/IMG_1055.JPG)\n\n![IMG_1058](/images/typora/IMG_1058.JPG)\n\n![IMG_1062](/images/typora/IMG_1062.JPG)\n\n仙人掌区,比较喜欢这里,看到仙人掌就觉得幸福\n\n![IMG_1063](/images/typora/IMG_1063.JPG)\n\n![IMG_1065](/images/typora/IMG_1065.JPG)\n\n憨批照片\n\n![IMG_1069](/images/typora/IMG_1069.JPG)\n\n![IMG_1071](/images/typora/IMG_1071.JPG)\n\n![IMG_1079](/images/typora/IMG_1079.JPG)\n\n这是什么树\n\n![IMG_1080](/images/typora/IMG_1080.JPG)\n\n![IMG_1084](/images/typora/IMG_1084.JPG)\n\n![IMG_1085](/images/typora/IMG_1085.JPG)\n\n![IMG_1086](/images/typora/IMG_1086.JPG)\n\n![IMG_1087](/images/typora/IMG_1087.JPG)\n\n![IMG_1088](/images/typora/IMG_1088.JPG)\n\n![IMG_1090](/images/typora/IMG_1090.JPG)\n\n玻璃房,里面热炸了\n\n![IMG_1091](/images/typora/IMG_1091.JPG)\n\n![IMG_1096](/images/typora/IMG_1096.JPG)\n\n![IMG_1101](/images/typora/IMG_1101.JPG)\n\n![IMG_1104](/images/typora/IMG_1104.JPG)\n\n![IMG_1108](/images/typora/IMG_1108.JPG)\n\n![IMG_1110](/images/typora/IMG_1110.JPG)\n\n![IMG_1112](/images/typora/IMG_1112.JPG)\n\n![IMG_1113](/images/typora/IMG_1113.JPG)\n\n![IMG_1115](/images/typora/IMG_1115.JPG)\n\n很有地平线5墨西哥的感觉\n\n接下来是藤蔓植物区,这时候zjh中暑了,我们也回去了\n\n![IMG_1118](/images/typora/IMG_1118.JPG)\n\n![IMG_1120](/images/typora/IMG_1120.JPG)\n\n![IMG_1121](/images/typora/IMG_1121.JPG)\n\n远处的三栋住宅楼据说一平方17w,厦门的汤臣一品\n\n![IMG_1122](/images/typora/IMG_1122.JPG)\n\n![IMG_1123](/images/typora/IMG_1123.JPG)\n\n彩虹小马lyt\n\n![IMG_1130(20220724-144859)](/images/typora/IMG_1130(20220724-144859).JPG)\n\n鹭景大酒楼(好像叫这个),出租车司机推荐的,便宜又好吃,吃了一堆海鲜人均70\n\n![IMG_1135](/images/typora/IMG_1135.JPG)\n\n![IMG_1136](/images/typora/IMG_1136.JPG)\n\n![IMG_1137](/images/typora/IMG_1137.JPG)\n\n![IMG_1138](/images/typora/IMG_1138.JPG)\n\n![IMG_1139](/images/typora/IMG_1139.JPG)\n\n回上海了,和小机器人说再见\n\n![IMG_1149](/images/typora/IMG_1149.JPG)\n\n高铁上还在打牛客(悲)\n\n![IMG_1153](/images/typora/IMG_1153.JPG)\n\n回家的感觉真好!\n\n![IMG_1163](/images/typora/IMG_1163.JPG)\n","tags":["旅游"],"categories":["随笔"]},{"title":"计算机组成原理(五)指令系统","url":"/2023/04/13/c57f22a89037/","content":"\n## 指令格式\n\n指令（机器指令）是指示计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。指令系统是计算机的主要属性，位于硬件和软件的交界面上。  \n\n### 指令的基本格式\n\n指令是机器语言的一个语句,一组有意义的**二进制代码**,通常包括**操作码字段**和**地址码字段**\n\n<img src=\"/images/typora/image-20230413143636832.png\" alt=\"image-20230413143636832\" style=\"zoom: 67%;\" />\n\n操作码指出指令中该指令应该**执行什么性质的操作**以及**具有何种功能**(算术加运算/减运算,程序转移/返回等)\n\n地址码给出被操作的**信息**（指令或数据）**的地址**(操作数所在地址,运算结果保存地址等)\n\n在一个指令系统中，若所有指令的长度都是相等的，则称为**定长指令字结构**。定字长指令的**执行速度快，控制简单**。若各种指令的长度随指令功能而异，则称为**变长指令字结构**。然而，因为主存一般是按字节编址的，所以指令字长多为字节的整数倍  \n\n#### 零地址指令\n\n<img src=\"./images/typora/image-20230413144044781.png\" alt=\"image-20230413144044781\" style=\"zoom:67%;\" />\n\n只给出操作码OP, 没有显式地址。这种指令有两种可能 :\n\n1.**不需要操作数**的指令，如空操作指令、停机指令、关中断指令等。  \n\n2.零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈。  \n\n(**操作数地址是默认**的,所需的操作数默认在堆栈中,或在默认的寄存器中)\n\n####  一地址指令\n\n![image-20230413144517014](/images/typora/image-20230413144517014.png)\n\n#### 1.1.3 二地址指令\n\n![image-20230413144620722](/images/typora/image-20230413144620722.png)\n\n若指令字长为 32 位，操作码占 8 位，两个地址码字段各占 12 位，则指令操作数的直接寻址范围为 $2^{12}=4K$ 。  \n\n####  三地址指令\n\n![image-20230413145702438](/images/typora/image-20230413145702438.png)\n\n####  四地址指令\n\n![image-20230413145746073](/images/typora/image-20230413145746073.png)\n\n### 定长操作码指令\n\n定长操作码指令在指令字的**最高位部分**分配**固定的若干位**（定长）表示操作码。  \n\n对于**简化计算机硬件设计**，**提高指令译码和识别速度**很有利。  \n\n###  拓展操作码指令\n\n为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即全部指令的操作码字段的**位数不固定**，且**分散地**放在指令字的**不同位置**上。  \n\n最常见的变长操作码方法是**扩展操作码**，它使操作码的长度**随地址码的减少而增加**，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。  \n\n<img src=\"/images/typora/image-20230413150127221.png\" alt=\"image-20230413150127221\" style=\"zoom: 67%;\" />\n\n上图指令字长16位:\n\n4位为基本操作码字段OP,还有三个4位长的地址字段$A_1,A_2,A_3$\n\n1. 如果四位操作码全部用于三地址指令,有16条,而图中有15条三地址指令,1111留作拓展操作码\n\n2. 二地址指令15条,1111 1111留作拓展操作码\n\n3. 一地址指令15条,1111 1111 1111留作拓展操作码\n\n4. 零地址指令16条\n\n设计扩展操作码指令格式时，必须**注意**以下两点：  \n\n1. 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。  \n\n2. 各指令的操作码一定不能重复。  \n\n通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。  \n\n### 指令的操作类型\n\n####  数据传送\n\n传送指令通常有寄存器之间的传送（MOV）、从内存单元读取数据到 CPU 寄存器（LOAD）、从 CPU 寄存器写数据到内存单元（STORE）等。  \n\n####  算术和逻辑运算\n\n这类指令主要有加（ADD）、减（SUB）、比较（CMP）、乘（MUL）、除（DIV）、加 1（INC）、减 1（DEC）、与（AND）、或（OR）、取反（NOT）、异或（XOR）等\n\n####  移位操作\n\n算法移位,逻辑移位,逻辑循环等\n\n####  转移操作\n\n转移指令主要有无条件转移（JMP）、条件转移（BRANCH）、调用（CALL）、返回（RET）、陷阱（TRAP）等。无条件转移指令在任何情况下都执行转移操作，而条件转移指令仅在特定条件满足时才执行转移操作，转移条件一般是**某个标志位的值**，或**几个标志位的组合**。  \n\n####  输入输出操作\n\n这类指令用于完成 CPU 与外部设备交换数据或传送控制命令及状态信息  \n\n## 指令的寻址方式\n\n寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为**指令寻址**和**数据寻址**两大类。  \n\n###  指令寻址和数据寻址\n\n寻找**下一条将要执行的指令地址**称为指令寻址；寻找**本条指令的数据地址**称为数据寻址。  \n\n#### 指令寻址\n\n指令寻址方式有两种：一种是顺序寻址方式，另一种是跳跃寻址方式 \n\n1. 顺序寻址:通过程序计数器 PC 加 1（1 个指令字长），自动形成下一条指令的地址  \n\n2. 跳跃寻址:通过转移类指令实现。所谓跳跃，是指下条指令的地址**不由程序计数器 PC 自动给出**，而**由本条指令给出下条指令地址的计算方式**。  \n\n#### 数据寻址\n\n数据寻址是指如何**在指令中表示一个操作数的地址**，如何用这种表示**得到操作数**或怎样**计算出操作数的地址**\n\n数据寻址的方式较多，为区别各种方式，通常在指令字中设一个字段，用来指明属于哪种寻址方式\n\n<img src=\"/images/typora/image-20230413153330216.png\" alt=\"image-20230413153330216\" style=\"zoom:50%;\" />\n\n###  常见的数据寻址方式\n\n####  隐含寻址\n\n这种类型的指令不明显地给出操作数的地址，而在指令中**隐含操作数**的地址。  \n\n<img src=\"/images/typora/image-20230413153525442.png\" alt=\"image-20230413153525442\" style=\"zoom:67%;\" />\n\n优点:有利于缩短指令字长  \n\n缺点:需增加存储操作数或隐含地址的硬件  \n\n#### 立即(数)寻址\n\n这种类型的指令的**地址字段**指出的不是操作数的地址，而是**操作数本身**，又称**立即数**，采用补码表示  \n\n![image-20230413153627093](/images/typora/image-20230413153627093.png)\n\n优点:不访问主存，指令执行时间最短  \n\n缺点:**A的位数**限制立即数范围\n\n#### 直接寻址\n\n指令字中的形式地址 A 是**操作数的真实地址** EA, 即 EA = A  \n\n<img src=\"/images/typora/image-20230413153658594.png\" alt=\"image-20230413153658594\" style=\"zoom:67%;\" />\n\n优点:简单,执行阶段仅访问一次主存,不需要计算操作数位置\n\n缺点:**A的位数**决定了该指令操作数的寻址范围，操作数的地址不易修改。  \n\n#### 间接寻址\n\n间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即 EA =（A）\n\n<img src=\"/images/typora/image-20230413154423046.png\" alt=\"image-20230413154423046\" style=\"zoom:67%;\" />\n\n优点:扩大寻址范围\n\n缺点:执行阶段多次访存（一次间接寻址需两次访存，多次间接寻址需根据存储字的最高位确定访存次数）  \n\n由于访问速度**过慢**，这种寻址方式并不常用。一般问到扩大寻址范围时，通常指的是**寄存器间接寻址**  \n\n#### 寄存器寻址\n\n寄存器寻址是指在指令字中直接给出操作数所在的寄存器编号  ,即:$EA=R_i$,操作数在由$R_i$所指向的寄存器内\n\n<img src=\"/images/typora/image-20230413154653669.png\" alt=\"image-20230413154653669\" style=\"zoom:67%;\" />\n\n优点:指令在执行阶段**不访问主存**，**只访问寄存器**，因寄存器数量较少，对应地址码长度较小，使得**指令字短且因不用访存**，所以**执行速度快**，支持向量/矩阵运算 \n\n缺点:寄存器价格昂贵,计算机内寄存器数量个数有限\n\n#### 寄存器间接寻址\n\n寄存器间接寻址是指在寄存器 $R_i$种给出的不是一个操作数,而是操作数所在的主存单元的地址,即$EA=R_i$\n\n<img src=\"/images/typora/image-20230413154904390.png\" alt=\"image-20230413154904390\" style=\"zoom:67%;\" />\n\n优点:比一般间接寻址较快,但执行阶段需访问主存(操作数)\n\n#### 相对寻址\n\n相对寻址是把 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址 ,即$EA=(PC)+A$,其中$A$是相对于当前指令地址的位移量，可正可负，补码表示  \n\n<img src=\"/images/typora/image-20230413160205048.png\" alt=\"image-20230413160205048\" style=\"zoom:67%;\" />\n\n优点:操作数的地址不是固定的，它随 PC 值的变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。\n\n相对寻址广泛应用于**转移指令**。  \n\n#### 基址寻址\n\n基址寻址是指将 CPU 中基址寄存器 (BR) 的内容**加上**指令格式中的**形式地址 A **而形成操作数的有效地址，即 EA = (BR) + A。  \n\n基址寄存器既可采用专用寄存器，又可采用通用寄存器 \n\n![image-20230413160847836](/images/typora/image-20230413160847836.png)\n\n优点: 可扩大寻址范围  （基址寄存器的位数大于形式地址 A 的位数） \n\n 用户不必考虑自己的程序存于主存的哪个空间区域，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址 A）的位数较短  \n\n#### 变址寻址\n\n变址寻址是指有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容之和，即EA =（IX）+ A, 其中IX 为变址寄存器（专用），也可用通用寄存器作为变址寄存器。  \n\n![image-20230413161007225](/images/typora/image-20230413161007225.png)\n\n变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址 A 不变（作为基地址）。  \n\n\n\n基址寻址**面向系统**，主要用于**为多道程序或数据分配存储空间**，因此基址寄存器的内容通常**由操作系统或管理程序确定**，在程序的**执行过程中其值不可变**，而**指令字中的 A 是可变的**\n\n变址寻址**立足于用户**，主要用于**处理数组问题**，在变址寻址中，变址寄存器的**内容由用户设定**，在程序执行过程中**其值可变**，而指令字中的**A 是不可变**的。  \n\n#### 堆栈寻址\n\n堆栈是存储器（或专用寄存器组）中一块特定的、按**后进先出（LIFO）**原则管理的存储区，该存储区中读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为**堆栈指针**（SP）\n\n堆栈可分为**硬堆栈**与**软堆栈**两种。  \n\n**寄存器堆栈又称硬堆栈**。寄存器堆栈的成本较高，不适合做大容量的堆栈  \n\n从**主存中划出一段区域**来做堆栈是最合算且最常用的方法，这种堆栈称为**软堆栈**  \n\n在采用堆栈结构的计算机系统中，大部分指令表面上都表现为**无操作数指令**的形式，因为操作数地址都**隐含使用了 SP**。\n\n通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。  \n\n#### 总结\n\n![image-20230413161433328](/images/typora/image-20230413161433328.png)\n","tags":["计算机组成原理"],"categories":["笔记"]},{"title":"力扣105 从前序和中序遍历序列构造二叉树","url":"/2023/04/13/1054cc159d42/","content":"\n![image-20230413105415080](/images/typora/image-20230413105415080.png)\n\n前序遍历的顺序为\"根左右\",中序遍历的顺序为\"左根右\"\n\n先根据先序遍历得到根节点,在中序遍历中根节点的左边为左子树的结点,右边为右子树的结点\n\n基本思路:先根据前序遍历得到根节点,然后根据中序遍历的左右子树关系遍历得到左右子树\n\n```java\nroot.left=myBuildTree(preorder,inorder,preorder_left+1,preorder_left+size_left_subtree,inorder_left,inorder_root-1);\n//preorder_left+1,preorder_left+size_left_subtree表示先序遍历中左子树在数组中的的范围\n//inorder_left,inorder_root-1表示中序遍历中左子树在数组中的范围\nroot.right=myBuildTree(preorder,inorder,preorder_left+size_left_subtree+1,preorder_right,inorder_root+1,inorder_right);\n//preorder_left+size_left_subtree+1,preorder_right表示先序遍历中右子树在数组中的范围\n//inorder_root+1,inorder_right表示中序遍历中右子树在数组中的范围\n```\n\n由于每次要根据先序遍历中的第一个数(根)找到中序遍历中的根,遍历过于缓慢,可以用HashMap建立映射,从$O(n)$优化至$O(1)$\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private Map<Integer,Integer> hashmap;\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int n=preorder.length;\n        hashmap=new HashMap<Integer,Integer>();\n        for(int i=0;i<n;i++)\n            hashmap.put(inorder[i],i);//建立前序遍历到中序遍历的映射\n        TreeNode tree=myBuildTree(preorder,inorder,0,n-1,0,n-1);\n        return tree;\n    }\n    public TreeNode myBuildTree(int[] preorder,int[] inorder,int preorder_left,int preorder_right,int inorder_left,int inorder_right)\n    {\n        if(preorder_left>preorder_right)return null;\n        int preorder_root=preorder_left;\n        int inorder_root=hashmap.get(preorder[preorder_root]);\n        TreeNode root=new TreeNode(preorder[preorder_root]);\n        int size_left_subtree=inorder_root-inorder_left;\n        root.left=myBuildTree(preorder,inorder,preorder_left+1,preorder_left+size_left_subtree,inorder_left,inorder_root-1);\n        root.right=myBuildTree(preorder,inorder,preorder_left+size_left_subtree+1,preorder_right,inorder_root+1,inorder_right);\n        return root;\n    }\n}\n```\n\n\n\n","tags":["递归","二叉树"],"categories":["题解"]},{"title":"二叉树前序遍历","url":"/2023/04/12/27334146a02e/","content":"\n![image-20230412103942757](/images/typora/image-20230412103942757.png)\n\n题目没什么难度,主要是语法:\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> tree=new ArrayList<Integer>();\n        preorder(root,tree);\n        return tree;\n    }\n    public void preorder(TreeNode root,List<Integer> tree)\n    {\n        if(root==null)return;//Java中有null关键词\n        tree.add(root.val);\n        if(root.left!=null)preorder(root.left,tree);\n        if(root.right!=null)preorder(root.right,tree);\n        return;\n    }\n}\n```\n\n## 关于Java中的List接口\n\n在 Java 中，`List` 是一个接口，它是 Java 集合框架中最基本的一种序列容器，实现了一个动态数组的数据结构。\n\n`List` 接口是 `Collection` 接口的子接口，它定义了一些常用的操作方法，例如添加、删除、修改和查找元素等。与数组相比，`List` 接口提供了更加灵活的元素访问和操作方式，并且支持动态扩容和自动缩小等功能，可以方便地适应不同的应用场景和需求。\n\n在 Java 中，常用的 `List` 接口的实现类包括 `ArrayList`、`LinkedList`、`Vector`、`Stack`、`CopyOnWriteArrayList` 等等。这些实现类提供了不同的性能和特性，需要根据具体的使用场景和需求进行选择。\n\n例如，`ArrayList` 是基于动态数组实现的列表，支持快速的随机访问和元素插入/删除操作，因此在需要频繁进行随机访问或修改操作的场景下使用较为合适；而 `LinkedList` 则是基于双向链表实现的列表，支持快速的插入/删除操作，但是访问元素的性能较差，因此在需要频繁进行插入/删除操作的场景下使用较为合适。\n\n```java\nList<Integer> tree=new ArrayList<Integer>();\nList<Integer> tree=new LinkedList<Integer>();\nList<Integer> tree=new Vector<Integer>();\n```\n\n这段代码创建了一个名为 `tree` 的泛型类型为 `Integer` 的 `ArrayList` 对象。\n\n具体来说，`List<Integer>` 表示一个泛型类型为 `Integer` 的 `List` 对象，`ArrayList<Integer>` 则表示一个泛型类型为 `Integer` 的 `ArrayList` 对象。在 Java 中，`ArrayList` 是 `List` 接口的一个实现类，它实现了 `List` 接口中定义的所有方法，并且使用了动态数组来存储元素，因此支持随机访问和快速的元素插入/删除操作。\n\n因此，这段代码创建了一个名为 `tree` 的 `ArrayList` 对象，可以使用 `add()` 方法向其中添加元素，使用 `get()` 方法或下标访问符 `[]` 来访问指定位置的元素。例如，可以使用以下代码向 `tree` 中添加一些整数：\n\n```java\ncsharpCopy codetree.add(1);\ntree.add(2);\ntree.add(3);\n```\n\n这样就向 `tree` 中添加了三个整数 `1`、`2` 和 `3`。然后可以使用以下代码来访问 `tree` 中的元素：\n\n```java\ncsharpCopy codeSystem.out.println(tree.get(0)); // 输出 1\nSystem.out.println(tree.get(1)); // 输出 2\nSystem.out.println(tree.get(2)); // 输出 3\n```\n\n### ArrayList\n\n这样定义一个数组:\n\n```java\nList<Integer> tree=new ArrayList<Integer>();\n```\n\n在 Java 中，`ArrayList` 是一个动态数组类，它实现了 `List` 接口，支持快速的随机访问和元素插入/删除操作。\n\n具体来说，`ArrayList` 内部使用一个 Object 类型的数组来存储元素，并且支持动态扩容和自动缩小等功能。当向 `ArrayList` 中添加元素时，如果数组已满，则会自动创建一个更大的数组，并将原有元素复制到新数组中。同样地，当从 `ArrayList` 中删除元素时，如果数组中的元素数量较少，会自动收缩数组的大小，以节约内存空间。\n\n`ArrayList` 支持随机访问，可以使用 `get()` 方法或下标访问符 `[]` 来访问指定位置的元素；同时也支持在指定位置插入和删除元素，可以使用 `add()`、`remove()`、`set()` 等方法来进行操作。\n\n由于 `ArrayList` 基于数组实现，因此具有一些数组的特性，例如支持快速的随机访问和修改操作，但是在元素插入和删除操作时可能需要移动大量的元素，性能较差。因此，`ArrayList` 适合用于需要频繁进行随机访问或修改操作的场景。\n\n#### ArrayList中的操作\n\n在 Java 中，`ArrayList` 实现了 `List` 接口，提供了一系列的操作方法，常用的包括：\n\n1. `add(E element)`：向列表的末尾添加一个元素。\n2. `add(int index, E element)`：在指定位置插入一个元素。\n3. `addAll(Collection<? extends E> c)`：将指定集合中的所有元素添加到列表的末尾。\n4. `addAll(int index, Collection<? extends E> c)`：将指定集合中的所有元素插入到指定位置。\n5. `get(int index)`：返回指定位置的元素。\n6. `set(int index, E element)`：用指定的元素替换列表中指定位置的元素。\n7. `remove(int index)`：删除指定位置的元素。\n8. `remove(Object o)`：删除列表中第一个出现的指定元素。\n9. `clear()`：删除列表中的所有元素。\n10. `size()`：返回列表中元素的数量。\n11. `isEmpty()`：检查列表是否为空。\n\n除了上述方法之外，`ArrayList` 还提供了其他一些方法，例如 `indexOf()`、`lastIndexOf()`、`contains()` 等等，用于查找、比较和判断元素是否存在等操作。此外，`ArrayList` 还提供了一些操作数组的方法，例如 `toArray()`、`ensureCapacity()`、`trimToSize()` 等等，用于将列表转换为数组、调整数组的容量等操作。\n\n例如在刚刚的题目中\n\n```java\ntree.add(root.val);\n```\n\n就在`tree`数组的末尾加了一个数,来表示二叉树的前序排列\n","tags":["二叉树"],"categories":["笔记"]},{"title":"力扣279 完全平方数","url":"/2023/04/11/f92478edfc60/","content":"\n![image-20230411102321927](/images/typora/image-20230411102321927.png)\n\n思路:\n\n枚举一些数的平方来表示$i$,这些数落在区间$[1,\\sqrt n]$上,枚举这些数.同时,我们还需要取这些一些数的平方,构成$i-j^2$\n\n容易想到\n$$\ndp[i]=1+\\underset{j=1}{\\overset{\\sqrt{i}}{min}}dp[i-j^2]\n$$\n其中$\\underset{j=1}{\\overset{\\sqrt{i}}{min}}dp[i-j^2]$表示构成$i-j^2$的最少数,$1$表示加上一个数的平方($j^2$)\n\n边界条件:$dp[0]=0$,使得$i=j$时结果为$1$\n\n```java\nclass Solution {\n    public int numSquares(int n) {\n        int[] dp=new int[n+1];\n        for(int i=1;i<=n;i++)\n        {\n            int minn=Integer.MAX_VALUE;\n            for(int j=1;j*j<=i;j++)\n            {\n                minn=Math.min(dp[i-j*j],minn);\n            }\n            dp[i]=minn+1;\n        }\n        return dp[n];\n    }\n}\n```\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣343 整数拆分","url":"/2023/04/11/f44b48e2a9cf/","content":"\n![image-20230411100216812](/images/typora/image-20230411100216812.png)\n\n思路:\n\n从$1$开始到$n$,对于每个数$i$分别拆分后求出拆分后的最大乘积$dp[i]$,令拆分的数为$j$,对于$i,j$而言,拆分的数是$i-j$,那么可以继续拆分$i-j$或者不拆分$i-j$,采用$i-j$的拆分最大乘积$dp[i-j]$,可以发现每个数的拆分最大乘积$dp[i]$取决于所有比它小的$dp[j]$.\n\n当$j$固定时,可以发现\n$$\ndp[i]=max(j\\times(i-j),j\\times dp[i-j])\n$$\n由于$1\\le j\\le i$,因此总的状态转移方程有:\n$$\ndp[i]=\\underset {1\\le j<i}{max}\\{max(j\\times(i-j),j\\times dp[i-j])\\}\n$$\n\n```java\nclass Solution {\n    public int integerBreak(int n) {\n        int[] dp=new int[n+1];\n        dp[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            int curMax=0;\n            for(int j=1;j<i;j++)\n            {\n                curMax=Math.max(curMax,Math.max(j*(i-j),j*dp[i-j]));\n            }\n            dp[i]=curMax;\n        }\n        return dp[n];\n    }\n}\n```\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣96 不同的二叉搜索树","url":"/2023/04/10/036f297619d6/","content":"\n![image-20230410145243115](/images/typora/image-20230410145243115.png)\n\n思路:\n\n对于一个序列$1,2,3,...,n$,遍历其中每个数$i$,以$i$为根建立一棵二叉树:\n\n例如$n=9,i=6$,二叉树为:\n$$\n(12345)6(789)\n$$\n然后对左右两棵子树可再次遍历以上操作,不断如此直到左右子树等于1\n\n设:\n\n$G[n]$表示长度为$n$的序列可以组成的二叉树的数量\n\n$F[i,n]$表示长度为$n$的序列,以第$i$个结点为根节点可以组成的二叉树数量\n\n可以得到:\n$$\nF[i,n]=G[i-1]*G[n-i]\n$$\n\n因此,有:\n$$\n\\begin{equation}\nG[n]=\\sum_{i=1}^{n}F[i,n]\n\\end{equation}\n$$\n\n```java\nclass Solution {\n    public int numTrees(int n) {\n        int[] dp=new int[n+1];\n        dp[1]=1;\n        dp[0]=1;\n        for(int i=2;i<=n;i++)\n        {\n            for(int j=1;j<=i;j++)\n            {\n                dp[i]+=dp[j-1]*dp[i-j];\n            }\n        }\n        return dp[n];\n    }\n}\n```\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣264 丑数II","url":"/2023/04/10/17fd2c04b3fc/","content":"\n![image-20230410135712500](/images/typora/image-20230410135712500.png)\n\n容易发现,丑数都是由2,3,5作为质因数相乘得到的正整数\n\n前10个丑数序列:\n$$\n(2^0*3^0*5^0),(2^1*3^0*5^0),(2^0*3^1*5^0),(2^2*3^0*5^0),(2^0*3^0*5^1)\n$$\n\n$$\n(2^1*3^1*5^0),(2^3*3^0*5^0),(2^0*3^2*5^0),(2^1*3^0*5^1),(2^2*3^1*5^0),\n$$\n\n但是第N位是由2的几次幂乘上3的几次整数幂乘上5的几次幂是没有规律可循的\n\n定义状态$dp[i]$表示第$i$个丑数.由于第1个丑数是1,故$dp[1]=1$\n\n定义三个指针$p2,p3,p5$,表示下一个丑数是该质因数$i$乘上指针$p_i$指向的丑数,$p_i$表示的是可以同质因数$i$相乘的最小丑数的位置(因为我们要按顺序找,即找尽量小的,所有找的是最小丑数的位置).\"可以同质因数$i$相乘的最小丑数\"的意思是我们可以通过$i*dp[p_i]$得到下一个丑数,这时候我们就可以使$p_i++$以得到下一个丑数.\n\n用例子辅助理解:\n\n第一个丑数为$1,p_2=p_3=p_5=1$,$1$可以和$2,3,5$相乘,取最小的丑数$2=1*2$,由于乘上$2$因此$p_2+1=2,dp[2]=2$,此时$dp[2]$是可以同$i=2$相乘的最小丑数,为什么?因为我们要求下一个丑数,对于$2$来说,$1$已经完成了$1*2=2$,找到下一个丑数的使命,他不能再找到乘上质因数$2$的下一个丑数了,这时只要把这份使命传递给$p_2=2$指向的那个丑数就可以了.\n\n第二个丑数为$2,p_2=2,p_3=p_5=1$,取其中最小的乘积$dp[p_3]*3=3$,之后$p_3++$变成了$2$,把乘上质因数$3$找到下一个丑数的任务传递给了$dp[p_3]=dp[2]=2$,之后我们可以通过他找到某个丑数\n\n第三个丑数为$3,p_2=p_3=2,p_5=1$,取最小乘积$dp[p2]*2=4$,之后$p_2++$,变成$3$,把下一次乘上质因数$2$找到丑数的任务传递给了$dp[p_2]=dp[3]=3$,同样的我们要通过他找到之后的某个丑数\n\n...\n\n```java\nclass Solution {\n    public int nthUglyNumber(int n) {\n        int p2=1,p3=1,p5=1;\n        int[] dp=new int[n+1];\n        dp[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            int num2=dp[p2]*2;\n            int num3=dp[p3]*3;\n            int num5=dp[p5]*5;\n            dp[i]=Math.min(num2,Math.min(num3,num5));\n            if(dp[i]==num2)\n            {\n                p2++;\n            }\n            if(dp[i]==num3)\n            {\n                p3++;\n            }\n            if(dp[i]==num5)\n            {\n                p5++;\n            }\n        }\n        return dp[n];\n    }\n}\n```\n\n\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣512 零钱兑换II","url":"/2023/04/10/702fdf8007c0/","content":"\n![image-20230410072333992](/images/typora/image-20230410072333992.png)\n\n思路很简单,记一点细节\n\n一开始我用的双重循环,外圈循环为$0\\le i\\le amount$,内圈为不同的硬币面值,这样做会有问题:会记录重复的硬币排列\n\n例如`amount=3,coins=[1,2,3]`,当内层循环遍历到$1$的时候会加上一次(因为能找到2),遍历到2的时候又能找到一次(因为能找到1),这样会导致很多重复排列\n\n去除重复排列的思路是令外层循环为硬币的面值,内层为金额\n\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp=new int[amount+1];\n        dp[0]=1;\n        int n=coins.length;\n        for(int j=0;j<n;j++)\n        {\n            for(int i=coins[j];i<=amount;i++)\n            {\n                dp[i]+=dp[i-coins[j]];\n            }\n        }\n        return dp[amount];\n    }\n}\n```\n\n由于先对硬币面值进行循环,每个$i$中会记录下由前$j$个硬币面值构成的组合数量,排列是严格按照硬币顺序来的,即在上面的例子中会先算所有1构成的,再算所有2构成的,不会生成重复排列.\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣72 编辑距离","url":"/2023/04/09/da88c2b82754/","content":"\n![image-20230409164149440](/images/typora/image-20230409164149440.png)\n\n状态:用$dp[i][j]$表示字符串1以$i$结尾的子串转化成字符串2以$j$结尾的子串所需要的操作数量\n\n如何转移?\n\n由于在字符串1中添加一个字符是字符串2中删除一个字符的逆操作,反之亦然,例如:\n\n`rorse->rose`,是字符串`rose`删除`r`\n\n可以理解为`ros->rose`\n\n因此字符串添加/删除本身有4种操作(对1添加删除,对2添加删除),现在简化为对1添加与对2添加,2种操作\n\n第三种操作就是替换一个字符,例如`horse->rorse`\n\n那么对$dp[i][j]$来说,有两种情况:\n\n1.$word1[i]=word2[j]$,这种情况下,由于最后一个字符相同,因此只要考虑两个字符串在最后一个字符之前的编辑操作,编辑次数与最后一个字符无关(因为完成了前面的操作,就完成了整个字符串的操作),有:\n$$\ndp[i][j]=dp[i-1][j-1],(word1[i]=word2[j])\n$$\n2.$word1[i]\\ne word2[j]$,这种情况下,最后一个字符不同,有三种操作方式:\n\n将字符串1最后加上一个字符,即$dp[i][j]=dp[i-1][j]+1$\n\n将字符串2最后加上一个字符,即$dp[i][j]=dp[i][j-1]+1$\n\n替换字符串1/2最后一个字符,即$dp[i][j]=dp[i-1][j-1]+1$\n\n要获得最小的编辑距离,即对以上三者取最小值\n\n**边界条件**\n\n由于第1/2个字符串第$i$位转移到空字符串的编辑操作是空字符串$+i$个字符,因此\n$$\ndp[i][0]=i\n$$\n\n$$\ndp[0][j]=j\n$$\n\n```java\nclass Solution {\n    public int minDistance(String word1, String word2) {\n        int s1=word1.length();\n        int s2=word2.length();\n        int[][] dp=new int[s1+1][s2+1];\n        for(int i=1;i<=s1;i++)dp[i][0]=i;\n        for(int i=1;i<=s2;i++)dp[0][i]=i;\n        for(int i=1;i<=s1;i++)\n        {\n            for(int j=1;j<=s2;j++)\n            {\n                if(word1.charAt(i-1)==word2.charAt(j-1))\n                {\n                    dp[i][j]=dp[i-1][j-1];\n                }\n                else\n                {\n                    dp[i][j]=1+Math.min(Math.min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]);\n                }\n                \n            }\n        }\n        return dp[s1][s2];\n    }\n}\n```\n\n\n\n\n\n\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣516 最长回文子序列","url":"/2023/04/07/d72a84b75b3b/","content":"\n![image-20230407155503108](/images/typora/image-20230407155503108.png)\n\n状态: 定义$dp[i][j]$表示$i$到$j$区间内的最长回文子序列\n\n转移: 如果第$i$位置的字符和第$j$位置的字符相同,说明回文子序列可以在原先最长的子序列长度上加二 \n\n即:\n$$\ndp[i][j]=dp[i+1][j-1]+2,String[i]=String[j]\n$$\n如果不相同,说明不能以$i$和$j$作为起点和终点,就在不是以这两个为终点的字符串中找最大值作为转移:\n$$\ndp[i][j]=max(dp[i+1][j],dp[i][j-1])\n$$\n\n```java\nclass Solution {\n    public int longestPalindromeSubseq(String s) {\n        int n=s.length();\n        int[][] dp=new int[n][n];\n        int ans=1;\n        for(int i=0;i<n;i++)\n        {\n            dp[i][i]=1;\n        }\n        for(int len=2;len<=n;len++)\n        {\n            for(int i=0;i+len-1<n;i++)\n            {\n                int j=i+len-1;\n                if(s.charAt(i)==s.charAt(j))\n                {\n                    dp[i][j]=dp[i+1][j-1]+2;\n                }\n                else\n                {\n                    dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[0][n-1];\n    }\n}\n```\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"CSAPP Lab1:datalab","url":"/2023/04/05/acf9b49a1879/","content":"\n## 1.bitXor(x,y)\n\nDescription: return x^y only using & and ~.\n\n题意:只用~和&运算符计算^\n\n思路:\n\n^:位不同时为真,相同时为假.\n\n找出x和y相同的位(例如0100和0101,第一位0,第二位1,第三位0是相同的,第四位0100是0,0101是1)\n\n`x & y`可以找出x和y同为1的位,而`~x & ~y `可以找出x和y中同为0的位.\n\n比如:`0100&0101=0100`,找出了同样为1的第二位.\n\n`~x=1011,~y=1010,~x&~y=1010`,这里的1表示两者都为0的位,在0100和0101中,第1和第3位同时为0.\n\n这时候我们可以发现,在`x & y`和`~x & ~y `中始终为0的位,是两个数中不同的位.将`x & y`和`~x & ~y `再取反,使得在两个数中不同的位变为1,相同的位变为0,再取`&`,即可得到`^`的结果(两个位不同时为真).\n\n```c\nint bitXor(int x, int y) {\n    int c;\n    c=x&y;\n    int d;\n    d=~x&~y;\n    return ~c&~d;\n}\n```\n\n## 2.tmin()\n\nDescription: return smallest two's complement integer.\n\n题意: 返回二进制补码最小数($-2^{32}$)\n\n限制:\n\n```\n/*\n * tmin - return minimum two's complement integer\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 4\n *   Rating: 1\n */\n```\n\n考虑$\\sim 0=11111....11111$,将其右移31位把所有其他位移掉得到$10000000..000$,即$-2^{32}$\n\n```c\nint tmin(void) {\n    return ~0<<31;\n}\n```\n\n## 3.isTmax(x)\n\nDescription: True only if x is largest two's comp. integer.\n\n题意: 如果$x$是最大的二进制补码,返回$1$\n\n限制:\n\n```\n/*\n * isTmax - returns 1 if x is the maximum, two's complement number,\n *     and 0 otherwise\n *   Legal ops: ! ~ & ^ | +\n *   Max ops: 10\n *   Rating: 1\n */\n```\n\n因为只有当$x$为$2^{32}-1$时,该函数返回1,从另一个角度想,因为这个数字($01111.....1111$)比较特殊,是否有一种形方法能使得$func(x)=0$,然后以$!func(x)=1$的方式输出\n\n假设$x=2^{32}-1$\n\n可以发现:$x+1=(1000...0000)_{\\text{bin}}$,此时将$x$和$x+1$取异或,能得到$x \\oplus (x+1)=(1111...1111)$,此时再$+1$即可得到$0$,返回$!s$即能得到$1$\n\n然而并不是只有$x=2^{32}-1$能通过这些运算得到最后的$!func(x)=1$,还有一个神奇的数:$-1$\n\n我们知道$-1=(1111...1111)_{\\text{bin}}$ ,如果我们对其执行上面相同的运算,可以发现:$-1+1=0=(0000...0000)_{\\text{bin}}$ ,设$y=-1$,可以发现:$y\\oplus(y+1)=(1111...1111)$,$+1$得到$0$,再取$!$则为1.\n\n而且由于$x=0111...1111$,$y=1111...1111$,可以发现$x$和$y$在$+1$后,与其自身无论进行任何一种位运算结果都相同,即最终结果都返回$1$,似乎这种思路行不通.\n\n然而,还有一个运算符:$!$\n\n由于$-1+1=0=(0000...0000)_{\\text{bin}}$ ,令$a=y+1$,容易发现$a=0$.然而,$x+1=(1000...0000)_{\\text{bin}}=-2147483648$,令$b=x+1$可以发现$b!=0$,而$a$和$b$是否等于$0$可以决定$!a$和$!b$的值不相同,从而在位运算完全相同的$-1和2^{32}-1$中区分两个数.\n\n可以发现:\n$$\nx\\oplus(x+1)=(1111...1111)_{bin}\n$$\n\n$$\nx\\oplus(x+1)+1=0\n$$\n\n$$\nx\\oplus(x+1)+1+a!=0+0=0\n$$\n\n而另一边,有:\n$$\ny\\oplus(y+1)=(1111...1111)_{bin}\n$$\n\n$$\ny\\oplus(y+1)+1=0\n$$\n\n$$\ny\\oplus(y+1)+1+b!=0+1=1\n$$\n\n最后取反,可以区别出$2^{32}-1$和$-1$\n\n```c\nint isTmax(int x) {\n    int a;\n    a=x+1;\n    int b;\n    b=x^a;\n    return !(b+1+!a);\n}\n```\n\n## 4.allOddBits(int x)\n\nDescription: True only if all odd-numbered bits in x set to 1.\n\n题意: 如果x中所有奇数位为1,那么返回真,否则返回假\n\n限制:\n\n```\n/*\n * allOddBits - return 1 if all odd-numbered bits in word set to 1\n *   where bits are numbered from 0 (least significant) to 31 (most significant)\n *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 2\n */\n```\n\n思路: \n\n创建一个只有奇数位上位1的掩码,先对$x$取$and$去除所有偶数位,之后和掩码自身做$xor$,如果两者相同(即$x$奇数位上全是掩码),那么异或后的结果为$0$,否则为$1$\n\n```c\nint allOddBits(int x) {\n    int test;\n    test=0xAA+(0xAA<<8);\n    test=test+(test<<16);\n    return !((x&test)^test);\n}\n```\n\n\n\n## 5.negate(x)\n\nDescription: return -x without using -operator.\n\n题意: 返回-x,但是不用负号\n\n限制:\n\n```\n/*\n * negate - return -x\n *   Example: negate(1) = -1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 5\n *   Rating: 2\n */\n```\n\n思路: 取反加一,最简单一题\n\n```c\nint negate(int x) {\n    return ~x+1;\n}\n```\n\n## 6.isAsciiDigit(x)\n\nDescription: return 1 if 0x30 <= x <= 0x39 (ASCII codes for characters '0' to '9')\n\n```\n/*\n * isAsciiDigit - return 1 if 0x30 <= x <= 0x39 (ASCII codes for characters '0' to '9')\n *   Example: isAsciiDigit(0x35) = 1.\n *            isAsciiDigit(0x3a) = 0.\n *            isAsciiDigit(0x05) = 0.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 3\n */\n```\n\n题意:如果输入的数x满足: $0x30\\le x\\le0x39$,返回1,否则返回0\n\n开始的思路:对0x30到0x39每个数和$x$取$xor$,总有一个是0,然后对所有取$and$,之后取反.然而由于只有15个符号位,这样做会超出很多符号位.\n\n考虑: 由于对一个数取反+1就是他的负数,不妨尝试将$0x30$和$0x39$分别取反加一,得到$-48$和$-57$,然后将这两个数加上$x$\n\n如果$x<48$,即$x<0x30$,那么$x$加上这两个数的结果都$<0$\n\n相反,如果$x>57$,即$x>0x39$那么$x$加上这两个数的结果都$>0$\n\n令两个结果为$a$与$b$,只有当$a>0$且$b<0$的时候说明$0x30\\le x \\le 0x39$\n\n为什么不是$ab<0$呢?因为当$0x80000039\\le x\\le 0x80000030$时,此时有$a<0$和$b>0$,此时$ab<0$,但是不符合题意\n\n但是无法用条件分支,我们无法分别对$a$和$b$判断,只能先用$xor$来判断$x$是否在范围内,再用$x$的符号位和$xor$之后的结果进行运算,排除$0x80000039\\le x\\le 0x80000030$的情况$(x<0)$\n\n```c\nint isAsciiDigit(int x) {\n    int signBit=x>>31;\n    //x是正数,signBit=0,最后!signBit=1\n    //x是负数,signBit=1,最后!signBit=0\n    int lowerbase=(~0x30+1);\n    int upperbase=(~0x3a+1);\n    int lowerbound=x+lowerbase;\n    int upperbound=x+upperbase;\n    lowerbound=lowerbound>>31;\n    upperbound=upperbound>>31;\n    //有符号数,算术右移,判断符号位要&1\n    lowerbound=lowerbound&1;\n    upperbound=upperbound&1;\n    return (lowerbound^upperbound)&(!signBit);\n}\n```\n\n为什么会发现除了$0x30$到$0x39$还有其他的数满足要求(如果忽略符号位计算)?一开始试出来的.为了找到原因和逻辑清晰的写法并思考清楚花了3-4个小时,原来只花了30分钟就写完了....\n\n## 7 conditional(x,y,z)\n\n```\n/*\n * conditional - same as x ? y : z\n *   Example: conditional(2,4,5) = 4\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 16\n *   Rating: 3\n */\n```\n\n思路:\n\n 条件运算是0和1的运算,当x为1时结果为y,当x=0时结果为z,那么就先将x转化为0/1的形式,再思考如何进行后面的运算.\n\n把$x$转化为$0/1$很简单,求两次$x$的非即可\n\n此时$x$已经变成$0/1$,现在要把$0/1$用位运算和$y,z$进行联系,即:如果$x=1$,运算结果为$func(0,y,z)=y$,\n\n如果$x=0$,运算结果为$func(0,y,z)=z$.先考虑如何让$y$进行位运算后仍然为$y$?对$y$和$-1(11111...111)$做$and$即可,同理,要对$z$也做$and$运算.\n\n这时候就能想到:一个对$1111...1111$进行$and$,一个对$0000...000$进行$and$,(正好这两个数是互反的,用一个$\\sim$即可完成全0与全1的转换).当$y$和$z$都这样计算了以后,留下一个值,无论他是哪个,对另外一个取$or$即可(因为一个是原来的值,一个是全0),就能保留我们需要的那个值\n\n总结思路:\n\n如果$x$为真,那么$y\\&1111...1111,z\\&0000...0000$\n\n如果$x$为假,那么$y\\&0000...0000,z\\&1111...1111$\n\n然后对两者取$or$即可\n\n最后的问题:\n\n要进行运算,如果$x=1$,$func(x)=-1$;如果$x=0$,$func(x)=0$\n\n观察发现:$1,-1,0,0$是各自的相反数,取反加一即可.\n\n```c\nint conditional(int x, int y, int z) {\n    int base;\n    base=!x;\n    base=!base;//转化为0/1\n    base=~base+1;\n    return ((y&base)|(z&(~base)));\n}\n```\n\n## 8.isLessOrEqual(x,y)\n\n```\n/*\n * isLessOrEqual - if x <= y  then return 1, else return 0\n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 24\n *   Rating: 3\n */\n```\n\n思路:\n\n起初的思路: 减一减,然后判断正负号\n\n这个基础的思路是对的,但是由于计算机内部的补码运算,会导致溢出时出差错:\n\n假设:$y=2147483647,x=-2147483648$,可以写成这样:(简化为四位)\n\n```\n 先对x取反加一:\n ~1000=0111,0111+0001=1000\n 0111\n+1000\n------\n 1111\n```\n\n可以发现,$y-x=-1$,$正数-负数=负数$,这明显是不可能的,如何解决?\n\n可以想到引入符号位:如果$y>0,x<0$,那么无论差值是多少,结果都为真\n\n总结有:\n\n符号相同,$y-x\\ge0$,结果为真\n\n符号相同,$y-x<0$,结果为假\n\n符号不同,$y\\ge0(x<0)$,结果为真\n\n符号不同,$y<0$,结果为假\n\n```c\nint isLessOrEqual(int x, int y) {\n    //符号相同看差值,符号不同正数大\n    int signX;\n    int signY;\n    signX=!!(x>>31);\n    signY=!!(y>>31);\n    int signJ;\n    signJ=!(signX^signY);\n    int negX;\n    negX=~x+1;\n    int diff;\n    diff=y+negX;\n    int signDiff;\n    signDiff=!(diff>>31);\n    return (signJ&signDiff)|((!signJ)&(!signY));\n    //signDiff=1,说明y+negX>0,否则y<x(相同符号情况下)\n}\n```\n\n\n\n## 9.logicalNeg(x)\n\n```\n/* \n * logicalNeg - implement the ! operator, using all of \n *              the legal operators except !\n *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1\n *   Legal ops: ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 4 \n */\n```\n\n思路: 取$-2147483648(minint)$,这个数减去任何正整数都会溢出到正数,减去$0$依旧是负数,因此减去$abs(x)$后取符号位\n\n```c\nint logicalNeg(int x) {\n    int minint;\n    minint=(1<<31);\n    int signBit;\n    signBit=(x>>31);\n    int absX;\n    absX=(x^signBit)+(x&1);\n    //x是正数或0,和其符号位(0)异或为自身,x&1=0\n    //x是负数,和其符号位(1)异或为取反,x&1=1\n    //这样就能实现正数与0不变,负数变为相反数,即取反加一\n    minint=minint+(~absX+1);\n    return (minint>>31)&1;//取符号位\n}\n```\n\n## 10.howManyBits(x)\n\n```\n/* howManyBits - return the minimum number of bits required to represent x in\n *             two's complement\n *  Examples: howManyBits(12) = 5\n *            howManyBits(298) = 10\n *            howManyBits(-5) = 4\n *            howManyBits(0)  = 1\n *            howManyBits(-1) = 1\n *            howManyBits(0x80000000) = 32\n *  Legal ops: ! ~ & ^ | + << >>\n *  Max ops: 90\n *  Rating: 4\n */\n```\n\n思路:\n\n一开始以为就是单纯的求每个数有几个bit,例如$howManyBits(-1)=32$(因为是1111...1111),后来才发现原来不是这样\n\n那什么是可以表示$x$的最小Bit呢?\n\n研究一下这几个数:\n\n12,二进制为1100,二进制有4位$howManyBits(12)=5$\n\n298,二进制为100101010,二进制有9位,$howManyBits(298)=10$\n\n-5,即5的二进制取反加一,二进制为1011,有4位,$howManyBits(-5)=4$\n\n0,二进制为0,一位,$howManyBits(0)=1$\n\n-1,二进制为1111...1111($int$下),有32位,$howManyBits(-1)=1$\n\n0x80000000,二进制为1000...0000,有32位,$howManyBits(0x80000000)=32$\n\n发现:\n\n正数$x$,二进制有$a$位,则$howManyBits(x)=a+1$,不难想到是由于符号位$+1$\n\n负数$y$,如果要表示$y$,取反加一只是形式上是他们对等,对$y$取反即可有与其一一对应的非负数\n\n(但是这个是我做出来之后再回去想的,有事后诸葛亮的意思),那么如何自然的想到负数的最小位表示方式就是对其取反呢?\n\n答案是$-1$,由于$-1$可以被$0$表示$(\\sim 0)$,原来这里就是$howManyBits(-1)=1$的来源\n\n而且我们知道,补码中负数和非负数形成双射,此时再考虑$0x80000000$\n\n可以发现:\n$$\n-1=(\\sim 0)\n$$\n\n$$\n0x80000000(MinInt)=(\\sim 0111...1111)(MaxInt)\n$$\n\n就可以知道本题中,负数$y$的表达方式就是把$y$进行按位非操作变成一个非负数$x$,然后与其他非负数进行相同的操作\n\n第一步:把$x$转化成非负数即:\n$$\nx = \\begin{cases}\nx, & x\\ge 0 \\\\\n\\sim x, & x < 0 \\\\\n\\end{cases}\n$$\n\n```c\nsignBit=x>>31;\nx_reverse=((~x)&(signBit))|(x&(~signBit));\n```\n\n关键是使得$or$左右两边分别在$x\\ge 0$和$x<0$的时候都有一个为$0$,用$or$可以表示出结果\n\n解释以上代码:\n\n如果$x<0$,$signBit=(1111...1111)$,`(~x)&(signBit))`可求出反,而$\\sim signBit=0$,右边代表正数的`x&(~signBit)`此时为0,取$or$后可以得到左半边的部分$\\sim x$\n\n如果$x\\ge 0$,$signBit=(0000...0000)$,`(~x)&(signBit))=0`,右边可以求出$x$本身\n\n接下来是对非负数$x$,计算他有多少个Bit\n\n这里用到二进制的思想:\n\n分别用16位1,8位1,4位1,二位1和1对$x$进行减法运算,这里用一个7位正数举例子:\n\n```\n1111101,先对1000做减法运算,结果>=0,说明这个数大于等于1000,至少有4位,Bit+4\n把该数右移四位:1111101->111\n对111和10做减法运算,发现结果依旧>=0,说明这个数大于等于100000,至少有6位,Bit=4+2\n解释:右移的意义是假设右边全变成1111101->1110000(假设的),然后与10进行减法运算其实是减去100000\n右移两位:111->1,与1做减法运算,结果>=0,说明这个数大于1000000,至少有7位,Bit=4+2+1\n由于是正数,结果+1(符号位),Bit=8\n```\n\n在题目中,由于我们对$int$求位数,因此要从16位开始进行减法运算,依次减去16位,8位,4位,2位,1位同时不断位移,这是由于二进制的性质:我们可以用$2^0\\sim2^{n-1}$的数表示出$2^0\\sim 2^n-1$的所有数,这里我们用来表示位\n\n我们先做好预处理:\n\n```c\nint Bit16;\nint Bit8;\nint Bit4;\nint Bit2;\nint Bit1;\nBit16=1<<15;\nBit8=1<<7;\nBit4=1<<3;\nBit2=1<<1;\nBit1=1;\n```\n\n一段示例代码:\n\n```c\nint plus16;\nplus16=((~(x_1+(~Bit16+1))>>31)&(16));//如果x_1(处理后的x)>=16位,这样可以得到16\ncount=count+plus16;//位数加上16\nx_1=x_1>>(plus16);//右移16位\n```\n\n解释这句代码:\n\n```c\nplus16=((~(x_1+(~Bit16+1))>>31)&(16));\n```\n\n其中\n\n```c\n(x_1+(~Bit16+1)\n```\n\n表示将处理后的$x$(这里叫$x\\_1$)和$1000...0000(16Bit)$做减法\n\n```c\n(x_1+(~Bit16+1))>>31\n```\n\n结果大于$0$,符号位为$0$,结果小于$1$,符号位为$1$,右移$31$位获得$0000...0000$和$1111...1111$\n\n```c\n((~(x_1+(~Bit16+1))>>31)\n```\n\n取反,如果大于$0$变为$1111...1111$,小于$0$变为$0000...0000$\n\n```c\n((~(x_1+(~Bit16+1))>>31)&(16))\n```\n\n如果做差结果大于$0$,左边为$1111...1111$,与$16$按位取和得到$16$(原数大于16位,位数加上16)\n\n如果做差结果小于$0$,左边为$0000...0000$,与$16$取按位和得到$0$(原数小于16位,加上0)\n\n最后右移16位,分别和8位,4位,2位,1位进行相同操作即可.\n\n```c\nint howManyBits(int x) {\n    int x_1;\n    int signBit;\n    signBit=x>>31;\n    x_1=((~x)&(signBit))|(x&(~signBit));//如果负数,求x的逆,正数不变\n    int Bit16;\n    int Bit8;\n    int Bit4;\n    int Bit2;\n    int Bit1;\n    Bit16=1<<15;\n    Bit8=1<<7;\n    Bit4=1<<3;\n    Bit2=1<<1;\n    Bit1=1;\n    int count=0;\n    int if_signBit;\n    if_signBit=1;\n    count=if_signBit;\n    int plus16;\n    plus16=((~(x_1+(~Bit16+1))>>31)&(16));\n    count=count+plus16;\n    x_1=x_1>>(plus16);\n    int plus8;\n    plus8=((~(x_1+(~Bit8+1))>>31)&(8));\n    count=count+plus8;\n    x_1=x_1>>(plus8);\n    int plus4;\n    plus4=((~(x_1+(~Bit4+1))>>31)&(4));\n    count=count+plus4;\n    x_1=x_1>>(plus4);\n    int plus2;\n    plus2=((~(x_1+(~Bit2+1))>>31)&(2));\n    count=count+plus2;\n    x_1=x_1>>(plus2);\n    int plus1;\n    plus1=((~(x_1+(~Bit1+1))>>31)&(1));\n    count=count+plus1;\n    return count;\n}\n```\n\n## 11.unsigned floatScale2(unsigned uf)\n\n```\n/* \n * floatScale2 - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\n```\n\n复习一下浮点数的表示方式:\n\nIEEE浮点标准用$V=(-1)^s\\times M\\times 2^E$的形式来表示一个浮点数\n\n**符号(sign)** $s$决定这是负数($s=1$)还是正数($s=0$),对于数值0的符号位特殊处理\n\n**尾数(significand)** $M$是一个二进制小数,范围是$1\\sim 2-ε$,或者是$0\\sim 1-ε$\n\n**阶码(exponent)** $E$的作用是对浮点数加权,这个权重是$2$的$E$次幂\n\n![image-20230411124726712](/images/typora/image-20230411124726712.png)\n\n![image-20230411124743281](/images/typora/image-20230411124743281.png)\n\n本题中,求$2\\times f$,先要考虑特殊情况:\n\n**特殊情况1:无穷大与NaN**\n\n当$f$为无穷大或者是$NaN$时,可以发现其$exp=255$(二进制下的$11111111$),在32位数的第24到31位之间.\n\n可以用$uf \\& 01111111...0000$来求得$exp$\n\n换算为十六进制为$0x7f800000$\n\n因此,有\n\n```c\nint exp=(0x7f800000&uf)>>23;\n```\n\n如果$f$为无穷大或者$NaN$,那么$2\\times f$也是无穷大或者$NaN$,此时只要返回其自身就可以了,即:\n\n```c\nif(exp==255)return uf;\n```\n\n**特殊情况2:为非规格化浮点数(exp=0)**\n\n此时$exp=0$,浮点数的形式为:\n$$\nV=(-1)^s\\times1\\times M\n$$\n此时要将$f\\times2$,只要将$f<<1$,并保持原来的符号位\n\n$M$的范围从$0 \\sim 1-ε$变成了$1\\sim 2-ε$,可以把$exp$最左位也视为$M$的一部分\n\n```\n0 0000 101表示exp=0,M=0.625(M=f),阶码E的值为1-Bias(非规格化浮点数),该数V=1*(-6)*0.625\n0 0001 010表示exp=1,M=1.25(M=1+f),阶码E的值为e-Bias=1-Bias,该数V=1*(-6)*1.25\n```\n\n这是一个例子,我们可以发现在非规格化浮点数中$M=f$,规格化浮点数中$M=1+f$可以使得$f\\ge0.5$时,$f\\times2$可以直接通过左移一位从非规格化浮点数转化成规格化浮点数,真是巧妙\n\n注意还要保留原来的符号位\n\n```c\nint signBit=uf&(1<<31);\nif(exp==0)return(signBit|uf<<1);\n```\n\n**特殊情况3:exp+1后为255**\n\n这种情况下$f\\times 2$溢出了,会变成无穷大,保留符号位取无穷大:\n\n```c\nexp++;\nif(exp==255)return(signBit|0x7f800000);\n```\n\n**普通情况(规格化浮点数)**\n\n如果$f$是规格化浮点数,那么$M=1+frac$,不会发生改变,$f\\times2$也不会溢出,只要把指数+1后变回去,然后再取原来的小数和浮点数部分即可\n\n```c\nreturn(exp<<23)|(uf&0x807fffff);\n```\n\n完整代码:\n\n```c\nunsigned floatScale2(unsigned uf) {\n    int signBit = uf & (1 << 31);\n    int exp = (0x7f800000 & uf) >> 23;\n    if (exp == 0)return (signBit | uf << 1);\n    if (exp == 255)return uf;\n    exp++;\n    if (exp == 255)return (signBit | 0x7f800000);\n    return (exp << 23) | (uf & 0x807fffff);\n}\n```\n\n## 12.floatFloat2Int(unsigned uf)\n\n```\n/*\n * floatFloat2Int - Return bit-level equivalent of expression (int) f\n *   for floating point argument f.\n *   Argument is passed as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point value.\n *   Anything out of range (including NaN and infinity) should return\n *   0x80000000u.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\n```\n\n![image-20230411154948339](/images/typora/image-20230411154948339.png)\n\n我们可以发现,浮点数和整数的转换就是:\n\n```\n整数->二进制整数\n二进制整数->小数*2^n,其中n=小数点后位数\nn<=精度(比如单精度是23位精度),在小数点后的进制后数补上(x-n),其中x为精度位数,这里是(23-13)=10位0\n小数部分构造完成\n构造阶码\nn(小数点后位数)+偏置量(单精度127)=140\n阶码转化为二进制\n加上符号位\n```\n\n浮点数转化到整数就是逆过程(几乎,但不完全一样)\n\n在开始之前,先思考有几种特殊情况:\n\n**特殊情况1:偏置量小于0**\n\n偏置量小于$0$说明浮点数没有整数部分,原数是小数,直接返回$0$\n\n**特殊情况2:偏置量大于31**\n\n偏置量大于$31$说明这个数的位数大于$31$,已经超出了$int$能表示的范围,返回$0x80000000$\n\n**特殊情况3:原数为0**\n\n在浮点数中,$0$是可以有正负号的,但是浮点数$0$在符号位之后全为$0$,因此有判断$0$的方式:\n\n```c\nif(!(uf&(0x7fffffff)))return 0;\n```\n\n特殊情况判断完了,接下来就对普遍情况进行计算:\n\n先求出原先的二进制数:\n\n```c\nint frac=uf&0x007fffff|0x00800000;\n```\n\n其中,`|0x00800000`的原因是在浮点数转化为整数时,舍去了最前面的1,现在要补回来(看上方课本)\n\n```c\nif(E<23)frac=frac>>(23-E);\nif(E>=23)frac=frac<<(E-23);\n```\n\n如果不到23位,原先补0,现在右移去0\n\n超过了23位,直接左移变大\n\n除此之外,还有正负性问题:\n\n如果起初为负数,符号不同(变成正数了),那么要变回负数\n\n```c\nint floatFloat2Int(unsigned uf) {\n    int exp=uf&(0x7f800000);\n    exp=exp>>23;\n    int E=exp-127;\n    unsigned frac=(uf&0x007fffff)|(0x00800000);\n\n    if(E>31)return 0x80000000;\n    if(E<0)return 0;\n\n    if(E>23)frac=frac<<(E-23);\n    if(E<=23)frac=frac>>(23-E);\n    if (uf>>31) frac *= -1;\n    return frac;\n}\n```\n\n**特别注意**\n\n```c\nint exp=uf&(0x7f800000);\nexp=exp>>23;\nexp=exp-127\n```\n\n和\n\n```c\nint exp=(uf&(0x7f800000)>>23)-127;\n```\n\n在评测机上的结果不同,暂未发现为什么,为了debug这个困扰了一个多小时\n\n\n\n## 13.floatPower2(x)\n\n```\n/*\n * floatPower2 - Return bit-level equivalent of the expression 2.0^x\n *   (2.0 raised to the power x) for any 32-bit integer x.\n *\n *   The unsigned value that is returned should have the identical bit\n *   representation as the single-precision floating-point number 2.0^x.\n *   If the result is too small to be represented as a denorm, return\n *   0. If too large, return +INF.\n *\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. Also if, while\n *   Max ops: 30\n *   Rating: 4\n */\n```\n\n思路:\n\n2.0的浮点数在计算机中表示为:\n$$\n2.0=(-1)^0\\times2^1\\times1\n$$\n($2$的二进制为$10$,去掉第一位后剩下的作为$frac$保存)\n\n其中$M=1$,这意味着$f=0$,即小数位全为$0$,因此我们只要对阶码做加减法后左移就可以算出$2.0^x$的值\n\n```c\nunsigned floatPower2(int x) {\n    if(x>127)return 0x7f800000u;//大于规格化浮点数能表示的上限,变为无穷大\n    if(x<-126)return 0;//小于非规格化浮点数能表示的下限,变0\n    int exp=127+x;//算出阶码,即2的exp次方\n    exp=exp<<23;\n    return exp;\n}\n```\n\n## 尾声\n\n2023.4.11 18:27写完了这篇笔记,第一次尝试做国外大学的作业.大概做了一个星期左右,还做得挺艰难的,而这只是CSAPP中最简单的Lab罢了,仍需继续努力.\n\n![image-20230411183217388](/images/typora/image-20230411183217388.png)\n\n$End.$\n","tags":["CSAPP"],"categories":["笔记"]},{"title":"力扣1000 合并石头的最低成本","url":"/2023/04/04/cceb555ddbc3/","content":"\n## 题目描述\n\n![image-20230404142607216](/images/typora/image-20230404142607216.png)\n\n## 思路\n\n经典区间dp，首先考虑合并两个石头$(k=2)$的情况\n\n此时很容易根据区间dp得到状态转移方程：\n$$\ndp[i][j]=min(dp[i][j],dp[i][p]+dp[p+1][j]+cost)\n$$\n其中$dp[i][j]$表示合并$i$和$j$个石头间所有石头的最小花费\n\n那么当一次要合并的石头多于2个怎么办？考虑加入一个新的状态$k$，表示把石头合并成$k$堆，即\n$$\ndp[i][j][k]\n$$\n表示的是合并$i$到$j$的石头为$k$堆的最小成本\n\n### 状态转移方程：\n\n1.$dp[i][j][1]=dp[i][j][k]+sum[i,j]$，即要把$k$堆（题目要求的一次合并石头的数量）合并成一堆，就是加上这堆石头里所有的花费。\n\n2.$dp[i][j][m]=min(dp[i][j][m],dp[i][p][1]+dp[p+1][j][m-1])$其中$i<=p<j,2<=m<=k$，把$i$到$j$的所有石头合并为$m$堆的最小花费为其自身，或挑选一个中间点$p$，将$p$左边的一堆和右边的$m-1$堆合并为一堆。由于$p$和$m$都会遍历，因此无论左边的一堆还是右边的一堆都没有区别。\n\n### 讨论边界/初始化情况：\n\n$dp[i][i][1]=0$\n\n最终结果为$dp[1][n][1]$\n\n初始化所有情况为$dp[i][j][k]=INF$\n\n### 什么情况下无解？\n\n由于最后石头会被合并成一堆，因此石头必然能被合并成$k$堆，而$k$堆中的每一堆都是被原始的$n$堆合并而来。每次合并$k$个数，即每次操作减少$k-1$个数（将$k$个石头合并为$1$个），有\n$$\n(n-1)mod(k-1)==0\n$$\n其中$n-1$代表除了最后一个石头的所有石头数量,$(k-1)*n$表示合并了$n$次,每次减少$k-1$个石头,为了剩余一个石头,$k-1$要被$n$整除\n\n```java\nclass Solution {\n    public int mergeStones(int[] stones, int k) {\n        int n=stones.length;\n        final int maxx=1145141919;\n        int[] sum=new int[n+1];\n        int[][][] dp=new int[n+1][n+1][k+1];\n        if((n-1)%(k-1)!=0)return -1;\n        for(int i=1;i<=n;i++)sum[i]=sum[i-1]+stones[i-1];\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=i;j<=n;j++)\n            {\n                for(int m=2;m<=k;m++)\n                    dp[i][j][m]=maxx;\n            }\n            dp[i][i][1]=0;\n        }\n        for(int len=2;len<=n;len++)\n        {\n            for(int i=1;i+len-1<=n;i++)\n            {\n                int j=i+len-1;\n                for(int m=2;m<=k;++m)\n                {\n                    for(int p=i;p<j;p+=k-1)//********************\n                    {\n                        dp[i][j][m]=Math.min(dp[i][j][m],dp[i][p][1]+dp[p+1][j][m-1]);\n                    }\n                }\n                dp[i][j][1]=dp[i][j][k]+sum[j]-sum[i-1];\n            }\n        }\n        return dp[1][n][1];\n    }\n}\n```\n\n### 细节\n\n在标$*$行,发现分割点的跨度是$k-1$,这是由于要把左边合并成一堆,在上面证明过$(n-1)mod(k-1)=0$时石头才能合并为一堆,如果跨度为1,石头必不能合并为一堆,会浪费大量时间.\n\n\n\n\n\n","tags":["动态规划","区间dp"],"categories":["题解"]},{"title":"力扣1567 乘积为正数的最长子数组长度","url":"/2023/04/01/cae96d1c6b79/","content":"\n# 1567 [乘积为正数的最长子数组长度](https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/)\n\n![image-20230401000903394](/images/typora/image-20230401000903394.png)\n\n## 思路：\n\n由乘法的奇偶性很容易想到对乘积是奇数和乘积是偶数的数组长度分别进行维护\n\n故，维护数组$positive[i]$和$negative[i]$表示以$i$为下标为终点的最大乘积为正与负的数组的长度，分别对两个数组进行讨论：\n\n初始：\n$$\npositive[0]=1,nums[0]>0\n$$\n\n$$\nnegative[0]=1,nums[0]<0\n$$\n\n这是由于当$nums[0]>0$时，以$0$为终点下标的且最大乘积为正的数组的长度为$1$，这个数组即为\n\n$\\lbrace\\,{nums[0]}\\,\\rbrace$\n\n反之亦然\n\n从$i=1$开始：\n\n当$nums[i]>0$，有：\n$$\npositive[i]=positive[i-1]+1\n$$\n\n$$\nnegative[i] = \n\\begin{cases}\nnegative[i-1] + 1, & negative[i-1] > 0 \\\\\n0, & negative[i-1] = 0\n\\end{cases}\n$$\n\n$positive[i]$代表乘积为正的数组长度，由于正数$*$正数依旧是正数，因此当$nums[i]>0$时，乘积为正的数组长度$+1$即可\n\n当$negative[i-1]$不等于$0$时，由于正数$*$负数是负数，因此数组长度也$+1$就行了\n\n为什么当$negative[i-1]=0$时候$negative[i]=0$？因为之前没有乘积为负数的数组，无论存在乘积为正数的数组或是$0$都不能使乘上一个正数的积为负数，因此当$negative[i-1]=0$时候依旧有$negative[i]=0$。\n\n当$nums[i]<0$，有：\n$$\npositive[i]=\n\\begin{cases}\n0, & \\text{if } negative[i-1]=0 \\\\\nnegative[i-1]+1, & \\text{if } negative[i-1]>0\n\\end{cases}\n$$\n\n$$\nnegative[i]=negative[i-1]+1\n$$\n\n由于负数$*$负数为正数，因此当$negative[i-1]>0$时，$positive[i]=negative[i-1]+1$\n\n同上，由于不存在负数与 $0$ 可以使得$nums[i],nums[i]<0$与$0$相乘的积为正数，因此当 $negative[i-1]=0$时，$positive[i]=0$\n\n最后，当$nums[i]=0$时，有：\n$$\npositive[i]=0\n$$\n\n$$\nnegative[i]=0\n$$\n\n```java\nclass Solution {\n    public int getMaxLen(int[] nums) {\n        int n=nums.length;\n        int negative[]=new int[n];\n        int postive[]=new int[n];\n        if(nums[0]<0)negative[0]=1;\n        if(nums[0]>0)postive[0]=1;\n        for(int i=1;i<n;i++)\n        {\n            if(nums[i]>0)\n            {\n                postive[i]=postive[i-1]+1;\n                if(negative[i-1]==0)negative[i]=0;\n                if(negative[i-1]!=0)negative[i]=negative[i-1]+1;\n                continue;\n            }\n            else if(nums[i]<0)\n            {\n                if(negative[i-1]==0)postive[i]=0;\n                if(negative[i-1]>0)postive[i]=negative[i-1]+1;\n                negative[i]=postive[i-1]+1;\n                continue;\n            }\n            else\n            {\n                postive[i]=0;\n                negative[i]=0;\n            }\n        }\n        int maxx=0;\n        for(int i=0;i<n;i++)\n        {\n            maxx=Math.max(maxx,postive[i]);\n        }\n        return maxx;\n    }\n}\n```\n\n\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣413 等差数列划分","url":"/2023/03/31/96deb2c3c449/","content":"\n## 力扣413 等差数列划分\n\n![image-20230331235627133](/images/typora/image-20230331235627133.png)\n\n先确定状态：用$dp[i]$表示以第$i$个为结尾的等差子数列的数量\n\n观察数列$[1,2,3,4]$，先对数列中的每个等差子数组观察：$[1,2,3],[2,3,4],[1,2,3,4]$可以发现，如果$[a_i,...,a_j]$是等差子数列，如果$[a_i,...,a_j,a_{j+1}]$也是等差子数列，那么$dp[j+1]=dp[j]+1$ \n\n例如，在$[1,2,3,4]$中，$dp[3]=1([1,2,3]),dp[4]=2([2,3,4],[1,2,3,4])$，如果该数组是$[1,2,3,4,5]$，则可以发现$dp[5]=3([3,4,5],[2,3,4,5],[1,2,3,4,5])$，将其推广到通用形式，可以发现$[a_i,...,a_j,a_{j+1}]$在$length=3,4,...,j-i$的子等差数列都能与$[a_i,...,a_j]$中的形成双射，多了一个$length=j-i+1$的子等差数列，这就是递推公式$dp[j+1]=dp[j]+1$的来源\n\n\n\n```java\nclass Solution {\n    public int numberOfArithmeticSlices(int[] nums) {\n        int n=nums.length;\n        if(n<3)return 0;\n        int[] f=new int[n];\n        for(int i=1;i<n-1;i++)\n        {\n            if(nums[i+1]-nums[i]==nums[i]-nums[i-1])\n            {\n                f[i+1]=f[i]+1;\n            }\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)ans+=f[i];\n        return ans;\n        \n    }\n}\n\n```\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣312 戳气球","url":"/2023/03/31/36d75772171a/","content":"\n# 力扣312 戳气球（动态规划）\n\n![image-20230401000505067](/images/typora/image-20230401000505067.png)\n\n### 分治：一种自顶向下的思路\n\n戳破气球发现气球从不相邻变为相邻，后续难以处理，倒过来看这个过程，将过程看作添加气球。\n\n定义方法$solve$，用$solve(i,j)$表示将开区间$(i,j)$能获得的最大硬币数。由于是开区间，区间两端气球编号为$i,j$，对应$val[i]$和$val[j]$\n\n当$i+1>=j$时，$i$和$j$之间没有气球，此时$solve(i,j)=0$\n\n当$i+1<j$时，枚举开区间$(i,j)$之间所有元素$mid$，令$mid$为当前区间内第一个添加的气球，该操作能得到的硬币数为：$val[i]*val[mid]*val[j]$，同时递归的计算$(i,mid)$和$(mid,j)$区间对最终答案的贡献，这三项和的最大值即为$solve(i,j)$的值\n\n即：\n$$\nsolve(i,j)=solve(i,mid)+val[i]*val[mid]*val[j]+solve(mid,j),i+1<j\n$$\n\n为什么要令$mid$为当前区间内第一个添加的气球？因为我们是倒过来看这个过程的，在区间内戳破最后一个气球在逆过程中就是第一个添加的气球，以此类推\n\n为什么戳破气球得到的硬币数是$val[i]*val[mid]*val[j]$？\n\n由于$mid$是区间内添加的第一个气球，也是戳破的最后一个气球\n\n假设原来有气球：$1,2,3,4,5$\n\n$mid$为$4$，即在这个区间内最后一个戳破/第一个添加的气球是$4$，那么戳破该气球时，区间是这样的：\n\n$1,4,5$\n\n因为$2,3$在之前都已经被戳破了，可以发现，戳破$4$气球获得的硬币只和区间两端的端点有关\n\n用代码表示，即：\n\n```java\npublic int solve(int left,int right)\n    {\n        if(left>=right-1)return 0;\n        if(f[left][right]!=-1)return f[left][right];\n        for(int i=left+1;i<right;i++)\n        {\n            int sum=val[left]*val[i]*val[right];\n            sum+=solve(left,i)+solve(i,right);//分治处理左右区间（开区间）\n            f[left][right]=Math.max(f[left][right],sum);\n        }\n        return f[left][right];\n    }\n```\n\n### 动态规划：自底向上\n\n在分治中用$solve(i,j)$表示开区间$(i,j)$能获得的最大硬币数，在动态规划中可以用二维数字$f[i][j]$来表示，通过小区间求出大区间，直到最后求出最大的区间。\n\n```java\nclass Solution {\n    public int f[][];\n    public int val[];\n    public int maxCoins(int[] nums) {\n        int n=nums.length;\n        val=new int[n+2];\n        System.arraycopy(nums, 0, val, 1, n);\n        val[0]=val[n+1]=1;\n        f=new int [n+2][n+2];\n        for(int bet=2;bet<n+2;bet++)//区间长度，从2开始到n+1\n        {\n            for(int l=0;l+bet<n+2;l++)\n            {\n                int r=l+bet;\n                for(int mid=l+1;mid<l+bet;mid++)\n                {\n                    int sum=val[l]*val[mid]*val[r];\n                    sum+=f[l][mid]+f[mid][r];\n                    f[l][r]=Math.max(f[l][r],sum);\n                }\n            }\n        }\n        return f[0][n+1];\n    }\n}\n```\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"力扣91 解码方法","url":"/2023/03/31/8e54280232df/","content":"## 力扣 91 解码方法\n\n![image-20230401000549763](/images/typora/image-20230401000549763.png)\n\n确定状态：用$dp[i]$表示以$i$为终点下标的消息的解码方法数\n\n对于每个$i$，可能有两种情况：$s[i]$是一个独立的字母或者$s[i-1]+s[i]$构成一个字母\n\n可以用$s[i]-'0'$直接将字符转化成数字。令$a=s[i]-'0',b=s[i-1]-'0'$\n\n接下来对递推关系进行讨论：\n\n当$0<a<10$时，$dp[i]=dp[i-1]$，因为这是对字符串$s[0:i]$的解码方法就是在对字符串$s[0:i-1]$的解码方法上增加一个对单个字母的解释。\n\n如：字符串$12$可以解释为$AB,L$，字符串$127$可以解释为$ABG,LG$，$dp[3]=dp[3-1]=dp[2]$，这是由于单个字符的解释不会增加解释方法数，只是增加一个字母。\n\n当$9<b*10+a<27$时，$s[i-1]+s[i]$既可以解释为两个独立的字母，也可以解释为一个字母，那么$dp[i]=dp[i-1]+dp[i-2]$。因为此时$s[0:i]$的解码方法可以是$s[0:i-2]$加一个字母或$s[0:i-1]$加一个字母，因此方法是两种字符串解释方法之和。\n\n除了这些，还有特殊情况：带0的情况\n\n考虑一个字符串$abcdef0jskldx$\n\n此时，如果$f$是$1,2$，那么$f0$可以解释为$10(j)$或$20(t)$，否则中间会多一个无法解释的$0$，直接return 0\n\n```java\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        int n=s.size();\n        if(s[0]=='0')return 0;\n        s=\" \"+s;\n        vector<int> dp(n+1,0);\n        dp[0]=1;\n        for(int i=1;i<=n;i++)\n        {\n            int a=s[i]-'0',b=s[i-1]-'0';\n            if(a==0)\n            {\n                if(b==1 || b==2)dp[i]=dp[i-2];\n                else return 0;\n            }\n            else\n            {\n                if(a>0 && a<10)dp[i]=dp[i-1];\n                if(b*10+a>=10 && b*10+a<=26)dp[i]=dp[i-1]+dp[i-2];\n            }\n        }\n        return dp[n];\n    }\n};\n\n```\n\n","tags":["动态规划"],"categories":["题解"]},{"title":"AC Automaton","url":"/2022/07/30/0b4cf2e4435f/","content":"\n```cpp\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int maxn = 1e6 + 10;\nint n;\nint trie[maxn][30];\nstring s, ss;\nint cntword[maxn];//用来记录单词结尾\nint fail[maxn];\nint cnt = 0;\n\nvoid Insert(string s)//字典树插入操作\n{\n\tint root = 0;\n\tint len = s.length();\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tint ch = s[i] - 'a';\n\t\tif (!trie[root][ch])\n\t\t\ttrie[root][ch] = ++cnt;\n\t\troot = trie[root][ch];\n\t}\n\tcntword[root]++;//不断的插入到深处，此时root已是最后一个单词\n\t//说明走到当前节点又多了一个单词，单词数+1\n}\nvoid getfail()//构造trie树的fail指针\n{\n\tqueue<int> q;\n\tfor (int i = 0; i < 26; i++)//预处理第二行，fail指针全部指向根\n\t{\n\t\tif (trie[0][i])\n\t\t{\n\t\t\tfail[trie[0][i]] = 0;\n\t\t\tq.push(trie[0][i]);//把第二行的点加入队列，之后继续处理\n\t\t}\n\t}\n\twhile (!q.empty())\n\t{\n\t\tint now = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tif (trie[now][i])//枚举所有子节点，子节点存在的情况\n\t\t\t{\n\t\t\t\tfail[trie[now][i]] = trie[fail[now]][i];\n\t\t\t\t//子节点的fail指针指向当前结点的fail指针指向结点的相同（字符）子节点\n\t\t\t\tq.push(trie[now][i]);//把儿子也压入队列\n\t\t\t}\n\t\t\telse//子节点不存在的情况\n\t\t\t\ttrie[now][i] = trie[fail[now]][i];\n\t\t\t//当前节点子节点指向当前节点fail指针指向节点\n\t\t}\n\t}\n}\nint AC_query(string s)//此串是文本串\n{\n\tint len = s.length();\n\tint now = 0, ans = 0;\n\tfor (int i = 0; i < len; i++)//遍历文本串\n\t{\n\t\tint ch = s[i] - 'a';\n\t\tnow = trie[now][ch];//trie树向下一层\n\t\tfor (int j = now; j && cntword[j] != -1; j = fail[j])\n\t\t//一直向下查找，直到匹配失败（失败指针指向根节点/当前节点已经找过\n\t\t{\n\t\t\tans += cntword[j];//加上当前节点单词数\n\t\t\tcntword[j] = -1;//标记，当前节点已找过\n\t\t}\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> s;\n\t\tInsert(s);\n\t}\n\tfail[0] = 0;\n\tgetfail();\n\tcin >> ss;\n\tcout << AC_query(ss) << endl;\n\treturn 0;\n}\n```","tags":["字符串","AC自动机"],"categories":["笔记"]},{"title":"P4824 [USACO15FEB] Censoring S","url":"/2022/07/29/c1c3813e68e2/","content":"\n# [USACO15FEB] Censoring S\n\n## 题面翻译\n\nFarmer John为他的奶牛们订阅了Good Hooveskeeping杂志，因此他们在谷仓等待挤奶期间，可以有足够的文章可供阅读。不幸的是，最新一期的文章包含一篇关于如何烹制完美牛排的不恰当的文章，FJ不愿让他的奶牛们看到这些内容。\n\nFJ已经根据杂志的所有文字，创建了一个字符串  $ S $  ( $ S $  的长度保证不超过  $ 10^6 $  )，他想删除其中的子串  $ T $  ,他将删去  $ S $ 中第一次出现的子串  $ T $  ，然后不断重复这一过程，直到  $ S $  中不存在子串  $ T $ 。\n\n注意：每次删除一个子串后，可能会出现一个新的子串  $ T $ （说白了就是删除之后，两端的字符串有可能会拼接出来一个新的子串  $ T $ ）。\n\n输入格式：第一行是字符串  $ S $  ，第二行输入字符串  $ T $ ，保证  $ S $  的长度大于等于  $ T $  的长度， $ S $  和  $ T $  都只由小写字母组成。\n\n输出格式：输出经过处理后的字符串，保证处理后的字符串不会为空串。\n\nTranslated by @StudyingFather\n\n## 题目描述\n\nFarmer John has purchased a subscription to Good Hooveskeeping magazine for his cows, so they have plenty of material to read while waiting around in the barn during milking sessions. Unfortunately, the latest issue contains a rather inappropriate article on how to cook the perfect steak, which FJ would rather his cows not see (clearly, the magazine is in need of better editorial oversight).\n\nFJ has taken all of the text from the magazine to create the string $S$ of length at most 10^6 characters. From this, he would like to remove occurrences of a substring $T$ to censor the inappropriate content. To do this, Farmer John finds the **_first_** occurrence of $T$ in $S$ and deletes it. He then repeats the process again, deleting the first occurrence of $T$ again, continuing until there are no more occurrences of $T$ in $S$. Note that the deletion of one occurrence might create a new occurrence of $T$ that didn't exist before.\n\nPlease help FJ determine the final contents of $S$ after censoring is complete.\n\n## 输入格式\n\nThe first line will contain $S$. The second line will contain $T$. The length of $T$ will be at most that of $S$, and all characters of $S$ and $T$ will be lower-case alphabet characters (in the range a..z).\n\n## 输出格式\n\nThe string $S$ after all deletions are complete. It is guaranteed that $S$ will not become empty during the deletion process.\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\nwhatthemomooofun\nmoo\n```\n\n### 样例输出 #1\n\n```\nwhatthefun\n```\n\n## 思路\n\n一开始的思路非常简单：跑一遍kmp，对于一个字符串重复匹配，如果匹配到有子串用string.erase来擦除掉子串，然后重新匹配，直到没有重复为止\n\n然而当数据很多时这个算法复杂度非常大（假设整个文本串都是模式串的循环），时间复杂度会爆炸\n\n正解：kmp+栈\n\n思路很简单：每次匹配的时候把文本串匹配到的序号入栈，如果匹配到子串就把它出栈，接着继续入栈\n\n如何做？\n\n```cpp\nvoid kmp(string pat, string txt)\n{\n\tint len1 = pat.length();\n\tint len2 = txt.length();\n\tfor (int i = 0, j = 0; i < len2; i++)\n\t{\n\t\twhile (j && pat[j] != txt[i])\n\t\t{\n\t\t\tj = nxt[j - 1];\n\t\t}\n\t\tif (txt[i] == pat[j])\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\tst[++top] = i;//***\n\t\tf[i] = j;//***\n\t\tif (j == len1)\n\t\t{\n\t\t\ttop -= len1;\n\t\t\tj = f[st[top]];//***\n\t\t}\n\t}\n}\n```\n在上述代码中，f[]代表的是当文本串匹配到第i位时，模式串匹配到第j位，它的存在意义是：由于修改后的字符串被占所决定，那么这个数组能保存入栈前的状态，方便出栈后继续匹配。\n\n例：\n\n文本串114514，匹配串45\n\n$$st[1]=1,st[2]=1,st[3]=4,st[4]=5,st[5]=1,st[6]=4$$\n\n$$f[1]=0,f[2]=0,f[3]=1,f[4]=2,f[5]=0,f[6]=1$$\n\n不难看出当 $i=4$ 时 $j=2,top=4$ ，跳出循环，之后 $top-=2$ ，即文本串和模式串从第二位开始重新匹配。那么要匹配第二位的时候模式串原先匹配到的位数 $j$ （这里是0，因为他们没有相同前缀）已经存在 $f[]$ 中了，可以直接取出来立刻进行匹配。\n\n另一种说法：$f[]$ 存储了第 $i$ 位模式串和文本串有 $j$ 位相同前缀，因此只要继续从模式串的 $j$ 位开始匹配即可。\n\n```cpp\n#include<iostream>\n#include<cstring>\nusing namespace std;\nstring s1, s2;\nint nxt[1000010],top;\nint st[1000010],f[1000010];\nvoid build_nxt(string pat)\n{\n\tint len = pat.length();\n\tfor (int i = 1, j = 0; i < len; i++)\n\t{\n\t\twhile (j && pat[i] != pat[j])\n\t\t{\n\t\t\tj = nxt[j - 1];\n\t\t}\n\t\tif (pat[i] == pat[j])\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\tnxt[i] = j;\n\t}\n}\nvoid kmp(string pat, string txt)\n{\n\tint len1 = pat.length();\n\tint len2 = txt.length();\n\tfor (int i = 0, j = 0; i < len2; i++)\n\t{\n\t\twhile (j && pat[j] != txt[i])\n\t\t{\n\t\t\tj = nxt[j - 1];\n\t\t}\n\t\tif (txt[i] == pat[j])\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\tst[++top] = i;\n\t\tf[i] = j;\n\t\tif (j == len1)\n\t\t{\n\t\t\ttop -= len1;\n\t\t\tj = f[st[top]];\n\t\t}\n\t}\n}\nint main()\n{\n\tcin >> s1;\n\tcin >> s2;\n\tint len = s2.length();\n\tbuild_nxt(s2);\n\tkmp(s2, s1);\n\tfor (int i = 1; i <= top; i++)\n\t\tcout << s1[st[i]];\n}\n```","tags":["KMP","字符串","栈"],"categories":["题解"]},{"title":"2022牛客暑期多校赛2.D","url":"/2022/07/28/9006a786f31c/","content":"## 题意\n给定 $n (n<2000)$ 个物品和 $m(m<1000)$ 个关系，其中 $a_i$ 个物品 $b_i$ 可以制造出 $c_i$ 个物品 $d_i$ ，这样会导致能无限制造物品（例如1个a制造两个b，一个b制造两个c，一个c制造两个d，可以无限刷物品），希望给所有制造出来的物品数量乘上一个数 $w_i$ ,使得不能够无限刷物品，求 $w_i$ 的最小值。\n\n## 思路\n很明显的可以发现是一道图论+二分的题目，于是gyx写了一下午然后寄了。\n\n为什么？\n\n在建立边的时候，可以发现 $b$ 点和 $d$ 点之间的边权是 $w*c_i/a_i$ ，那么这个边权一定是一个浮点数。朴素的思想就是不断沿着边作乘法，找出一个环使得 $x$ 可以制造出大于一个 $x$ ，那么这就是不合格的，用二分找 $w$。\n\n这个思路是有问题的\n\n为什么？\n\n由于绝大多数时候，$c_i/a_i$都是小于1的，进行一大堆连乘以后精度爆炸会导致结果直接等与0。\n\n如何解决？\n\n答案是取对数，这样对于小于1的数，他们都会变成一些较大的负数。\n\n$$log(x*y)=log(x)+log(y)$$\n\n因此把所有的数都取对数，可以解决精度问题。\n\n而且如此我们可以发现，这样可以把乘法问题转化为了加法问题。原本沿边作乘法：\n\n$$( w * c_1 / a_1 )*( w * c_2/ a_2 )*...*( w * c_n / a_n )$$\n\n现在就变成了沿着边作加法：\n\n$$(w+c_1-a_1)+(w+c_2-a_2)+(w+c_3-a_3)$$\n\n原先判断不合格的要求是沿着环乘起来大于 $1$ ，转化为对数就是加起来大于 $0$ ，即判断图内是否存在负环。\n\n做法更加明了：$SPFA$ 判断负环。\n\n### SPFA如何判断负环\n\nSPFA本质上是通过对每个节点通过其他节点作为中间节点，然后再到达该节点进行松弛，由于有 $N$ 个节点，因此每个节点最多被松弛 $N-1$ 次，那么当一个节点被松弛超过 $N-1$ 次（两点之间距离在更新了 $N-1$ 次之后还能被更新），说明两点之间有超过 $N-1$ 条最短路，即存在负环。\n\n```cpp\n#include <iostream>\n#include<queue>\nusing namespace std;\nint n, m,cnt;\ndouble dis[2020];\nbool vis[2020];\nint head[2020],tot[2020];\nstruct edge {\n\tint to;\n\tint nxt;\n\tdouble w;\n}Edge[2020];\nvoid addedge(int u, int v, double w)\n{\n\tEdge[++cnt].to = v;\n\tEdge[cnt].w = w;\n\tEdge[cnt].nxt = head[u];\n\thead[u] = cnt;\n}\nbool spfa(double mid);\nint main()\n{\n\tcin >> n >> m;\n\twhile (m--)\n\t{\n\t\tint ai, bi, ci, di;\n\t\tcin >> ai >> bi >> ci >> di;\n\t\taddedge(bi, di, -log(ci*1.0/ai));//由于ci/ai一般小于1，取对后为负数，因此取反\n\t}\n\tdouble l = 0, r = 1.0;\n\twhile (r - l >= 1e-8)\n\t{\n\t\tdouble mid = (l + r) / 2.0;\n\t\tif (spfa(-log(mid)))//mid也小于1，取反\n\t\t{\n\t\t\tl = mid;\n\t\t}\n\t\telse\n\t\t\tr = mid;\n\t}\n\tprintf(\"%.6lf\", l);\n\treturn 0;\n}\nbool spfa(double mid)\n{\n\tqueue<int> q;\n\tmemset(dis, 0x3f, sizeof(dis));\n\tdis[1] = 0;\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(tot, 0, sizeof(tot));\n\tfor (int i = 1; i <= n; i++)//负环不一定是到源点的路径上产生的，把所有点入队列\n\t\tq.push(i), vis[1] = 1;\n\twhile (!q.empty())\n\t{\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tvis[u] = false;\n\t\tfor (int i = head[u]; i; i = Edge[i].nxt)\n\t\t{\n\t\t\tint to = Edge[i].to;\n\t\t\tif (dis[to] > dis[u] + Edge[i].w + mid)//原本是乘法，取对数转化为加法（每次乘w代表每经过一条边都要加w）\n\t\t\t{\n\t\t\t\tdis[to] = dis[u] + Edge[i].w + mid;\n\t\t\t\ttot[to] = tot[u] + 1;\n\t\t\t\tif (tot[to] >= n)return false;//说明有负环\n\t\t\t\tif (!vis[to])\n\t\t\t\t{\n\t\t\t\t\tq.push(to);\n\t\t\t\t\tvis[to] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n\n```","tags":["图论","二分","数学"],"categories":["题解"]},{"title":"KMP","url":"/2022/07/27/b296652ba7f6/","content":"\nhttps://zhuanlan.zhihu.com/p/105629613\n\n```cpp\n#include<iostream>\n#include<cstring>\nusing namespace std;\n#define maxn 1000010\nchar s1[maxn], s2[maxn],cnt=0;\nint nxt[maxn];\n//next数组的本质：寻找子串中相同前后缀的长度，并且一定是最长的前后缀\n//记录了失配后要跳转到模式串的哪个位置\n//前后缀不能是字符串本身\n//如何处理nxt数组？考虑用模式串自己匹配自己(用前缀匹配后缀）\n/*\n什么是nxt数组？\nnxt[i]是：pat[0]往后数，pat[i]往前数相同的位数，保证前后缀相同，能数多少位\n*/\nvoid build_next(char pat[])\n{\n\tint len = strlen(pat);//求模式串长度\n\tfor (int i = 1, j = 0; i < len; i++)//错位一位，让pat匹配自己（防止匹配整个串）\n\t//pat[0]=0，之后每一位用j来记录\n\t{\n\t\twhile (j && pat[i] != pat[j])//字符失配，跳过字符\n\t\t{\n\t\t\tj = nxt[j - 1];\n\t\t}\n\t\tif (pat[i] == pat[j])//匹配成功，j右移一位\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\tnxt[i] = j;//计算出nxt[i]（见上定义）\n\t}\n}\n\nvoid kmp(char s1[], char s2[])\n{\n\tint lena = strlen(s1), lenb = strlen(s2);\n\tfor (int i = 0, j = 0; i < lena; i++)\n\t{\n\t\twhile (j && s1[i] != s2[j])//字符失配，根据nxt跳过子串的一些字符\n\t\t{\n\t\t\tj = nxt[j - 1];\n\t\t}\n\t\tif (s1[i] == s2[j])\n\t\t{\n\t\t\tj++;//匹配成功，指针右移\n\t\t}\n\t\tif (j == lenb)//整个字符串匹配完了\n\t\t{\n\t\t\tcout << i - j + 2 << endl;//输出位置\n\t\t\tj = nxt[j - 1];//j继续往右移动\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> s1 >> s2;\n\tbuild_next(s2);\n\tkmp(s1, s2);\n\tfor (int i = 0; i < strlen(s2); i++)\n\t\tcout << nxt[i] << \" \";\n\treturn 0;\n} \n```\n","tags":["KMP","字符串"],"categories":["笔记"]},{"title":"字典树","url":"/2022/07/27/905bc6844e49/","content":"\n# 字典树\n\n什么是字典树？\n\n字典树，是关于“字典”的一棵树，是一串针对字符串进行维护的数据结构。它是对于字典的一种存储方式，对于每个单词，从根节点出发到某一目标节点，路径书上所有节点连起来就是一个单词。\n\n如图，我们目前有6个字符串：animal anxiety apple cross cxy qzh\n构成了一棵树，其中具有相同前缀的字符串在树上具有部分相同的结构。可以看出字典树的本质是把很多字符串拆成单个字符的形式存储起来，所以说其维护的是“字典”。\n\n\n![Trie树图解](https://github.com/KillingCommendatore/KillingCommendatore.github.io/blob/main/images/Trie%E6%A0%91%E8%A7%A3%E9%87%8A%E5%9B%BE.jpg?raw=true)\n\n## 字典树的应用：\n\n1.维护字符串集合（字典）\n\n2.向字典中插入字符串（建树）\n\n3.查询字典中是否含有某个字符串（查询）\n\n4.统计字符串在集合中出现的个数（统计）\n\n5.将字符串集合按字典序排序（排序）\n\n6.求两个字符串的最长公共前缀\n\n## 字典树的实现\n\n字典树的两种基本操作是建树和查询。\n\n### 建树基本思路：\n\n开一个数组 $tree[100010][65]$（不严格），对于字符串的每一个字符查询该字符对应数字（如'a'对应0）是否建立节点，如果建立节点那么跳到下一个字符并且向深处插入，如果没有建立节点就在该处建立节点。\n\n举例：目前有两个单词 $anxiety$ 和 $animal$ \n\n先对 $anxiety$ 进行建树，可以发现此前并无任何节点，那么过程有：\n\n$tree[0][a]=1$\n\n$tree[a][n]=2$\n\n$tree[n][x]=3$\n\n$tree[x][i]=4$\n\n$...$\n\n建完以后，再对 $animal$ 进行建树：\n\n发现：\n\n$tree[0][a]$ 是已经建立好的节点，那么不用新建立了，直接看下一个节点\n\n发现： $tree[a][n]$ 也建立好了，继续看下一个节点\n\n$tree[n][i]$ 未被建立，那么建立该节点，$tree[n][i]=8$\n\n如何判断一个节点是否被建立？即从该字符到下一个字符是否有编号：\n\n```cpp\nif (tree[root][ch] == 0)//对应的数字没有建立节点\n\ttree[root][ch] = ++cnt;//新节点的编号\n```\n对于查询操作而言，基本思路与插入操作相同。\n\n如果没找到节点返回0，所有节点都找到退出循环后返回1。\n\n\n### 初始化\n\n把字符转化成数字存储在字典种\n```cpp\nint getnum(char x)//将字符转化成0-62之间的数字\n{\n\tif (x >= 'A' && x <= 'Z')\n\t\treturn x - 'A';\n\telse if (x >= 'a' && x <= 'z')\n\t\treturn x - 'a' + 26;\n\telse\n\t\treturn x - '0' + 52;\n}\n```\n### 插入操作\n\n```cpp\nvoid Insert(char str[])//插入操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//对应的数字没有建立节点\n\t\t\ttree[root][ch] = ++cnt;//新节点的编号\n\t\troot = tree[root][ch];//向深处插入\n\t}\n}\n```\n\n### 查询操作\n\n```cpp\nint Search(char str[])//查询操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//没有查询到这个节点，退出\n\t\t\treturn 0;\n\t\troot = tree[root][ch];//查询到了，继续向深处查询\n\t}\n\treturn 1;\n}\n```\n\n# 洛谷题面\n\n## 【模板】字典树\n\n## 题目描述\n\n给定 $n$ 个模式串 $s_1, s_2, \\dots, s_n$ 和 $q$ 次询问，每次询问给定一个文本串 $t_i$，请回答 $s_1 \\sim s_n$ 中有多少个字符串 $s_j$ 满足 $t_i$ 是 $s_j$ 的**前缀**。\n\n一个字符串 $t$ 是 $s$ 的前缀当且仅当从 $s$ 的末尾删去若干个（可以为 0 个）连续的字符后与 $t$ 相同。\n\n输入的字符串大小敏感。例如，字符串 `Fusu` 和字符串 `fusu` 不同。\n\n## 输入格式\n\n**本题单测试点内有多组测试数据**。  \n\n输入的第一行是一个整数，表示数据组数 $T$。\n\n对于每组数据，格式如下：  \n第一行是两个整数，分别表示模式串的个数 $n$ 和询问的个数 $q$。  \n接下来 $n$ 行，每行一个字符串，表示一个模式串。  \n接下来 $q$ 行，每行一个字符串，表示一次询问。\n\n## 输出格式\n\n按照输入的顺序依次输出各测试数据的答案。  \n对于每次询问，输出一行一个整数表示答案。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n3\n3 3\nfusufusu\nfusu\nanguei\nfusu\nanguei\nkkksc\n5 2\nfusu\nFusu\nAFakeFusu\nafakefusu\nfusuisnotfake\nFusu\nfusu\n1 1\n998244353\n9\n```\n\n### 样例输出 #1\n\n```\n2\n1\n0\n1\n2\n1\n```\n\n## 提示\n\n### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq T, n, q\\leq 10^5$，且输入字符串的总长度不超过 $3 \\times 10^6$。输入的字符串只含大小写字母和数字，且不含空串。\n\n### 说明\nstd 的 IO 使用的是关闭同步后的 cin/cout，本题不卡常。\n\n## 思路\n\n为每个节点建立数量数组 $sum[]$ ，对于每个节点（节点代表了从根节点到目前节点的这串单词），在插入操作时在每个节点+1，即：\n\n```cpp\nvoid Insert(char str[])//插入操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//对应的数字没有建立节点\n\t\t\ttree[root][ch] = ++cnt;//新节点的编号\n\t\troot = tree[root][ch];//向深处插入\n\t\tsum[root]++;//从0节点到该节点（即一个前缀）的数量+1\n\t}\n}\n```\n\n在查询操作时，如果查询到该字符串，直接返回最后一个节点（字符串的最后一个字符）的sum值即可\n\n```cpp\nint Search(char str[])//查询操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//没有查询到这个节点，退出\n\t\t\treturn 0;\n\t\troot = tree[root][ch];//查询到了，继续向深处查询\n\t}\n\treturn sum[root];//返回插入操作中弄好的数量\n}\n```\n\n所有代码：\n```cpp\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int mxn = 3e6 + 10;\nint tree[mxn][65], cnt = 0, sum[mxn];\nchar s[mxn];\nint n, m;\nint getnum(char x)//将字符转化成0-62之间的数字\n{\n\tif (x >= 'A' && x <= 'Z')\n\t\treturn x - 'A';\n\telse if (x >= 'a' && x <= 'z')\n\t\treturn x - 'a' + 26;\n\telse\n\t\treturn x - '0' + 52;\n}\nvoid Insert(char str[])//插入操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//对应的数字没有建立节点\n\t\t\ttree[root][ch] = ++cnt;//新节点的编号\n\t\troot = tree[root][ch];//向深处插入\n\t\tsum[root]++;//从0节点到该节点（即一个前缀）的数量+1\n\t}\n}\nint Search(char str[])//查询操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//没有查询到这个节点，退出\n\t\t\treturn 0;\n\t\troot = tree[root][ch];//查询到了，继续向深处查询\n\t}\n\treturn sum[root];//返回插入操作中弄好的数量\n}\nint main()\n{\n\tint T = 0;\n\tcin >> T;\n\twhile (T--)\n\t{\n\t\tfor (int i = 0; i <= cnt; i++)//从0开始，因为字符转换成数字也是从0开始\n\t\t\tfor (int j = 0; j <= 64; j++)\n\t\t\t\ttree[i][j] = 0;\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t\tsum[i] = 0;\n\t\tcnt = 0;\n\t\tcin >> n >> m;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> s;\n\t\t\tInsert(s);\n\t\t}\n\t\tfor (int i = 1; i <= m; i++)\n\t\t{\n\t\t\tcin >> s;\n\t\t\tcout << Search(s) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```","tags":["字符串","字典树"],"categories":["笔记"]},{"title":"字符串hash","url":"/2022/07/26/7c7df27e203e/","content":"\n# 字符串哈希\n\n### 为什么要学习字符串哈希\n\nC++在比较两个字符串的时候效率不高，需要设计一种更高效的算法来匹配字符串。\n\n用途：\n\n1.判断两个字符串是否相等\n\n2.判断一个字符串是否出现过\n\n### 什么是哈希\n\nHash，一般称为散列，音译为哈希，是将任意长度的输入通过散列算法变换成固定的输出，该输出就是散列值\n\n即：把字符串赋予进制和模数，把每一个字符映射成一个小于等于模数的数字。\n\n例如：取进制为32进制，模数为1145141919810，字符串 'qzh' 的哈希值为：\n\n$ASCII[q]*32^2+ASCII[z]*32^1+ASCII[h]*32^0$  $mod$  $114514$\n\n可以算出该字符串的hash值为$113*32*32 + 122*32 + 104=119720$ \n\n但是，Hash并非完美无缺：当另外一个字符串的Hash值等与119720时，便会出现两个字符串共用hash值，但是两个字符串并不相同，即Hash冲突。\n\n如何解决Hash冲突问题？\n\n1.模数选择大质数\n\n选择小质数会导致有剩余系过小，hash冲突概率增大，选合数会导致剩余系的浪费。\n\n2.双模数Hash\n\n用两种不同方法hash，然后比对每一种hash值是否相同，增加了空间和时间，但是也增加了正确性。\n\n洛谷字符串Hash题面：\n\n## 【模板】字符串哈希\n\n## 题目描述\n\n如题，给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。\n\n\n友情提醒：如果真的想好好练习哈希的话，请自觉，否则请右转PJ试炼场:)\n\n## 输入格式\n\n第一行包含一个整数 $N$，为字符串的个数。\n\n接下来 $N$ 行每行包含一个字符串，为所提供的字符串。\n\n## 输出格式\n\n输出包含一行，包含一个整数，为不同的字符串个数。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5\nabc\naaaa\nabc\nabcc\n12345\n```\n\n### 样例输出 #1\n\n```\n4\n```\n\n## 提示\n\n对于 $30\\%$ 的数据：$N\\leq 10$，$M_i≈6$，$Mmax\\leq 15$。\n\n对于 $70\\%$ 的数据：$N\\leq 1000$，$M_i≈100$，$Mmax\\leq 150$。\n\n对于 $100\\%$ 的数据：$N\\leq 10000$，$M_i≈1000$，$Mmax\\leq 1500$。\n\n\n样例说明：\n\n样例中第一个字符串(abc)和第三个字符串(abc)是一样的，所以所提供字符串的集合为{aaaa,abc,abcc,12345}，故共计4个不同的字符串。\n\n\nTip：\n感兴趣的话，你们可以先看一看以下三题：\n\nBZOJ3097：http://www.lydsy.com/JudgeOnline/problem.php?id=3097\n\nBZOJ3098：http://www.lydsy.com/JudgeOnline/problem.php?id=3098\n\nBZOJ3099：http://www.lydsy.com/JudgeOnline/problem.php?id=3099\n\n如果你仔细研究过了（或者至少仔细看过AC人数的话），我想你一定会明白字符串哈希的正确姿势的^\\_^\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst unsigned long long mod=212370440130137957ll;//搞个大模数\nconst unsigned int basee=32;//32进制\nconst int prime=19260817;//搞个大质(xin)数(wen)\nint cnt=0;\nunsigned long long N,a[10010];\nunsigned long long hsh(char n[])\n{\n\tunsigned long long ans=0;\n\tint length=strlen(n);\n\tfor(int i=0;i<length;i++)//每个字符都hash一下\n\t{\n\t\tans=(ans*basee+n[i])%mod+prime;//每次都取模并加上大质数\n\t}\n\treturn ans;//返回该字符串的哈希值\n}\nint main()\n{\n\tcin>>N;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tchar s[1510]={0};\n\t\tcin>>s;\n\t\ta[i]=hsh(s);\n\t}\n\tsort(a+1,a+N+1);\n\tfor(int i=1;i<=N;i++)\n\t\tif(a[i]!=a[i+1])cnt++;\n\tcout<<cnt;\n\treturn 0;\n}\n```","tags":["字符串","哈希"],"categories":["笔记"]},{"title":"暑期中段反思","url":"/2022/07/10/a97c74d48428/","content":"\n## 汇编语言没好好学\n\n教汇编语言的朱教授相当好，但是课没好好听，作业也没有好好做，感觉很愧疚。今天（7/10）要把第二次上机和之前的作业都补完，早点睡觉，明天好好听课。\n\n## ACM也荒废了\n\n自从上汇编以后就再也没写过题\n\n## 浪费大量时间在懂球帝上\n\n切尔西恼人的夏季转会窗，花了很多时间看新闻，甚至和巴萨球迷对喷，这些都是没有意义的。说实话，我在考虑写个自动搬运新闻的bot去推特上爬取新闻，这样就不用看评论区而可以享受到纯净新闻了。\n\n目前卸载了懂球帝，之后用电脑端看看新闻吧，再也不要陷入骂战了。\n\n好好学汇编和acm，再学一门新语言。","tags":["碎碎念"],"categories":["随笔"]},{"title":"线段树代码注释","url":"/2022/07/04/f1225d3398cc/","content":"线段树笔记见：https://zhuanlan.zhihu.com/p/106118909 \n\n非常优秀的一篇笔记，个人感觉看完以后完全弄懂了，认为我没必要再花精力写一篇不如它且不能太增长个人理解的笔记。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=100010;\nint n,m,A[maxn*4],mark[maxn*4],tree[maxn*4];\nvoid buildtree(int l=1,int r=n,int p=1)\n{\n\tif(l==r)//到了叶子节点，l=r\n\t\ttree[p]=A[l];//注意这里是树的编号\n\telse\n\t{\n\t\tint mid=(l+r)/2;\n\t\tbuildtree(l,mid,2*p);//左右递归建立线段树\n\t\tbuildtree(mid+1,r,2*p+1);\n\t\ttree[p]=tree[2*p]+tree[2*p+1];//等与左右区间之和\n\t}\n}\nvoid push_down(int p,int len)//传递懒惰标记函数，p是节点编号，len是区间长度\n{\n\tmark[p*2]+=mark[p];//传递给左右区间，原先可能已经有懒惰标记因此是+=\n\tmark[p*2+1]+=mark[p];\n\ttree[p*2]+=mark[p]*(len-len/2);//左右区间权值加上懒惰标记（加了多少）乘区间长度\n\ttree[p*2+1]+=mark[p]*(len/2);//右区间短一点\n\tmark[p]=0; \n}\nvoid upd(int l,int r,int d,int p=1,int cl=1,int cr=n)\n//cl与cr是当前区间，l和r是要求的区间，d是加了多少\n{\n\tif(cl>r || cr<l)return;\n\telse if(cl>=l && cr<=r)\n\t{\n\t\ttree[p]+=d*(cr-cl+1);//区间加上权值乘区间长度\n\t\tif(cr>cl)\n\t\t\tmark[p]+=d;//不是叶子节点，打上懒惰标记\n\t}\n\telse\n\t{\n\t\tint mid=(cl+cr)/2;\n\t\tpush_down(p,cr-cl+1);//左右区间打上懒惰标记\n\t\tupd(l,r,d,p*2,cl,mid);//继续往下更新左右区间\n\t\tupd(l,r,d,p*2+1,mid+1,cr);\n\t\ttree[p]=tree[2*p]+tree[2*p+1];//加一加\n\t}\n}\nint qry(int l,int r,int p=1,int cl=1,int cr=n)\n{\n\tif(cl>r || cr<l)\n\t\treturn 0;\n\telse if(cl>=l && cr<=r)\n\t\treturn tree[p];\n\telse\n\t{\n\t\tint mid=(cl+cr)/2;\n\t\tpush_down(p,cr-cl+1);\n        //之前更新的时候有不少没有清除的懒惰标记，在询问中把懒惰标记加到区间上\n\t\treturn qry(l,r,p*2,cl,mid)+qry(l,r,p*2+1,mid+1,cr);//左右区间相加\n\t}\n}\nsigned main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>A[i];\n\tbuildtree();\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint opt;\n\t\tcin>>opt;\n\t\tif(opt==1)\n\t\t{\n\t\t\tint x,y,k;\n\t\t\tcin>>x>>y>>k;\n\t\t\tupd(x,y,k);\n\t\t}\n\t\telse if(opt==2)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tcout<<qry(x,y)<<endl; \n\t\t}\n\t}\n\treturn 0;\n}\n```","tags":["线段树"],"categories":["笔记"]},{"title":"算法学习笔记（2）-st表","url":"/2022/07/02/d8b19258ae62/","content":"\n# 【模板】ST 表\n\n## 题目背景\n\n这是一道 ST 表经典题——静态区间最大值\n\n**请注意最大数据时限只有 0.8s，数据强度不低，请务必保证你的每次查询复杂度为 $O(1)$。若使用更高时间复杂度算法不保证能通过。**\n\n## 题目描述\n\n给定一个长度为 $N$ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。\n\n## 输入格式\n\n第一行包含两个整数 $N,M$，分别表示数列的长度和询问的个数。\n\n第二行包含 $N$ 个整数（记为 $a_i$），依次表示数列的第 $i$ 项。\n\n接下来 $M$ 行，每行包含两个整数 $l_i,r_i$，表示查询的区间为 $[l_i,r_i]$。\n\n## 输出格式\n\n输出包含 $M$ 行，每行一个整数，依次表示每一次询问的结果。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n8 8\n9 3 1 7 5 6 0 8\n1 6\n1 5\n2 7\n2 6\n1 8\n4 8\n3 7\n1 8\n```\n\n### 样例输出 #1\n\n```\n9\n9\n7\n7\n9\n8\n7\n9\n```\n\n## 提示\n\n对于 $30\\%$ 的数据，满足 $1\\le N,M\\le 10$。\n\n对于 $70\\%$ 的数据，满足 $1\\le N,M\\le {10}^5$。\n\n对于 $100\\%$ 的数据，满足 $1\\le N\\le {10}^5$，$1\\le M\\le 2\\times{10}^6$，$a_i\\in[0,{10}^9]$，$1\\le l_i\\le r_i\\le N$。\n\n## 什么是st表\n\nST 表是用于解决 **可重复贡献问题** 的数据结构。主要用于解决 **RMQ** 问题，主要应用 **倍增** 的思想，可以实现区间最值的 $O(nlogn)$ 预处理， $O(1)$ 查询。\n\n### 可重复贡献问题\n\n举例来说：要你求10个数中的最大数，你完全可以先求前6个数的 $max$ ，再求后7个数的 $max$ ，然后再对所求的两个最大数求 $max$ 。虽然中间有四个数被重复计算了，但并不影响最后的答案。\n\n**常见的可重复贡献问题有：** 区间最值、区间按位和、区间按位或、区间GCD等。二而像区间和这样的问题就不是可重复贡献问题。\n\n**RMQ问题** RMQ问题即区间最大最小值问题，是英文 Range Maximum/Minimum Query 的缩写。\n\n### st表的构建\n\nst表基于倍增算法，用一个二维数组 $f[i][j]$ 表示区间 $[i,i+2^j-1]$ 内的最值，显然 $f[i][0]=max(i,i)=num_i$\n\n由倍增思想可知：跳 $2^i$ 步等与先跳 $2^{i-1}$ 步再跳 $2^{i-1}$ 步，因此，区间 $[i,i+2^j-1]$ 的最值可以看作区间 $[i,i+2^{j-1}-1]$ 的最值和区间 $[i+2^{j-1},i+2^j-1]$ 的最值。\n\n可以得到dp公式： $f[i][j]=max(f[i][j-1],f[i+2^{j-1}][j-1])$ \n\n$f[i][j-1]$ ：$i$ 向右跳 $2^{j-1}$ 步\n\n$f[i+2^{j-1}][j-1]$ ： $i+2^{j-1}$ 向右跳 $2^{j-1}$ 步，其中 $i+2^{j-1}$ = $f[i][j-1] + 1$\n\n接下来通过枚举区间长度 $j$ 和起点 $i$ 可构建出st表。 \n\n原理如图所示\n![](https://pic4.zhimg.com/80/v2-22d8a24faea894fb8ddceae627093bbf_1440w.jpg)\n\n```cpp\nfor(int j=1;j<=lg;j++)\n\tfor(int i=1;i+(1<<j)-1<=n;i++)//跳跃的范围要小于n（边界）\n\t\tf[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);\n```\n\n### 处理询问\n\n当处理区间 $[l,r]$ 内的最值时，我们需要找到两个 $[l,r]$ 的子区间，使得其并集正好是 $[l,r]$ （不必不相交）。具体地，我们要找一个整数 $s$ ，使得两个子区间分别为 $[l,l+2^s-1]$ 和 $[r-2^s+1,r]$ 。\n![](https://pic4.zhimg.com/80/v2-9d09b3492f0c0cbaa7555a56b22c1693_1440w.jpg) \n我们希望前一个子区间的右端点尽可能接近 $r$ （我们倾向于直接输出 $f[l][r]$）。因此，当 $l+2^s-1=r$ 时，有 $s=log_2(r-l+1)$ （这时 $r-2^s+1=l$ 也成立）。由于 $s$ 是整数，我们向下取整。\n\n同时，每次计算log过于耗费时间，我们在最开始对log进行预处理：\n```cpp\nvoid pre()\n{\n\tlogn[1]=0,logn[2]=1;\n\tfor(int i=3;i<maxn;i++){\n\t\tlogn[i]=logn[i/2]+1;//向下取整\n\t}\n}\n```\n\n在线查询：\n```cpp\nfor(int i=1;i<=m;i++)\n{\n\tint l,r;\n\tscanf(\"%d%d\",&l,&r);\n\tint lg=logn[r-l+1];\n\tint ans=max(f[l][lg],f[r-(1<<lg)+1][lg]);\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n### 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100010;\nconst int logN=22;\nint f[maxn][25],n,m,logn[maxn+1];\nvoid pre()//预处理log值\n{\n\tlogn[1]=0,logn[2]=1;\n\tfor(int i=3;i<maxn;i++){\n\t\tlogn[i]=logn[i/2]+1;\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&f[i][0]);\n\tpre();\n\tfor(int i=1;i<=logN;i++)\n\t\tfor(int j=1;j+(1<<i)-1<=n;j++)\n\t\t\tf[j][i]=max(f[j][i-1],f[j+(1<<(i-1))][i-1]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tint lg=logn[r-l+1];\n\t\tint ans=max(f[l][lg],f[r-(1<<lg)+1][lg]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```","tags":["st表"],"categories":["笔记"]},{"title":"P2015 二叉苹果树","url":"/2022/07/01/72b062651e38/","content":"# 二叉苹果树\n\n## 题目描述\n\n有一棵苹果树，如果树枝有分叉，一定是分二叉（就是说没有只有一个儿子的结点）\n\n这棵树共有 $N$ 个结点（叶子点或者树枝分叉点），编号为 $1 \\sim N$，树根编号一定是 $1$。\n\n我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有 $4$ 个树枝的树：\n\n```\n2   5\n \\ / \n  3   4\n   \\ /\n    1\n```\n\n现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。\n\n给定需要保留的树枝数量，求出最多能留住多少苹果。\n\n## 输入格式\n\n第一行 $2$ 个整数 $N$ 和 $Q$，分别表示表示树的结点数，和要保留的树枝数量。\n\n接下来 $N-1$ 行，每行 $3$ 个整数，描述一根树枝的信息：前 $2$ 个数是它连接的结点的编号，第 $3$ 个数是这根树枝上苹果的数量。\n\n## 输出格式\n\n一个数，最多能留住的苹果的数量。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5 2\n1 3 1\n1 4 10\n2 3 20\n3 5 20\n```\n\n### 样例输出 #1\n\n```\n21\n```\n\n## 提示\n\n$1 \\leqslant Q < N \\leqslant 100$，每根树枝上的苹果 $\\leqslant 3 \\times 10^4$。\n\n## 思路\n\n和选课一样同为树形背包，对于每一个节点有：\n\n$f[x][i]=max(f[x][i],f[x][i-j-1]+f[son][j]+e[i].cost)$\n\n其中 $f[x][i]$ 代表以 $x$ 为节点，保留 $i$ 根树枝能获得的最多苹果树。观察右边式子 $f[x][i-j-1]+f[son][j]+e[i].cost$ 可以发现，另一个选择是在子树上选择 $j$ 根树枝，那为什么根上的树枝要减去 $j+1$ 根呢？因为根和子树也要连起来，他们中间也需要一根树枝进行连接，它的苹果数量即 $e[i].cost$ 。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=110;\nint cnt,n,q,head[N*2],f[N][N];\nstruct edge{\n\tint to,nxt,cost;\n}e[N*2];\nvoid add(int u,int v,int w)\n{\n\te[++cnt].to=v;\n\te[cnt].cost=w;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dp(int x)\n{\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tdp(e[i].to);//从子结构开始进行dp\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].to;\n\t\tfor(int j=q;j>=1;j--)//q是最多保留树枝，即从容量开始倒序查找，与一维01背包同理\n\t\t{\n\t\t\tfor(int k=j-1;k>=0;k--)//子树上的树枝要少于根上的树枝\n\t\t\t{\n\t\t\t\tf[x][j]=max(f[x][j],f[x][j-k-1]+f[v][k]+e[i].cost);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\tadd(u,v,w);\n\t}\n\tdp(1);\n\tcout<<f[1][q];\n\treturn 0;\n}\n```","tags":["树形结构","树形dp","树形背包"],"categories":["题解"]},{"title":"综合训练洛谷题单","url":"/2022/07/01/4f0e948c3e36/","content":"洛谷试炼场的题目确实很具有代表性，但是近几年以来，又有许多经典题目出现在 OI 界中，这个大题单就是作为洛谷试炼场的扩展和补充。\n\n## Copyleft\n\n[![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.zh)\n\n本项目采用 [知识共享署名-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-sa/4.0/deed.zh) 以及附加的 [The Star And Thank Author License](https://github.com/zTrix/sata-license) 进行许可。\n\n换言之，您可以自由的共享并演绎该项目，但是必须给出必要的署名，并以相同方式共享本项目，并为本项目的 [Github 仓库](https://github.com/SFOI-Team/luogu-problem-list) 点赞（Star）。\n\n## 新版本食用指南\n\n**本次版本更新变更较大，建议您仔细阅读下面的内容！**\n\n在刚刚更新的 2.0 版本中，我们改变了原来按知识难度排列知识点的目录结构，改为按照专题大类组织目录结构。\n\n为了方便按知识难度刷题的用户，这里给出一些建议：\n\n- 对于初学者，建议先完成 Part 1,2 两部分内容，为接下来的学习打好基础。\n- 对于要参加 CSP-S 的选手，建议在前面的基础上优先完成 Part 3.1-3.4, 4.1-4.4, 6.1-6.5, 7.1-7.8, 8.1-8.7 的内容（具体内容见下），在此基础上继续完成其他内容。\n- 每个专题下的题目先给出模板，剩下的题目均按照难度递增顺序排序，部分难度较高的综合性题目建议达到一定能力后再尝试解决。\n\n## 更新日志\n\n3.0.2 2020/2/28：\n\n1. 添加了少量比赛题目；\n2. 移除了一些做法重复的题目。\n\n3.0.1 2019/12/8：\n\n1. 添加了 CSP2019 和一些公开赛的题目；\n2. 跟进洛谷域名更换，将题目链接全部更新。\n\n3.0 2019/10/13：\n\n1. 新增专题：回文自动机，K-D Tree，自适应辛普森法，左偏树，置换群，离线算法，构造，DLX，三分法，珂朵莉树。\n2. 添加了一些最近的公开比赛题目，部分专题补充了一些优质题目。\n3. 移除了部分重复题目。\n4. 对之前没有介绍的专题补充了介绍。\n\n[更早版本的更新日志请点击这里查看](https://github.com/SFOI-Team/luogu-problem-list/blob/master/history.md)\n\n## Part 0 试机题\n\n> 三道试机题目。\n\n- [P1000 超级玛丽游戏](https://www.luogu.com.cn/problem/P1000)\n- [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001)\n- [P1008 三连击](https://www.luogu.com.cn/problem/P1008)\n\n## Part 1 入门阶段\n\n> 本部分内容针对入门 OIer ，主要是语言基础内容。\n\n### Part 1.1 从零开始\n\n> 语言基础题。\n\n- [P1421 小玉买文具](https://www.luogu.com.cn/problem/P1421)\n- [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)\n- [P1089 津津的储蓄计划](https://www.luogu.com.cn/problem/P1089)\n- [P1085 不高兴的津津](https://www.luogu.com.cn/problem/P1085)\n- [P1035 级数求和](https://www.luogu.com.cn/problem/P1035)\n- [P1980 计数问题](https://www.luogu.com.cn/problem/P1980)\n- [P1014 Cantor表](https://www.luogu.com.cn/problem/P1014)\n- [P1307 数字反转](https://www.luogu.com.cn/problem/P1307)\n\n### Part 1.2 数组基础\n\n> 数组可以用于存储大量的信息。\n\n- [P1046 陶陶摘苹果](https://www.luogu.com.cn/problem/P1046)\n- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)\n- [P1427 小鱼的数字游戏](https://www.luogu.com.cn/problem/P1427)\n- [P2141 珠心算测验](https://www.luogu.com.cn/problem/P2141)\n- [P5594 【XR-4】模拟赛](https://www.luogu.com.cn/problem/P5594)\n\n### Part 1.3 字符串基础\n\n> 字符串是特殊的数组，但它也有很多自身的特点。\n\n- [P5015 标题统计](https://www.luogu.com.cn/problem/P5015)\n- [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)\n- [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)\n- [P2010 回文日期](https://www.luogu.com.cn/problem/P2010)\n- [P1012 拼数](https://www.luogu.com.cn/problem/P1012)\n- [P5587 打字练习](https://www.luogu.com.cn/problem/P5587)\n\n### Part 1.4 函数，递归及递推\n\n> 这是初学者最难理解的部分，建议画出递归图来理解递归的过程。\n\n- [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)\n- [P1036 选数](https://www.luogu.com.cn/problem/P1036)\n- [P1464 Function](https://www.luogu.com.cn/problem/P1464)\n- [P5534 【XR-3】等差数列](https://www.luogu.com.cn/problem/P5534)\n- [P1192 台阶问题](https://www.luogu.com.cn/problem/P1192)\n- [P1025 数的划分](https://www.luogu.com.cn/problem/P1025)\n- [P4994 终于结束的起点](https://www.luogu.com.cn/problem/P4994)\n\n## Part 2 基础算法\n\n> 这一部分的内容包含了 OI 中的基础算法，供各位巩固基础。\n>\n> 当然，这里面也有一些难度比较高的题目。\n\n### Part 2.1 模拟\n\n> 模拟，顾名思义就是题目要求你做什么你就做什么，这样的题目很考验选手的代码组织能力。\n>\n> 这里不仅仅有非常基础的模拟，也有一些非常复杂的题目。\n\n- [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)\n- [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)\n- [P1328 生活大爆炸版石头剪刀布](https://www.luogu.com.cn/problem/P1328)\n- [P1563 玩具谜题](https://www.luogu.com.cn/problem/P1563)\n- [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)\n- [P1179 数字统计](https://www.luogu.com.cn/problem/P1179)\n- [P2615 神奇的幻方](https://www.luogu.com.cn/problem/P2615)\n- [P3952 时间复杂度](https://www.luogu.com.cn/problem/P3952)\n- [P2482 [SDOI2010]猪国杀](https://www.luogu.com.cn/problem/P2482)\n- [P5380 [THUPC2019]鸭棋](https://www.luogu.com.cn/problem/P5380)\n\n### Part 2.2 排序算法\n\n> 通过排序，我们可以将数据有序化，这让我们对数据的处理方便了很多。\n\n- [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)\n- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)\n- [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068)\n- [P1051 谁拿了最多奖学金](https://www.luogu.com.cn/problem/P1051)\n- [P1309 瑞士轮](https://www.luogu.com.cn/problem/P1309)\n- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)\n\n### Part 2.3 二分答案\n\n> 对一个满足单调性质的问题，我们可以采用二分答案的方法来解决。\n\n- [P1024 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)\n- [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)\n- [P1824 进击的奶牛](https://www.luogu.com.cn/problem/P1824)\n- [P1902 刺杀大使](https://www.luogu.com.cn/problem/P1902)\n- [P1314 聪明的质监员](https://www.luogu.com.cn/problem/P1314)\n- [P1083 借教室](https://www.luogu.com.cn/problem/P1083)\n- [P4343 [SHOI2015]自动刷题机](https://www.luogu.com.cn/problem/P4343)\n\n### Part 2.4 分治\n\n> 分治，即分而治之，将大问题分解为小问题，分别求解，最后合并结果。\n\n- [P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)\n- [P1010 幂次方](https://www.luogu.com.cn/problem/P1010)\n- [P1429 平面最近点对（加强版）](https://www.luogu.com.cn/problem/P1429)\n- [P3612 [USACO17JAN]Secret Cow Code](https://www.luogu.com.cn/problem/P3612)\n\n### Part 2.5 贪心\n\n> 贪心，指的是决策时都采取当前最优解的算法。有的时候，这样做确实可以获得最优解。\n\n- [P1208 [USACO1.3]Mixing Milk](https://www.luogu.com.cn/problem/P1208)\n- [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995)\n- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)\n- [P1199 三国游戏](https://www.luogu.com.cn/problem/P1199)\n- [P2672 推销员](https://www.luogu.com.cn/problem/P2672)\n- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)\n- [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)\n- [P5521 [yLOI2019]梅深不见冬](https://www.luogu.com.cn/problem/P5521)\n\n### Part 2.6 构造\n\n> 构造题是一种形式灵活多样的题型。正是因为这个特点，使得构造题没有一种通用的方法。\n\n- [P3599 Koishi Loves Construction](https://www.luogu.com.cn/problem/P3599)\n- [P5441 【XR-2】伤痕](https://www.luogu.com.cn/problem/P5441)\n- [P5595 【XR-4】歌唱比赛](https://www.luogu.com.cn/problem/P5595)\n\n### Part 2.7 高精度\n\n> 在 C++ 中，long long 都无法表示我们需要的整数时怎么办？那就用高精度吧！\n\n- [P1601 A+B Problem（高精）](https://www.luogu.com.cn/problem/P1601)\n- [P2142 高精度减法](https://www.luogu.com.cn/problem/P2142)\n- [P1303 A\\*B Problem](https://www.luogu.com.cn/problem/P1303)\n- [P1480 A/B Problem](https://www.luogu.com.cn/problem/P1480)\n- [P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009)\n\n### Part 2.8 前缀和 & 差分\n\n> 前缀和是一种重要的预处理，能大大降低查询的时间复杂度，而差分则是一种和前缀和相对的策略。\n\n- [P3131 [USACO16JAN]Subsequences Summing to Sevens](https://www.luogu.com.cn/problem/P3131)\n- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)\n- [P3397 地毯](https://www.luogu.com.cn/problem/P3397)\n- [P2280 [HNOI2003]激光炸弹](https://www.luogu.com.cn/problem/P2280)\n- [P4552 [Poetize6] IncDec Sequence](https://www.luogu.com.cn/problem/P4552)\n\n\n## Part 3 搜索\n\n> 搜索其实就是高级的枚举，很多题目都可以用搜索完成。就算不能，搜索也是骗分神器。\n\n### Part 3.1 深度优先搜索\n\n> 深度优先搜索（DFS），即按照深度优先的顺序搜索的算法。\n>\n> 深度优先搜索一般使用栈来实现。\n\n- [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)\n- [P1019 单词接龙](https://www.luogu.com.cn/problem/P1019)\n- [P5194 [USACO05DEC]Scales](https://www.luogu.com.cn/problem/P5194)\n- [P5440 【XR-2】奇迹](https://www.luogu.com.cn/problem/P5440)\n- [P1378 油滴扩展](https://www.luogu.com.cn/problem/P1378)\n\n### Part 3.2 广度优先搜索\n\n> 广度优先搜索（BFS），即优先扩展浅层节点，逐渐深入的搜索算法。\n>\n> 广度优先搜索一般使用队列来实现。\n\n- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)\n- [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)\n- [P3956 棋盘](https://www.luogu.com.cn/problem/P3956)\n- [P1032 字串变换](https://www.luogu.com.cn/problem/P1032)\n- [P1126 机器人搬重物](https://www.luogu.com.cn/problem/P1126)\n\n### Part 3.3 记忆化搜索\n\n> 通过将已经遍历的状态记录下来，从而减少重复的搜索量，这就是记忆化搜索。\n>\n> 动态规划的时候，记忆化搜索也是一种高效简洁的实现方式。\n\n- [P1514 引水入城](https://www.luogu.com.cn/problem/P1514)\n- [P1535 游荡的奶牛](https://www.luogu.com.cn/problem/P1535)\n- [P1434 [SHOI2002]滑雪](https://www.luogu.com.cn/problem/P1434)\n- [P3953 逛公园](https://www.luogu.com.cn/problem/P3953)\n\n### Part 3.4 搜索的剪枝\n\n> 对于一些不必要搜索的部分，我们可以避免访问这些状态，从而提高搜索效率。\n\n- [P1120 小木棍 ［数据加强版］](https://www.luogu.com.cn/problem/P1120)\n- [P1312 Mayan游戏](https://www.luogu.com.cn/problem/P1312)\n- [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)\n\n### Part 3.5 双向搜索\n\n> 在搜索时，如果能从初态和终态出发，同时进行搜索，就可以减小搜索树的规模，提高时间效率。\n\n- [P3067 [USACO12OPEN]Balanced Cow Subsets](https://www.luogu.com.cn/problem/P3067)\n- [P4799 [CEOI2015 Day2]世界冰球锦标赛](https://www.luogu.com.cn/problem/P4799)\n- [P5195 [USACO05DEC]Knights of Ni](https://www.luogu.com.cn/problem/P5195)\n\n### Part 3.6 A\\*\n\n> 在 BFS 中，如果能设计一个合理的估价函数，就可以更快扩展到最优解。这就是 A\\*算法。\n\n- [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379)\n\n### Part 3.7 IDA\\*\n\n> 像 BFS 那样，每次只扩展一层节点，却采用 DFS 方式来遍历搜索树，这就是迭代加深搜索。\n>\n> 再加上一个估价函数来减小搜索量，就是 IDA\\*了。\n\n- [P2324 [SCOI2005]骑士精神](https://www.luogu.com.cn/problem/P2324)\n- [P2534 [AHOI2012]铁盘整理](https://www.luogu.com.cn/problem/P2534)\n\n### Part 3.8 DLX\n\n> 算法 X 是通过回溯法求解精确覆盖问题的算法，而删除列这一操作可以使用舞蹈链加速。\n\n- [P4929 【模板】舞蹈链（DLX）](https://www.luogu.com.cn/problem/P4929)\n- [P4205 [NOI2005]智慧珠游戏](https://www.luogu.com.cn/problem/P4205)\n\n## Part 4 动态规划\n\n> 动态规划是一种重要的思维方法，通过利用已有的子问题信息高效求出当前问题的最优解。\n\n### Part 4.1 线性动态规划\n\n> 线性动态规划，即具有线性阶段划分的动态规划。\n\n- [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)\n- [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)\n- [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)\n- [P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095)\n- [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)\n- [P1868 饥饿的奶牛](https://www.luogu.com.cn/problem/P1868)\n- [P2679 子串](https://www.luogu.com.cn/problem/P2679)\n- [P2501 [HAOI2006]数字序列](https://www.luogu.com.cn/problem/P2501)\n- [P3336 [ZJOI2013]话旧](https://www.luogu.com.cn/problem/P3336)\n- [P3558 [POI2013]BAJ-Bytecomputer](https://www.luogu.com.cn/problem/P3558)\n- [P4158 [SCOI2009]粉刷匠](https://www.luogu.com.cn/problem/P4158)\n- [P5301 [GXOI/GZOI2019]宝牌一大堆](https://www.luogu.com.cn/problem/P5301)\n\n### Part 4.2 背包动态规划\n\n> 背包动态规划是线性动态规划中特殊的一类，NOIP中考到的次数也不少。\n\n- [P1048 采药](https://www.luogu.com.cn/problem/P1048)\n- [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)\n- [P1855 榨取kkksc03](https://www.luogu.com.cn/problem/P1855)\n- [P5020 货币系统](https://www.luogu.com.cn/problem/P5020)\n- [P1757 通天之分组背包](https://www.luogu.com.cn/problem/P1757)\n- [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)\n- [P2946 [USACO09MAR]Cow Frisbee Team](https://www.luogu.com.cn/problem/P2946)\n- [P1156 垃圾陷阱](https://www.luogu.com.cn/problem/P1156)\n- [P5322 [BJOI2019]排兵布阵](https://www.luogu.com.cn/problem/P5322)\n- [P5289 [十二省联考2019]皮配](https://www.luogu.com.cn/problem/P5289)\n\n### Part 4.3 区间动态规划\n\n> 区间动态规划一般以区间作为动态规划的阶段。\n\n- [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)\n- [P3146 [USACO16OPEN]248](https://www.luogu.com.cn/problem/P3146)\n- [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)\n- [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)\n- [P4170 [CQOI2007]涂色](https://www.luogu.com.cn/problem/P4170)\n- [P4302 [SCOI2003]字符串折叠](https://www.luogu.com.cn/problem/P4302)\n- [P2466 [SDOI2008]Sue的小球](https://www.luogu.com.cn/problem/P2466)\n\n### Part 4.4 树形动态规划\n\n> 树形动态规划，即在树上进行的动态规划。\n>\n> 因为树的递归性质，树形动态规划一般都是递归求解的。\n\n- [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)\n- [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)\n- [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)\n- [P1122 最大子树和](https://www.luogu.com.cn/problem/P1122)\n- [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)\n- [P2014 选课](https://www.luogu.com.cn/problem/P2014)\n- [P2585 [ZJOI2006]三色二叉树](https://www.luogu.com.cn/problem/P2585)\n- [P3047 [USACO12FEB]Nearby Cows](https://www.luogu.com.cn/problem/P3047)\n- [P3698 [CQOI2017]小Q的棋盘](https://www.luogu.com.cn/problem/P3698)\n- [P5658 括号树](https://www.luogu.com.cn/problem/P5658)\n- [P2607 [ZJOI2008]骑士](https://www.luogu.com.cn/problem/P2607)\n- [P3177 [HAOI2015]树上染色](https://www.luogu.com.cn/problem/P3177)\n- [P4395 [BOI2003]Gem](https://www.luogu.com.cn/problem/P4395)\n- [P4516 [JSOI2018]潜入行动](https://www.luogu.com.cn/problem/P4516)\n\n### Part 4.5 状态压缩动态规划\n\n> 将一个状态压缩为一个整数（通常为二进制数），就可以在更为方便地进行状态转移的同时，达到节约空间的目的。\n\n- [P2704 [NOI2001]炮兵阵地](https://www.luogu.com.cn/problem/P2704)\n- [P1879 [USACO06NOV]Corn Fields](https://www.luogu.com.cn/problem/P1879)\n- [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)\n- [P3092 [USACO13NOV]No Change](https://www.luogu.com.cn/problem/P3092)\n- [P3694 邦邦的大合唱站队](https://www.luogu.com.cn/problem/P3694)\n- [P4925 [1007]Scarlet的字符串不可能这么可爱](https://www.luogu.com.cn/problem/P4925)\n- [P2157 [SDOI2009]学校食堂](https://www.luogu.com.cn/problem/P2157)\n- [P2167 [SDOI2009]Bill的挑战](https://www.luogu.com.cn/problem/P2167)\n- [P2396 yyy loves Maths VII](https://www.luogu.com.cn/problem/P2396)\n- [P4363 [九省联考2018]一双木棋](https://www.luogu.com.cn/problem/P4363)\n- [P5005 中国象棋 - 摆上马](https://www.luogu.com.cn/problem/P5005)\n- [P2150 [NOI2015]寿司晚宴](https://www.luogu.com.cn/problem/P2150)\n\n### Part 4.6 倍增优化动态规划\n\n> 利用倍增的方式，我们可以将状态转移的效率大大提高。\n\n- [P1613 跑路](https://www.luogu.com.cn/problem/P1613)\n- [P1081 开车旅行](https://www.luogu.com.cn/problem/P1081)\n- [P5024 保卫王国](https://www.luogu.com.cn/problem/P5024)\n\n### Part 4.7 数据结构优化动态规划\n\n> 利用数据结构来维护已有信息，也可以达到优化状态转移的目的。\n\n- [P4719 【模板】动态dp](https://www.luogu.com.cn/problem/P4719)\n- [P4751 动态dp【加强版】](https://www.luogu.com.cn/problem/P4751)\n- [P3287 [SCOI2014]方伯伯的玉米田](https://www.luogu.com.cn/problem/P3287)\n- [P2605 [ZJOI2010]基站选址](https://www.luogu.com.cn/problem/P2605)\n\n### Part 4.8 单调队列优化动态规划\n\n> 借助单调队列，排除不可能的决策，可以起到优化状态转移的效果。\n\n- [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)\n- [P3089 [USACO13NOV]Pogo-Cow](https://www.luogu.com.cn/problem/P3089)\n- [P3572 [POI2014]PTA-Little Bird](https://www.luogu.com.cn/problem/P3572)\n- [P3522 [POI2011]TEM-Temperature](https://www.luogu.com.cn/problem/P3522)\n- [P4544 [USACO10NOV]Buying Feed](https://www.luogu.com.cn/problem/P4544)\n- [P5665 划分](https://www.luogu.com.cn/problem/P5665)\n- [P1973 [NOI2011]Noi嘉年华](https://www.luogu.com.cn/problem/P1973)\n- [P2569 [SCOI2010]股票交易](https://www.luogu.com.cn/problem/P2569)\n- [P4852 yyf hates choukapai](https://www.luogu.com.cn/problem/P4852)\n\n### Part 4.9 斜率优化动态规划\n\n> 通过用单调队列维护一个凸壳，来达到优化转移的目的。\n\n- [P2900 [USACO08MAR]Land Acquisition](https://www.luogu.com.cn/problem/P2900)\n- [P3195 [HNOI2008]玩具装箱](https://www.luogu.com.cn/problem/P3195)\n- [P3628 [APIO2010]特别行动队](https://www.luogu.com.cn/problem/P3628)\n- [P3648 [APIO2014]序列分割](https://www.luogu.com.cn/problem/P3648)\n- [P4027 [NOI2007]货币兑换](https://www.luogu.com.cn/problem/P4027)\n- [P4360 [CEOI2004]锯木厂选址](https://www.luogu.com.cn/problem/P4360)\n- [P5468 [NOI2019]回家路线](https://www.luogu.com.cn/problem/P5468)\n- [P2305 [NOI2014]购票](https://www.luogu.com.cn/problem/P2305)\n\n### Part 4.10 决策单调性优化动态规划\n\n> 利用决策间的递变规律，也能实现优化状态转移的目的。\n\n- [P3515 [POI2011]Lightning Conductor](https://www.luogu.com.cn/problem/P3515)\n- [P4767 [IOI2000]邮局](https://www.luogu.com.cn/problem/P4767)\n- [P1912 [NOI2009]诗人小G](https://www.luogu.com.cn/problem/P1912)\n- [P1973 [NOI2011]Noi嘉年华](https://www.luogu.com.cn/problem/P1973)\n- [P3724 [AH2017/HNOI2017]大佬](https://www.luogu.com.cn/problem/P3724)\n- [P5574 [CmdOI2019]任务分配问题](https://www.luogu.com.cn/problem/P5574)\n\n### Part 4.11 数位统计类动态规划\n\n> 统计一个区间中满足条件的数有多少，就是数位统计类动态规划。\n\n- [P2602 [ZJOI2010]数字计数](https://www.luogu.com.cn/problem/P2602)\n- [P3281 [SCOI2013]数数](https://www.luogu.com.cn/problem/P3281)\n- [P2518 [HAOI2010]计数](https://www.luogu.com.cn/problem/P2518)\n- [P2657 [SCOI2009]windy数](https://www.luogu.com.cn/problem/P2657)\n- [P3286 [SCOI2014]方伯伯的商场之旅](https://www.luogu.com.cn/problem/P3286)\n- [P4124 [CQOI2016]手机号码](https://www.luogu.com.cn/problem/P4124)\n- [P4999 烦人的数学作业](https://www.luogu.com.cn/problem/P4999)\n- [P2606 [ZJOI2010]排列计数](https://www.luogu.com.cn/problem/P2606)\n- [P4798 [CEOI2015 Day1]卡尔文球锦标赛](https://www.luogu.com.cn/problem/P4798)\n\n### Part 4.12 轮廓线动态规划\n\n> 轮廓线动态规划（即常说的插头 DP）是一种特殊的状压动态规划，通过以轮廓线为状态来实现状态转移。\n\n- [P5056 【模板】插头dp](https://www.luogu.com.cn/problem/P5056)\n- [P2289 [HNOI2004]邮递员](https://www.luogu.com.cn/problem/P2289)\n- [P2337 [SCOI2012]喵星人的入侵](https://www.luogu.com.cn/problem/P2337)\n- [P5347 【XR-1】俄罗斯方块](https://www.luogu.com.cn/problem/P5347)\n\n## Part 5 字符串\n\n> 字符串问题有很多自己的特点。\n\n### Part 5.1 字符串哈希\n\n> 字符串哈希通过牺牲很小的准确率，达到快速进行字符串匹配的效果。\n\n- [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)\n- [P5270 无论怎样神树大人都会删库跑路](https://www.luogu.com.cn/problem/P5270)\n- [P5537 【XR-3】系统设计](https://www.luogu.com.cn/problem/P5537)\n\n### Part 5.2 KMP\n\n> KMP 算法可以用来解决模式串匹配问题。\n\n- [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)\n- [P4391 [BOI2009]Radio Transmission](https://www.luogu.com.cn/problem/P4391)\n- [P3435 [POI2006]OKR-Periods of Words](https://www.luogu.com.cn/problem/P3435)\n- [P4824 [USACO15FEB]Censoring (Silver)](https://www.luogu.com.cn/problem/P4824)\n- [P2375 [NOI2014]动物园](https://www.luogu.com.cn/problem/P2375)\n- [P3426 [POI2005]SZA-Template](https://www.luogu.com.cn/problem/P3426)\n- [P3193 [HNOI2008]GT考试](https://www.luogu.com.cn/problem/P3193)\n\n### Part 5.3 Manacher\n\n> Manacher 可以在线性时间内求出一个字符串的最长回文子串。\n\n- [P3805 【模板】manacher算法](https://www.luogu.com.cn/problem/P3805)\n- [P4555 [国家集训队]最长双回文串](https://www.luogu.com.cn/problem/P4555)\n- [P1659 [国家集训队]拉拉队排练](https://www.luogu.com.cn/problem/P1659)\n\n### Part 5.4 Trie树\n\n> Trie树可以像查字典一样把多个字符串组织到一棵树上。\n\n- [P3879 [TJOI2010]阅读理解](https://www.luogu.com.cn/problem/P3879)\n- [P2292 [HNOI2004]L语言](https://www.luogu.com.cn/problem/P2292)\n- [P2922 [USACO08DEC]Secret Message](https://www.luogu.com.cn/problem/P2922)\n- [P3065 [USACO12DEC]First!](https://www.luogu.com.cn/problem/P3065)\n- [P3294 [SCOI2016]背单词](https://www.luogu.com.cn/problem/P3294)\n- [P4407 [JSOI2009]电子字典](https://www.luogu.com.cn/problem/P4407)\n- [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)\n- [P4683 [IOI2008]Type Printer](https://www.luogu.com.cn/problem/P4683)\n- [P3783 [SDOI2017]天才黑客](https://www.luogu.com.cn/problem/P3783)\n\n### Part 5.5 AC自动机\n\n> AC自动机可以看成是 KMP 和 Trie 的结合体，用于解决多字符串匹配问题。\n\n- [P3808 【模板】AC自动机（简单版）](https://www.luogu.com.cn/problem/P3808)\n- [P3796 【模板】AC自动机（加强版）](https://www.luogu.com.cn/problem/P3796)\n- [P5357 【模板】AC自动机（二次加强版）](https://www.luogu.com.cn/problem/P5357)\n- [P3121 [USACO15FEB]Censoring (Gold)](https://www.luogu.com.cn/problem/P3121)\n- [P2414 [NOI2011]阿狸的打字机](https://www.luogu.com.cn/problem/P2414)\n- [P3966 [TJOI2013]单词](https://www.luogu.com.cn/problem/P3966)\n- [P2444 [POI2000]病毒](https://www.luogu.com.cn/problem/P2444)\n- [P3311 [SDOI2014]数数](https://www.luogu.com.cn/problem/P3311)\n- [P4052 [JSOI2007]文本生成器](https://www.luogu.com.cn/problem/P4052)\n- [P5599 【XR-4】文本编辑器](https://www.luogu.com.cn/problem/P5599)\n\n### Part 5.6 回文自动机\n\n> 回文自动机是解决回文串问题的有力工具。\n\n- [P5496 【模板】回文自动机（PAM）](https://www.luogu.com.cn/problem/P5496)\n- [P3649 [APIO2014]回文串](https://www.luogu.com.cn/problem/P3649)\n- [P4287 [SHOI2011]双倍回文](https://www.luogu.com.cn/problem/solution/P4287)\n- [P4762 [CERC2014]Virus synthesis](https://www.luogu.com.cn/problem/P4762)\n\n### Part 5.7 后缀数组\n\n> 后缀数组可以解决很多字符串匹配的问题。\n\n- [P3809 【模板】后缀排序](https://www.luogu.com.cn/problem/P3809)\n- [P5353 【模板】树上后缀排序](https://www.luogu.com.cn/problem/P5353)\n- [P2336 [SCOI2012]喵星球上的点名](https://www.luogu.com.cn/problem/P2336)\n- [P2463 [SDOI2008]Sandy的卡片](https://www.luogu.com.cn/problem/P2463)\n- [P2852 [USACO06DEC]Milk Patterns](https://www.luogu.com.cn/problem/P2852)\n- [P4051 [JSOI2007]字符加密](https://www.luogu.com.cn/problem/P4051)\n- [P1117 [NOI2016]优秀的拆分](https://www.luogu.com.cn/problem/P1117)\n- [P2178 [NOI2015]品酒大会](https://www.luogu.com.cn/problem/P2178)\n- [P5346 【XR-1】柯南家族](https://www.luogu.com.cn/problem/P5346)\n- [P5576 [CmdOI2019]口头禅](https://www.luogu.com.cn/problem/P5576)\n\n### Part 5.8 后缀自动机\n\n> 后缀自动机是一种处理字符串问题的强大工具。\n\n- [P3804 【模板】后缀自动机](https://www.luogu.com.cn/problem/P3804)\n- [P3649 [APIO2014]回文串](https://www.luogu.com.cn/problem/P3649)\n- [P3975 [TJOI2015]弦论](https://www.luogu.com.cn/problem/P3975)\n- [P4248 [AHOI2013]差异](https://www.luogu.com.cn/problem/P4248)\n- [P5341 [TJOI2019]甲苯先生和大中锋的字符串](https://www.luogu.com.cn/problem/P5341)\n- [P4770 [NOI2018]你的名字](https://www.luogu.com.cn/problem/P4770)\n- [P5284 [十二省联考2019]字符串问题](https://www.luogu.com.cn/problem/P5284)\n- [P5319 [BJOI2019]奥术神杖](https://www.luogu.com.cn/problem/P5319)\n\n## Part 6 数学\n\n> OI 中的数学知识很多，也有些杂乱。\n\n### Part 6.1 位运算\n\n> 将十进制整数转换为二进制后，有很多按位运算的运算符。\n> \n> 如果能善于利用位运算的一些性质，往往能达到事半功倍的效果。\n\n- [P5657 格雷码](https://www.luogu.com.cn/problem/P5657)\n- [P5514 [MtOI2019]永夜的报应](https://www.luogu.com.cn/problem/P5514)\n- [P5538 【XR-3】Namid[A]me](https://www.luogu.com.cn/problem/P5538)\n- [P5539 【XR-3】Unknown Mother-Goose](https://www.luogu.com.cn/problem/P5539)\n- [P5523 [yLOI2019]珍珠](https://www.luogu.com.cn/problem/P5523)\n\n### Part 6.2 整除相关\n\n> 与整除相关的概念有很多，比较常用的有素数，最大公约数和欧拉函数。\n\n#### Part 6.2.1 素数\n\n> 素数，指的是除 1 和它本身之外没有其他约数的数。\n\n- [P4718 【模板】Pollard-Rho算法](https://www.luogu.com.cn/problem/P4718)\n- [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)\n- [P2441 角色属性树](https://www.luogu.com.cn/problem/P2441)\n- [P5535 【XR-3】小道消息](https://www.luogu.com.cn/problem/P5535)\n\n#### Part 6.2.2 最大公约数\n\n> 如果两个数有一个共同的约数，那么这个约数就被称为公约数。最大公约数就是指这两个数的所有公约数中，最大的一个。\n>\n> 求解两个数的最大公约数，可以采用欧几里得算法解决。\n\n- [P5435 【模板】快速 GCD](https://www.luogu.com.cn/problem/P5435)\n- [P5436 【XR-2】缘分](https://www.luogu.com.cn/problem/P5436)\n- [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)\n- [P1414 又是毕业季II](https://www.luogu.com.cn/problem/P1414)\n- [P2152 [SDOI2009]SuperGCD](https://www.luogu.com.cn/problem/P2152)\n- [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)\n\n#### Part 6.2.3 欧拉函数\n\n> 欧拉函数 $ \\varphi (x) $ 表示了小于 $ x $ 的数字中，与 $ x $ 互质的数字个数。\n\n- [P2158 [SDOI2008]仪仗队](https://www.luogu.com.cn/problem/P2158)\n- [P2568 GCD](https://www.luogu.com.cn/problem/P2568)\n- [P2398 GCD SUM](https://www.luogu.com.cn/problem/P2398)\n- [P4139 上帝与集合的正确用法](https://www.luogu.com.cn/problem/P4139)\n\n### Part 6.3 同余方程\n\n> 求解同余方程往往可以引出不少话题。\n\n#### Part 6.3.1 线性同余方程&乘法逆元\n\n> 线性同余方程是同余方程中最基础的内容。\n\n- [P4549 【模板】裴蜀定理](https://www.luogu.com.cn/problem/P4549)\n- [P2613 【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)\n- [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)\n- [P5431 【模板】乘法逆元2](https://www.luogu.com.cn/problem/P5431)\n- [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)\n- [P3951 小凯的疑惑](https://www.luogu.com.cn/problem/P3951)\n- [P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)\n\n#### Part 6.3.2 中国剩余定理\n\n> 中国剩余定理可以快速解一元线性同余方程组。\n\n- [P4777 【模板】扩展中国剩余定理（EXCRT）](https://www.luogu.com.cn/problem/P4777)\n- [P3868 [TJOI2009]猜数字](https://www.luogu.com.cn/problem/P3868)\n- [P2480 [SDOI2010]古代猪文](https://www.luogu.com.cn/problem/P2480)\n- [P4774 [NOI2018]屠龙勇士](https://www.luogu.com.cn/problem/P4774)\n- [P5345 【XR-1】快乐肥宅](https://www.luogu.com.cn/problem/P5345)\n\n#### Part 6.3.3 高次同余方程\n\n> BSGS 算法可以高效计算离散对数。\n>\n> 而高次剩余的求解更加复杂，其中二次剩余作为高次剩余中比较特殊的情况，可以使用 Cipolla 法求解。\n\n- [P4195 【模板】exBSGS](https://www.luogu.com.cn/problem/P4195)\n- [P5491 【模板】二次剩余](https://www.luogu.com.cn/problem/P5491)\n- [P3306 [SDOI2013]随机数生成器](https://www.luogu.com.cn/problem/P3306)\n- [P2485 [SDOI2011]计算器](https://www.luogu.com.cn/problem/P2485)\n\n### Part 6.4 博弈论\n\n> 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。\n\n- [P2197 【模板】nim游戏](https://www.luogu.com.cn/problem/P2197)\n- [P1288 取数游戏II](https://www.luogu.com.cn/problem/P1288)\n- [P1290 欧几里德的游戏](https://www.luogu.com.cn/problem/P1290)\n- [P1247 取火柴游戏](https://www.luogu.com.cn/problem/P1247)\n- [P2252 取石子游戏](https://www.luogu.com.cn/problem/P2252)\n\n### Part 6.5 概率与期望\n\n> 概率和期望是紧密相连的，OI 中往往会出现和概率期望相关的动态规划问题。\n\n- [P5104 红包发红包](https://www.luogu.com.cn/problem/P5104)\n- [P1850 换教室](https://www.luogu.com.cn/problem/P1850)\n- [P3830 [SHOI2012]随机树](https://www.luogu.com.cn/problem/P3830)\n- [P4564 [CTSC2018]假面](https://www.luogu.com.cn/problem/P4564)\n- [P2473 [SCOI2008]奖励关](https://www.luogu.com.cn/problem/P2473)\n- [P2221 [HAOI2012]高速公路](https://www.luogu.com.cn/problem/P2221)\n- [P3239 [HNOI2015]亚瑟王](https://www.luogu.com.cn/problem/P3239)\n- [P3750 [六省联考2017]分手是祝愿](https://www.luogu.com.cn/problem/P3750)\n- [P4284 [SHOI2014]概率充电器](https://www.luogu.com.cn/problem/P4284)\n- [P5249 [LnOI2019]加特林轮盘赌](https://www.luogu.com.cn/problem/P5249)\n- [P2081 [NOI2012]迷失游乐园](https://www.luogu.com.cn/problem/P2081)\n- [P3343 [ZJOI2015]地震后的幻想乡](https://www.luogu.com.cn/problem/P3343)\n- [P3600 随机数生成器](https://www.luogu.com.cn/problem/P3600)\n- [P5326 [ZJOI2019]开关](https://www.luogu.com.cn/problem/P5326)\n\n### Part 6.6 组合数学\n\n> 组合数学常常与计数问题，概率期望紧密相连。\n\n#### Part 6.6.1 排列组合\n\n> 排列组合是组合数学的基础。\n\n- [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)\n- [P2822 组合数问题](https://www.luogu.com.cn/problem/P2822)\n- [P5520 [yLOI2019]青原樱](https://www.luogu.com.cn/problem/P5520)\n- [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)\n- [P2290 [HNOI2004]树的计数](https://www.luogu.com.cn/problem/P2290)\n- [P4981 父子](https://www.luogu.com.cn/problem/P4981)\n- [P4769 [NOI2018]冒泡排序](https://www.luogu.com.cn/problem/P4769)\n- [P4931 情侣？给我烧了！（加强版）](https://www.luogu.com.cn/problem/P4931)\n- [P5596 【XR-4】题](https://www.luogu.com.cn/problem/P5596)\n- [P5598 【XR-4】混乱度](https://www.luogu.com.cn/problem/P5598)\n\n#### Part 6.6.2 卡特兰数&斯特林数\n\n> 卡特兰数和斯特林数是两类常见的组合递推数列。\n\n- [P5395 第二类斯特林数·行](https://www.luogu.com.cn/problem/P5395)\n- [P5396 第二类斯特林数·列](https://www.luogu.com.cn/problem/P5396)\n- [P5408 第一类斯特林数·行](https://www.luogu.com.cn/problem/P5408)\n- [P5409 第一类斯特林数·列](https://www.luogu.com.cn/problem/P5409)\n- [P1655 小朋友的球](https://www.luogu.com.cn/problem/P1655)\n- [P2532 [AHOI2012]树屋阶梯](https://www.luogu.com.cn/problem/P2532)\n- [P3200 [HNOI2009]有趣的数列](https://www.luogu.com.cn/problem/P3200)\n- [P3978 [TJOI2015]概率论](https://www.luogu.com.cn/problem/P3978)\n- [P4091 [HEOI2016/TJOI2016]求和](https://www.luogu.com.cn/problem/P4091)\n- [P4827 [国家集训队]Crash 的文明世界](https://www.luogu.com.cn/problem/P4827)\n\n#### Part 6.6.3 容斥原理\n\n> 容斥原理常常用于解决集合的计数问题。\n\n- [P5664 Emiya 家今天的饭](https://www.luogu.com.cn/problem/P5664)\n- [P1450 [HAOI2008]硬币购物](https://www.luogu.com.cn/problem/P1450)\n- [P3214 [HNOI2011]卡农](https://www.luogu.com.cn/problem/P3214)\n- [P3270 [JLOI2016]成绩比较](https://www.luogu.com.cn/problem/P3270)\n- [P4336 [SHOI2016]黑暗前的幻想乡](https://www.luogu.com.cn/problem/P4336)\n- [P4448 [AHOI2018初中组]球球的排列](https://www.luogu.com.cn/problem/P4448)\n- [P4491 [HAOI2018]染色](https://www.luogu.com.cn/problem/P4491)\n- [P5339 [TJOI2019]唱、跳、rap和篮球](https://www.luogu.com.cn/problem/P5339)\n- [P5400 [CTS2019]随机立方体](https://www.luogu.com.cn/problem/P5400)\n\n### Part 6.7 线性代数\n\n> 线性代数主要用于解决线性关系问题。\n\n#### Part 6.7.1 矩阵\n\n> 利用矩阵优化数列递推，可以实现复杂度从线性到对数级的转变。\n\n- [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)\n- [P1939 【模板】矩阵加速（数列）](https://www.luogu.com.cn/problem/P1939)\n- [P4783 【模板】矩阵求逆](https://www.luogu.com.cn/problem/P4783)\n- [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)\n- [P1349 广义斐波那契数列](https://www.luogu.com.cn/problem/P1349)\n- [P4000 斐波那契数列](https://www.luogu.com.cn/problem/P4000)\n- [P3758 [TJOI2017]可乐](https://www.luogu.com.cn/problem/P3758)\n- [P4967 黑暗打击](https://www.luogu.com.cn/problem/P4967)\n- [P5343 【XR-1】分块](https://www.luogu.com.cn/problem/P5343)\n- [P5337 [TJOI2019]甲苯先生的字符串](https://www.luogu.com.cn/problem/P5337)\n- [P5303 [GXOI/GZOI2019]逼死强迫症](https://www.luogu.com.cn/problem/P5303)\n\n#### Part 6.7.2 高斯消元\n\n> 高斯消元可以用来求解方程组。\n\n- [P3389 【模板】高斯消元法](https://www.luogu.com.cn/problem/P3389)\n- [P2447 [SDOI2010]外星千足虫](https://www.luogu.com.cn/problem/P2447)\n- [P4035 [JSOI2008]球形空间产生器](https://www.luogu.com.cn/problem/P4035)\n- [P5516 [MtOI2019]小铃的烦恼](https://www.luogu.com.cn/problem/P5516)\n- [P4111 [HEOI2015]小Z的房间](https://www.luogu.com.cn/problem/P4111)\n- [P4457 [BJOI2018]治疗之雨](https://www.luogu.com.cn/problem/P4457)\n\n#### Part 6.7.3 线性基\n\n> 线性基可以求解最大异或和的一类问题。\n\n- [P3812 【模板】线性基](https://www.luogu.com.cn/problem/P3812)\n- [P3857 [TJOI2008]彩灯](https://www.luogu.com.cn/problem/P3857)\n- [P4570 [BJWC2011]元素](https://www.luogu.com.cn/problem/P4570)\n- [P4301 [CQOI2013]新Nim游戏](https://www.luogu.com.cn/problem/P4301)\n- [P3292 [SCOI2016]幸运数字](https://www.luogu.com.cn/problem/P3292)\n- [P4151 [WC2011]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)\n\n### Part 6.8 多项式\n\n> 对多项式的运算进行优化，从而能够解决规模更大的问题。\n\n- [P3803 【模板】多项式乘法（FFT）](https://www.luogu.com.cn/problem/P3803)\n- [P4238 【模板】多项式求逆](https://www.luogu.com.cn/problem/P4238)\n- [P4245 【模板】任意模数NTT](https://www.luogu.com.cn/problem/P4245)\n- [P4512 【模板】多项式除法](https://www.luogu.com.cn/problem/P4512)\n- [P4717 【模板】快速沃尔什变换](https://www.luogu.com.cn/problem/P4717)\n- [P4721 【模板】分治 FFT](https://www.luogu.com.cn/problem/P4721)\n- [P4725 【模板】多项式对数函数](https://www.luogu.com.cn/problem/P4725)\n- [P4726 【模板】多项式指数函数](https://www.luogu.com.cn/problem/P4726)\n- [P4781 【模板】拉格朗日插值](https://www.luogu.com.cn/problem/P4781)\n- [P5050 【模板】多项式多点求值](https://www.luogu.com.cn/problem/P5050)\n- [P5158 【模板】多项式快速插值](https://www.luogu.com.cn/problem/P5158)\n- [P5205 【模板】多项式开根](https://www.luogu.com.cn/problem/P5205)\n- [P5245 【模板】多项式快速幂](https://www.luogu.com.cn/problem/P5245)\n- [P5273 【模板】多项式幂函数 (加强版)](https://www.luogu.com.cn/problem/P5273)\n- [P5282 【模板】快速阶乘算法](https://www.luogu.com.cn/problem/P5282)\n- [P5373 【模板】多项式复合函数](https://www.luogu.com.cn/problem/P5373)\n- [P5394 【模板】下降幂多项式乘法](https://www.luogu.com.cn/problem/P5394)\n- [P3338 [ZJOI2014]力](https://www.luogu.com.cn/problem/P3338)\n- [P3723 [AH2017/HNOI2017]礼物](https://www.luogu.com.cn/problem/P3723)\n- [P5437 【XR-2】约定](https://www.luogu.com.cn/problem/P5437)\n- [P5293 [HNOI2019]白兔之舞](https://www.luogu.com.cn/problem/P5293)\n- [P5432 A/B Problem (加强版)](https://www.luogu.com.cn/problem/P5432)\n- [P5472 [NOI2019]斗主地](https://www.luogu.com.cn/problem/P5472)\n- [P5577 [CmdOI2019]算力训练](https://www.luogu.com.cn/problem/P5577)\n\n### Part 6.9 莫比乌斯反演\n\n> 运用莫比乌斯反演，我们可以将一些函数转化，从而降低计算难度。\n\n- [P3172 [CQOI2015]选数](https://www.luogu.com.cn/problem/P3172)\n- [P2522 [HAOI2011]Problem b](https://www.luogu.com.cn/problem/P2522)\n- [P3455 [POI2007]ZAP-Queries](https://www.luogu.com.cn/problem/P3455)\n- [P3327 [SDOI2015]约数个数和](https://www.luogu.com.cn/problem/P3327)\n- [P1829 [国家集训队]Crash的数字表格 / JZPTAB](https://www.luogu.com.cn/problem/P1829)\n- [P4619 [SDOI2018]旧试题](https://www.luogu.com.cn/problem/P4619)\n- [P3704 [SDOI2017]数字表格](https://www.luogu.com.cn/problem/P3704)\n- [P5518 [MtOI2019]幽灵乐团](https://www.luogu.com.cn/problem/P5518)\n\n### Part 6.10 筛法\n\n> 利用数列的性质，有多种筛法可以求出我们想要的信息。\n\n- [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)\n- [P4213 【模板】杜教筛（Sum）](https://www.luogu.com.cn/problem/P4213)\n- [P5325 【模板】Min_25筛](https://www.luogu.com.cn/problem/P5325)\n- [P1865 A % B Problem](https://www.luogu.com.cn/problem/P1865)\n- [P1621 集合](https://www.luogu.com.cn/problem/P1621)\n- [P3768 简单的数学题](https://www.luogu.com.cn/problem/P3768)\n- [P5438 【XR-2】记忆](https://www.luogu.com.cn/problem/P5438)\n\n### Part 6.11 线性规划\n\n> 线性规划是研究线性约束条件下线性目标函数极值问题的方法。\n\n- [P3980 [NOI2008]志愿者招募](https://www.luogu.com.cn/problem/P3980)\n- [P4232 无意识之外的捉迷藏](https://www.luogu.com.cn/problem/P4232)\n\n### Part 6.12 数值方法\n\n> 在算法领域，有很多求近似值的数值方法。\n\n#### Part 6.12.1 三分法\n\n> 三分法可以求出一个单峰 / 单谷函数的极值。\n\n- [P3382 【模板】三分法](https://www.luogu.com.cn/problem/P3382)\n- [P1883 函数](https://www.luogu.com.cn/problem/P1883)\n\n#### Part 6.12.2 自适应辛普森法\n\n> 自适应辛普森法可以高效求出给定函数的数值积分。\n\n- [P4525 【模板】自适应辛普森法1](https://www.luogu.com.cn/problem/P4525)\n- [P4526 【模板】自适应辛普森法2](https://www.luogu.com.cn/problem/P4526)\n- [P3779 [SDOI2017]龙与地下城](https://www.luogu.com.cn/problem/P3779)\n\n### Part 6.13 置换群\n\n> 置换群通常用来解决一些涉及“本质不同”的计数问题。\n\n- [P4980 【模板】Polya定理](https://www.luogu.com.cn/problem/P4980)\n- [P1446 [HNOI2008]Cards](https://www.luogu.com.cn/problem/P1446)\n- [P2561 [AHOI2002]黑白瓷砖](https://www.luogu.com.cn/problem/P2561)\n- [P4128 [SHOI2006]有色图](https://www.luogu.com.cn/problem/P4128)\n- [P4727 [HNOI2009]图的同构记数](https://www.luogu.com.cn/problem/P4727)\n\n## Part 7 数据结构\n\n> 灵活地运用数据结构可以高效地查询并处理需要的信息。\n\n### Part 7.1 链表\n\n> 在一个数列中高效插入一个元素，链表毫无疑问是最好的选择。\n\n- [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)\n- [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)\n\n### Part 7.2 栈\n\n> 栈，是一种后进先出（FILO）的数据结构。\n\n- [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)\n- [P1739 表达式括号匹配](https://www.luogu.com.cn/problem/P1739)\n- [P1981 表达式求值](https://www.luogu.com.cn/problem/P1981)\n- [P1175 表达式的转换](https://www.luogu.com.cn/problem/P1175)\n\n### Part 7.3 队列\n\n> 队列，是一种先进先出（FIFO）的数据结构。\n\n- [P1540 机器翻译](https://www.luogu.com.cn/problem/P1540)\n\n### Part 7.4 并查集\n\n> 并查集常用于处理一些不相交集合的合并和查询问题。\n\n- [P1111 修复公路](https://www.luogu.com.cn/problem/P1111)\n- [P3958 奶酪](https://www.luogu.com.cn/problem/P3958)\n- [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)\n- [P4185 [USACO18JAN]MooTube G](https://www.luogu.com.cn/problem/P4185)\n- [P2024 [NOI2001]食物链](https://www.luogu.com.cn/problem/P2024)\n- [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)\n- [P1196 [NOI2002]银河英雄传说](https://www.luogu.com.cn/problem/P1196)\n- [P1955 [NOI2015]程序自动分析](https://www.luogu.com.cn/problem/P1955)\n\n### Part 7.5 二叉堆\n\n> 二叉堆是一棵完全二叉树，堆中某个节点的值总是不大于或不小于其父节点的值。\n\n- [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)\n- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)\n- [P1168 中位数](https://www.luogu.com.cn/problem/P1168)\n- [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085)\n- [P2827 蚯蚓](https://www.luogu.com.cn/problem/P2827)\n- [P3045 [USACO12FEB]Cow Coupons](https://www.luogu.com.cn/problem/P3045)\n\n### Part 7.6 ST表\n\n> ST表可以离线查询区间最值。\n\n- [P3865 【模板】ST表](https://www.luogu.com.cn/problem/P3865)\n- [P2251 质量检测](https://www.luogu.com.cn/problem/P2251)\n- [P1816 忠诚](https://www.luogu.com.cn/problem/P1816)\n- [P1198 [JSOI2008]最大数](https://www.luogu.com.cn/problem/P1198)\n- [P2880 [USACO07JAN]Balanced Lineup](https://www.luogu.com.cn/problem/P2880)\n- [P5012 水の数列](https://www.luogu.com.cn/problem/P5012)\n- [P5344 【XR-1】逛森林](https://www.luogu.com.cn/problem/P5344)\n- [P2048 [NOI2010]超级钢琴](https://www.luogu.com.cn/problem/P2048)\n\n### Part 7.7 树状数组\n\n> 树状数组是一种简洁高效的树形数据结构。\n\n- [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)\n- [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)\n- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)\n- [P1966 火柴排队](https://www.luogu.com.cn/problem/P1966)\n- [P3605 [USACO17JAN]Promotion Counting](https://www.luogu.com.cn/problem/P3605)\n- [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)\n- [P3586 [POI2015]LOG](https://www.luogu.com.cn/problem/P3586)\n- [P4054 [JSOI2009]计数问题](https://www.luogu.com.cn/problem/P4054)\n- [P4113 [HEOI2012]采花](https://www.luogu.com.cn/problem/P4113)\n- [P3960 列队](https://www.luogu.com.cn/problem/P3960)\n\n### Part 7.8 线段树\n\n> 线段树的通用性比树状数组更强，可以处理更多涉及区间操作的题目。\n\n- [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)\n- [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)\n- [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)\n- [P4588 [TJOI2018]数学计算](https://www.luogu.com.cn/problem/P4588)\n- [P1502 窗口的星星](https://www.luogu.com.cn/problem/P1502)\n- [P2471 [SCOI2007]降雨量](https://www.luogu.com.cn/problem/P2471)\n- [P2824 [HEOI2016/TJOI2016]排序](https://www.luogu.com.cn/problem/P2824)\n- [P3722 [AH2017/HNOI2017]影魔](https://www.luogu.com.cn/problem/P3722)\n- [P4097 [HEOI2013]Segment](https://www.luogu.com.cn/problem/P4097)\n- [P4198 楼房重建](https://www.luogu.com.cn/problem/P4198)\n- [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)\n- [P4556 [Vani有约会]雨天的尾巴](https://www.luogu.com.cn/problem/P4556)\n- [P5324 [BJOI2019]删数](https://www.luogu.com.cn/problem/P5324)\n- [P5327 [ZJOI2019]语言](https://www.luogu.com.cn/problem/P5327)\n\n### Part 7.9 分块\n\n> 分块是一种非常通用的暴力方法，虽然效率不如线段树和树状数组，但可以解决很多线段树和树状数组处理不了的问题。\n\n- [P3870 [TJOI2009]开关](https://www.luogu.com.cn/problem/P3870)\n- [P3396 哈希冲突](https://www.luogu.com.cn/problem/P3396)\n- [P3863 序列](https://www.luogu.com.cn/problem/P3863)\n- [P1975 [国家集训队]排队](https://www.luogu.com.cn/problem/P1975)\n- [P3710 方方方的数据结构](https://www.luogu.com.cn/problem/P3710)\n- [P3992 [BJOI2017]开车](https://www.luogu.com.cn/problem/P3992)\n- [P4168 [Violet]蒲公英](https://www.luogu.com.cn/problem/P4168)\n- [P4119 [Ynoi2018]未来日记](https://www.luogu.com.cn/problem/P4119)\n\n### Part 7.10 可并堆\n\n> 可并堆分为左偏树和配对堆两种，它们都具有堆的性质，且可以高效合并。\n\n- [P3377 【模板】左偏树（可并堆）](https://www.luogu.com.cn/problem/P3377)\n- [P2713 罗马游戏](https://www.luogu.com.cn/problem/P2713)\n- [P1456 Monkey King](https://www.luogu.com.cn/problem/P1456)\n- [P1552 [APIO2012]派遣](https://www.luogu.com.cn/problem/P1552)\n- [P3261 [JLOI2015]城池攻占](https://www.luogu.com.cn/problem/P3261)\n- [P3273 [SCOI2011]棘手的操作](https://www.luogu.com.cn/problem/P3273)\n- [P4331 [BOI2004]Sequence](https://www.luogu.com.cn/problem/P4331)\n\n### Part 7.11 主席树\n\n> 主席树，即可持久化权值线段树。\n\n- [P2468 [SDOI2010]粟粟的书架](https://www.luogu.com.cn/problem/P2468)\n- [P3302 [SDOI2013]森林](https://www.luogu.com.cn/problem/P3302)\n- [P3168 [CQOI2015]任务查询系统](https://www.luogu.com.cn/problem/P3168)\n- [P4559 [JSOI2018]列队](https://www.luogu.com.cn/problem/P4559)\n- [P2633 Count on a tree](https://www.luogu.com.cn/problem/P2633)\n- [P3293 [SCOI2016]美味](https://www.luogu.com.cn/problem/P3293)\n- [P4618 [SDOI2018]原题识别](https://www.luogu.com.cn/problem/P4618)\n\n### Part 7.12 平衡树\n\n> 二叉搜索树可以用来维护有序序列。\n>\n> 为了保证查询效率，有多种使二叉搜索树保持平衡的实现方法。\n\n- [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)\n- [P3391 【模板】文艺平衡树（Splay）](https://www.luogu.com.cn/problem/P3391)\n- [P3850 [TJOI2007]书架](https://www.luogu.com.cn/problem/P3850)\n- [P4008 [NOI2003]文本编辑器](https://www.luogu.com.cn/problem/P4008)\n- [P5338 [TJOI2019]甲苯先生的滚榜](https://www.luogu.com.cn/problem/P5338)\n- [P2042 [NOI2005]维护数列](https://www.luogu.com.cn/problem/P2042)\n- [P1110 [ZJOI2007]报表统计](https://www.luogu.com.cn/problem/P1110)\n- [P3644 [APIO2015]八邻旁之桥](https://www.luogu.com.cn/problem/P3644)\n- [P1486 [NOI2004]郁闷的出纳员](https://www.luogu.com.cn/problem/P1486)\n- [P2710 数列](https://www.luogu.com.cn/problem/P2710)\n- [P3224 [HNOI2012]永无乡](https://www.luogu.com.cn/problem/P3224)\n- [P3285 [SCOI2014]方伯伯的OJ](https://www.luogu.com.cn/problem/P3285)\n- [P5321 [BJOI2019]送别](https://www.luogu.com.cn/problem/P5321)\n\n### Part 7.13 树链剖分\n\n> 树链剖分可以将任意一条树上路径划分成若干条连续的链，并用线段树等数据结构高效维护链上信息。\n\n- [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)\n- [P3313 [SDOI2014]旅行](https://www.luogu.com.cn/problem/P3313)\n- [P2590 [ZJOI2008]树的统计](https://www.luogu.com.cn/problem/P2590)\n- [P1505 [国家集训队]旅游](https://www.luogu.com.cn/problem/P1505)\n- [P2486 [SDOI2011]染色](https://www.luogu.com.cn/problem/P2486)\n- [P3258 [JLOI2014]松鼠的新家](https://www.luogu.com.cn/problem/P3258)\n- [P4069 [SDOI2016]游戏](https://www.luogu.com.cn/problem/P4069)\n- [P4211 [LNOI2014]LCA](https://www.luogu.com.cn/problem/P4211)\n- [P4592 [TJOI2018]异或](https://www.luogu.com.cn/problem/P4592)\n- [P5305 [GXOI/GZOI2019]旧词](https://www.luogu.com.cn/problem/P5305)\n- [P5354 [Ynoi2017]由乃的OJ](https://www.luogu.com.cn/problem/P5354)\n- [P5499 [LnOI2019]Abbi并不想研学](https://www.luogu.com.cn/problem/P5499)\n\n### Part 7.14 树套树\n\n> 树套树可以用来维护多维度信息。\n\n- [P3380 【模板】二逼平衡树（树套树）](https://www.luogu.com.cn/problem/P3380)\n- [P1975 [国家集训队]排队](https://www.luogu.com.cn/problem/P1975)\n- [P3332 [ZJOI2013]K大数查询](https://www.luogu.com.cn/problem/P3332)\n- [P4278 带插入区间K小值](https://www.luogu.com.cn/problem/P4278)\n- [P1903 [国家集训队]数颜色 / 维护队列](https://www.luogu.com.cn/problem/P1903)\n- [P3759 [TJOI2017]不勤劳的图书管理员](https://www.luogu.com.cn/problem/P3759)\n- [P3242 [HNOI2015]接水果](https://www.luogu.com.cn/problem/P3242)\n- [P3248 [HNOI2016]树](https://www.luogu.com.cn/problem/P3248)\n- [P5445 [APIO2019]路灯](https://www.luogu.com.cn/problem/P5445)\n\n### Part 7.15 动态树\n\n> Link-Cut Tree 可以用来解决动态树一类问题。\n\n- [P3690 【模板】Link Cut Tree （动态树）](https://www.luogu.com.cn/problem/P3690)\n- [P3203 [HNOI2010]弹飞绵羊](https://www.luogu.com.cn/problem/P3203)\n- [P4338 [ZJOI2018]历史](https://www.luogu.com.cn/problem/P4338)\n- [P4312 [COCI2009]OTOCI](https://www.luogu.com.cn/problem/P4312)\n- [P1501 [国家集训队]Tree II](https://www.luogu.com.cn/problem/P1501)\n- [P2387 [NOI2014]魔法森林](https://www.luogu.com.cn/problem/P2387)\n- [P3348 [ZJOI2016]大森林](https://www.luogu.com.cn/problem/P3348)\n- [P3703 [SDOI2017]树点涂色](https://www.luogu.com.cn/problem/P3703)\n- [P4172 [WC2006]水管局长](https://www.luogu.com.cn/problem/P4172)\n- [P4219 [BJOI2014]大融合](https://www.luogu.com.cn/problem/P4219)\n- [P5489 EntropyIncreaser 与 动态图](https://www.luogu.com.cn/problemnew/solution/P5489)\n\n### Part 7.16 可持久化数据结构\n\n> 可持久化数据结构实现了在更新信息的时候保留历史版本。\n\n- [P3919 【模板】可持久化数组（可持久化线段树/平衡树）](https://www.luogu.com.cn/problem/P3919)\n- [P3834 【模板】可持久化线段树 1（主席树）](https://www.luogu.com.cn/problem/P3834)\n- [P3402 【模板】可持久化并查集](https://www.luogu.com.cn/problem/P3402)\n- [P3835 【模板】可持久化平衡树](https://www.luogu.com.cn/problem/P3835)\n- [P5055 【模板】可持久化文艺平衡树](https://www.luogu.com.cn/problem/P5055)\n- [P5283 [十二省联考2019]异或粽子](https://www.luogu.com.cn/problem/P5283)\n\n### Part 7.17 K-D Tree\n\n> K-D Tree 是一种高效处理 $ k $ 维信息的数据结构。\n\n- [P4357 [CQOI2016]K远点对](https://www.luogu.com.cn/problem/P4357)\n- [P4148 简单题](https://www.luogu.com.cn/problem/P4148)\n- [P2479 [SDOI2010]捉迷藏](https://www.luogu.com.cn/problem/P2479)\n- [P3769 [CH弱省胡策R2]TATT](https://www.luogu.com.cn/problem/P3769)\n- [P4169 [Violet]天使玩偶/SJY摆棋子](https://www.luogu.com.cn/problem/P4169)\n- [P4390 [BOI2007]Mokia](https://www.luogu.com.cn/problem/P4390)\n- [P4475 巧克力王国](https://www.luogu.com.cn/problem/P4475)\n- [P2093 [国家集训队]JZPFAR](https://www.luogu.com.cn/problem/P2093)\n- [P5471 [NOI2019]弹跳](https://www.luogu.com.cn/problem/P5471)\n\n### Part 7.18 珂朵莉树\n\n> 珂朵莉树，是一种基于 `std::set` 的暴力数据结构，在数据随机的情况下表现优秀。\n\n- [P5251 [LnOI2019]第二代图灵机](https://www.luogu.com.cn/problem/P5251)\n- [P5350 序列](https://www.luogu.com.cn/problem/P5350)\n\n## Part 8 图论\n\n> 图论是数学的一个分支，它以图为研究的对象。\n\n### Part 8.1 图的存储与遍历\n\n> 这里的图论内容都比较简单，涉及图的存储以及遍历图的方式。\n\n- [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)\n- [P2921 [USACO08DEC]Trick or Treat on the Farm](https://www.luogu.com.cn/problem/P2921)\n\n### Part 8.2 最短路问题\n\n> 很多题目都可以转化为最短路的模型。因此，掌握最短路算法非常重要。\n\n- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)\n- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)\n- [P5905 【模板】Johnson 全源最短路](https://www.luogu.com.cn/problem/P5905)\n- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)\n- [P1462 通往奥格瑞玛的道路](https://www.luogu.com.cn/problem/P1462)\n- [P1522 Cow Tours](https://www.luogu.com.cn/problem/P1522)\n- [P1266 速度限制](https://www.luogu.com.cn/problem/P1266)\n- [P4001 [ICPC-Beijing 2006]狼抓兔子](https://www.luogu.com.cn/problem/P4001)\n- [P4568 [JLOI2011]飞行路线](https://www.luogu.com.cn/problem/P4568)\n- [P3238 [HNOI2014]道路堵塞](https://www.luogu.com.cn/problem/P3238)\n- [P5304 [GXOI/GZOI2019]旅行者](https://www.luogu.com.cn/problem/P5304)\n\n### Part 8.3 树上问题\n\n> 作为一种特殊的图，树上的问题具有很多鲜明的特点。\n\n#### Part 8.3.1 二叉树\n\n> 二叉树是一种特殊的树，它有很多特殊的性质。\n>\n\n- [P1087 FBI树](https://www.luogu.com.cn/problem/P1087)\n- [P1030 求先序排列](https://www.luogu.com.cn/problem/P1030)\n- [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)\n- [P1229 遍历问题](https://www.luogu.com.cn/problem/P1229)\n- [P5018 对称二叉树](https://www.luogu.com.cn/problem/P5018)\n- [P5597 【XR-4】复读](https://www.luogu.com.cn/problem/P5597)\n\n#### Part 8.3.2 树的直径\n\n> 树的直径被定义为树上最远的两点间的距离。\n>\n> 计算树的直径，可以通过两遍 DFS 解决。\n\n- [P2195 HXY造公园](https://www.luogu.com.cn/problem/P2195)\n- [P3629 [APIO2010]巡逻](https://www.luogu.com.cn/problem/P3629)\n- [P5536 【XR-3】核心城市](https://www.luogu.com.cn/problem/P5536)\n- [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)\n- [P4408 [NOI2003]逃学的小孩](https://www.luogu.com.cn/problem/P4408)\n\n#### Part 8.3.3 最近公共祖先\n\n> 两个点的最近公共祖先，即两个点的所有公共祖先中，离根节点最远的一个节点。\n>\n> 求解最近公共祖先，常用的方法是树上倍增或者树链剖分。\n\n- [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)\n- [P3938 斐波那契](https://www.luogu.com.cn/problem/P3938)\n- [P4281 [AHOI2008]紧急集合 / 聚会](https://www.luogu.com.cn/problem/P4281)\n\n### Part 8.4 生成树\n\n> 用 $ n-1 $ 条边将图上的 $ n $ 个点连接起来，形成的树就被称为生成树。\n\n- [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)\n- [P4180 【模板】严格次小生成树[BJWC2010]](https://www.luogu.com.cn/problem/P4180)\n- [P2872 [USACO07DEC]Building Roads](https://www.luogu.com.cn/problem/P2872)\n- [P1991 无线通讯网](https://www.luogu.com.cn/problem/P1991)\n- [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)\n- [P4047 [JSOI2010]部落划分](https://www.luogu.com.cn/problem/P4047)\n\n### Part 8.5 拓扑排序\n\n> 将一个有向无环图排序，使得所有排在前面的节点不能依赖于排在后面的节点，这就是拓扑排序。\n\n- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)\n- [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)\n- [P1038 神经网络](https://www.luogu.com.cn/problem/P1038)\n\n### Part 8.6 差分约束\n\n> 差分约束要解决的问题是：求出一组 $ n $ 元不等式的一组解，使得所有约束关系都能得到满足。 \n\n- [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)\n- [P3275 [SCOI2011]糖果](https://www.luogu.com.cn/problem/P3275)\n- [P2294 [HNOI2005]狡猾的商人](https://www.luogu.com.cn/problem/P2294)\n- [P4926 [1007]倍杀测量者](https://www.luogu.com.cn/problem/P4926)\n- [P5590 赛车游戏](https://www.luogu.com.cn/problem/P5590)\n\n### Part 8.7 图的连通性相关\n\n> 利用 Tarjan 算法，我们可以解决很多与图的连通性相关的问题。\n\n- [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)\n- [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)\n- [P2341 [HAOI2006]受欢迎的牛](https://www.luogu.com.cn/problem/P2341)\n- [P2863 [USACO06JAN]The Cow Prom](https://www.luogu.com.cn/problem/P2863)\n- [P2746 [USACO5.3]Network of Schools](https://www.luogu.com.cn/problem/P2746)\n- [P1407 [国家集训队]稳定婚姻](https://www.luogu.com.cn/problem/P1407)\n- [P2272 [ZJOI2007]最大半连通子图](https://www.luogu.com.cn/problem/P2272)\n- [P3225 [HNOI2012]矿场搭建](https://www.luogu.com.cn/problem/P3225)\n- [P5058 [ZJOI2004]嗅探器](https://www.luogu.com.cn/problem/P5058)\n- [P2515 [HAOI2010]软件安装](https://www.luogu.com.cn/problem/P2515)\n\n### Part 8.8 二分图\n\n> 二分图上的不少问题都可以转化成网络流解决，当然也有独特的其他方法。\n\n- [P3386 【模板】二分图匹配](https://www.luogu.com.cn/problem/P3386)\n- [P2756 飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)\n- [P1129 [ZJOI2007]矩阵游戏](https://www.luogu.com.cn/problem/P1129)\n- [P1559 运动员最佳匹配问题](https://www.luogu.com.cn/problem/P1559)\n- [P2423 [HEOI2012]朋友圈](https://www.luogu.com.cn/problem/P2423)\n- [P2764 最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)\n- [P2825 [HEOI2016/TJOI2016]游戏](https://www.luogu.com.cn/problem/P2825)\n- [P3033 [USACO11NOV]Cow Steeplechase](https://www.luogu.com.cn/problem/P3033)\n- [P3731 [HAOI2017]新型城市化](https://www.luogu.com.cn/problem/P3731)\n- [P4014 分配问题](https://www.luogu.com.cn/problem/P4014)\n- [P4617 [COCI2017-2018#5] Planinarenje](https://www.luogu.com.cn/problem/P4617)\n\n### Part 8.9 网络流\n\n> 网络流是图论中一个重要的分支，很多题目都可以通过建立网络流的模型来解决。\n\n#### Part 8.9.1 最大流\n\n> 最大流，即求网络中最大的流量。\n\n- [P3376 【模板】网络最大流](https://www.luogu.com.cn/problem/P3376)\n- [P4722 【模板】最大流 加强版 / 预流推进](https://www.luogu.com.cn/problem/P4722)\n- [P2065 [TJOI2011]卡片](https://www.luogu.com.cn/problem/P2065)\n- [P2763 试题库问题](https://www.luogu.com.cn/problem/P2763)\n- [P2472 [SCOI2007]蜥蜴](https://www.luogu.com.cn/problem/P2472)\n- [P2754 [CTSC1999]家园](https://www.luogu.com.cn/problem/P2754)\n- [P2765 魔术球问题](https://www.luogu.com.cn/problem/P2765)\n- [P2766 最长不下降子序列问题](https://www.luogu.com.cn/problem/P2766)\n- [P2805 [NOI2009]植物大战僵尸](https://www.luogu.com.cn/problem/P2805)\n- [P3749 [六省联考2017]寿司餐厅](https://www.luogu.com.cn/problem/P3749)\n\n#### Part 8.9.2 最小割\n\n> 最小割，即求一个边权最小的边集，使得源点和汇点不再连通。\n>\n> 可以证明，**最大流=最小割**。\n\n- [P1344 [USACO4.4]Pollutant Control](https://www.luogu.com.cn/problem/P1344)\n- [P1345 [USACO5.4]Telecowmunication](https://www.luogu.com.cn/problem/P1345)\n- [P2057 [SHOI2007]善意的投票](https://www.luogu.com.cn/problem/P2057)\n- [P2598 [ZJOI2009]狼和羊的故事](https://www.luogu.com.cn/problem/P2598)\n- [P2774 方格取数问题](https://www.luogu.com.cn/problem/P2774)\n- [P4126 [AHOI2009]最小割](https://www.luogu.com.cn/problem/P4126)\n- [P5039 [SHOI2010]最小生成树](https://www.luogu.com.cn/problem/P5039)\n\n#### Part 8.9.3 费用流\n\n> 在网络流中给边加上一个参数——费用，就出现了费用流。\n\n- [P3381 【模板】最小费用最大流](https://www.luogu.com.cn/problem/P3381)\n- [P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016)\n- [P4452 [国家集训队]航班安排](https://www.luogu.com.cn/problem/P4452)\n- [P2045 方格取数加强版](https://www.luogu.com.cn/problem/P2045)\n- [P2050 [NOI2012]美食节](https://www.luogu.com.cn/problem/P2050)\n- [P2053 [SCOI2007]修车](https://www.luogu.com.cn/problem/P2053)\n- [P2604 [ZJOI2010]网络扩容](https://www.luogu.com.cn/problem/P2604)\n- [P2770 航空路线问题](https://www.luogu.com.cn/problem/P2770)\n- [P3159 [CQOI2012]交换棋子](https://www.luogu.com.cn/problem/P3159)\n- [P3356 火星探险问题](https://www.luogu.com.cn/problem/P3356)\n- [P3358 最长k可重区间集问题](https://www.luogu.com.cn/problem/P3358)\n- [P4013 数字梯形问题](https://www.luogu.com.cn/problem/P4013)\n- [P4015 运输问题](https://www.luogu.com.cn/problem/P4015)\n- [P5331 [SNOI2019]通信](https://www.luogu.com.cn/problem/P5331)\n\n#### Part 8.9.4 上下界网络流\n\n> 在网络流问题中给每条边的流量增加一个下界，就有了上下界网络流。\n\n- [P3980 [NOI2008]志愿者招募](https://www.luogu.com.cn/problem/P3980)\n- [P4043 [AHOI2014/JSOI2014]支线剧情](https://www.luogu.com.cn/problem/P4043)\n- [P4553 80人环游世界](https://www.luogu.com.cn/problem/P4553)\n- [P4843 清理雪道](https://www.luogu.com.cn/problem/P4843)\n\n### Part 8.10 2-SAT\n\n> k-SAT 问题的目标是对一些布尔变量赋值，满足限定的条件。\n>\n> 在 k-SAT 问题中，2-SAT 问题属于较为容易解决的一类。\n\n- [P4782 【模板】2-SAT 问题](https://www.luogu.com.cn/problem/P4782)\n- [P4171 [JSOI2010]满汉全席](https://www.luogu.com.cn/problem/P4171)\n- [P3825 [NOI2017]游戏](https://www.luogu.com.cn/problem/P3825)\n- [P5332 [JSOI2019]精准预测](https://www.luogu.com.cn/problem/P5332)\n\n### Part 8.11 点分治\n\n> 点分治是一种可以高效统计树上路径信息的算法。\n\n- [P3806 【模板】点分治1](https://www.luogu.com.cn/problem/P3806)\n- [P2634 [国家集训队]聪聪可可](https://www.luogu.com.cn/problem/P2634)\n- [P2664 树上游戏](https://www.luogu.com.cn/problem/P2664)\n- [P3714 [BJOI2017]树的难题](https://www.luogu.com.cn/problem/P3714)\n- [P4149 [IOI2011]Race](https://www.luogu.com.cn/problem/P4149)\n- [P3241 [HNOI2015]开店](https://www.luogu.com.cn/problem/P3241)\n- [P4075 [SDOI2016]模式字符串](https://www.luogu.com.cn/problem/P4075)\n- [P4183 [USACO18JAN]Cow at Large P](https://www.luogu.com.cn/problem/P4183)\n- [P4292 [WC2010]重建计划](https://www.luogu.com.cn/problem/P4292)\n- [P5306 [COCI2019]Transport](https://www.luogu.com.cn/problem/P5306)\n\n### Part 8.12 虚树\n\n> 将一些无用的点从树上删去，从而达到降低树的规模的效果。\n\n- [P2495 [SDOI2011]消耗战](https://www.luogu.com.cn/problem/P2495)\n- [P3233 [HNOI2014]世界树](https://www.luogu.com.cn/problem/P3233)\n- [P5360 [SDOI2019]世界地图](https://www.luogu.com.cn/problem/P5360)\n- [P5439 【XR-2】永恒](https://www.luogu.com.cn/problem/P5439)\n\n### Part 8.13 矩阵树定理\n\n> 矩阵树定理可以解决图的生成树计数问题。\n\n- [P4111 [HEOI2015]小Z的房间](https://www.luogu.com.cn/problem/P4111)\n- [P2144 [FJOI2007]轮状病毒](https://www.luogu.com.cn/problem/P2144)\n- [P3317 [SDOI2014]重建](https://www.luogu.com.cn/problem/P3317)\n- [P4208 [JSOI2008]最小生成树计数](https://www.luogu.com.cn/problem/P4208)\n\n## Part 9 计算几何\n\n> 试着用计算机来解决几何问题吧！\n\n### Part 9.1 凸包\n\n> 凸包指在平面上能包含所有给定点的最小凸多边形。\n\n- [P2742 【模板】二维凸包](https://www.luogu.com.cn/problem/P2742)\n- [P2287 [HNOI2004]最佳包裹](https://www.luogu.com.cn/problem/P2287)\n- [P3829 [SHOI2012]信用卡凸包](https://www.luogu.com.cn/problem/P3829)\n- [P4680 [Ynoi2018]末日时在做什么?有没有空?可以来拯救吗?](https://www.luogu.com.cn/problem/P4680)\n- [P4557 [JSOI2018]战争](https://www.luogu.com.cn/problem/P4557)\n- [P5403 [CTS2019]田野](https://www.luogu.com.cn/problem/P5403)\n\n### Part 9.2 旋转卡壳\n\n> 旋转卡壳是一种求出凸包所有对踵点对的算法。\n\n- [P1452 Beauty Contest](https://www.luogu.com.cn/problem/P1452)\n- [P3187 [HNOI2007]最小矩形覆盖](https://www.luogu.com.cn/problem/P3187)\n\n### Part 9.3 半平面交\n\n> 多个半平面的交集称之为半平面交。\n\n- [P3256 [JLOI2013]赛车](https://www.luogu.com.cn/problem/P3256)\n- [P2600 [ZJOI2008]瞭望塔](https://www.luogu.com.cn/problem/P2600)\n- [P4196 [CQOI2006]凸多边形](https://www.luogu.com.cn/problem/P4196)\n- [P3297 [SDOI2013]逃考](https://www.luogu.com.cn/problem/P3297)\n- [P4250 [SCOI2015]小凸想跑步](https://www.luogu.com.cn/problem/P4250)\n- [P5328 [ZJOI2019]浙江省选](https://www.luogu.com.cn/problem/P5328)\n\n## Part 10 杂项\n\n> 这里的专题，有很多都难以纳入前面的类别中，故将他们单独列入了杂项。\n\n### Part 10.1 模拟退火\n\n> 模拟退火是一种随机化算法。当一个问题的方案数量极大（甚至是无穷的）而且不是一个单峰函数时，我们常使用模拟退火求解。\n\n- [P1337 [JSOI2004]平衡点 / 吊打XXX](https://www.luogu.com.cn/problem/P1337)\n- [P2503 [HAOI2006]均分数据](https://www.luogu.com.cn/problem/P2503)\n- [P3878 [TJOI2010]分金币](https://www.luogu.com.cn/problem/P3878)\n\n### Part 10.2 0/1 分数规划\n\n> 0/1 分数规划用来求一个分式的极值。\n\n- [P4377 [USACO18OPEN]Talent Show](https://www.luogu.com.cn/problem/P4377)\n- [P3199 [HNOI2009]最小圈](https://www.luogu.com.cn/problem/P3199)\n- [P3288 [SCOI2014]方伯伯运椰子](https://www.luogu.com.cn/problem/P3288)\n- [P3705 [SDOI2017]新生舞会](https://www.luogu.com.cn/problem/P3705)\n- [P4322 [JSOI2016]最佳团体](https://www.luogu.com.cn/problem/P4322)\n\n### Part 10.3 离线算法\n\n> 当题目不要求强制在线时，我们可以一次性读入所有询问来处理。\n\n#### Part 10.3.1 CDQ 分治\n\n> CDQ 分治是一个基于分治思想的离线算法。\n\n- [P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)\n- [P3157 [CQOI2011]动态逆序对](https://www.luogu.com.cn/problem/P3157)\n- [P2487 [SDOI2011]拦截导弹](https://www.luogu.com.cn/problem/P2487)\n- [P4690 [Ynoi2016]镜中的昆虫](https://www.luogu.com.cn/problem/P4690)\n- [P3206 [HNOI2010]城市建设](https://www.luogu.com.cn/problem/P3206)\n\n#### Part 10.3.2 整体二分\n\n> 整体二分，顾名思义就是把多个查询一起二分解决。\n\n- [P1527 [国家集训队]矩阵乘法](https://www.luogu.com.cn/problem/P1527)\n- [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)\n- [P3527 [POI2011]MET-Meteors](https://www.luogu.com.cn/problem/P3527)\n- [P4602 [CTSC2018]混合果汁](https://www.luogu.com.cn/problem/P4602)\n\n#### Part 10.3.3 莫队\n\n> 莫队算法可以解决不少离线区间询问问题。\n\n- [P1494 [国家集训队]小Z的袜子 /【模板】莫队](https://www.luogu.com.cn/problem/P1494)\n- [P1903 [国家集训队]数颜色 / 维护队列 /【模板】带修莫队](https://www.luogu.com.cn/problem/P1903)\n- [P5906 【模板】回滚莫队](https://www.luogu.com.cn/problem/P5906)\n- [P4887 【模板】莫队二次离线（第十四分块(前体)）](https://www.luogu.com.cn/problem/P4887)\n- [P2709 小B的询问](https://www.luogu.com.cn/problem/P2709)\n- [P3674 小清新人渣的本愿](https://www.luogu.com.cn/problem/P3674)\n- [P3709 大爷的字符串题](https://www.luogu.com.cn/problem/P3709)\n- [P4074 [WC2013]糖果公园](https://www.luogu.com.cn/problem/P4074)\n- [P5501 [LnOI2019]来者不拒，去者不追](https://www.luogu.com.cn/problem/P5501)\n\n### Part 10.4 奇怪的题目\n\n> OI 界中有一些非常规套路的题目，这里放出来分享。\n\n- [P4920 [WC2015]未来程序](https://www.luogu.com.cn/problem/P4920)\n- [P5042 [国家集训队]丢失的题面（ydc的题面）](https://www.luogu.com.cn/problem/P5042)\n- [P5285 [十二省联考2019]骗分过样例](https://www.luogu.com.cn/problem/P5285)\n- [P5246 [集训队互测2016]消失的源代码](https://www.luogu.com.cn/problem/P5246)\n\n### Part 10.5 非传统题\n\n> 在 NOI 等比赛中，非传统题正越来越频繁出现。\n>\n> 非传统题主要包括以下几类：提交答案题，交互题，通信题。\n\n#### Part 10.5.1 提交答案题\n\n> 给你一些输入，你只需要提交这些输入对应的答案，即为提交答案题。\n\n- [P1335 [NOI2013]小Q的修炼](https://www.luogu.com.cn/problem/P1335)\n- [P1737 [NOI2016]旷野大计算](https://www.luogu.com.cn/problem/P1737)\n- [P3614 yyy棋 II](https://www.luogu.com.cn/problem/P3614)\n- [P3640 [APIO2013]出题人](https://www.luogu.com.cn/problem/P3640)\n- [P3782 [WC2017]排序](https://www.luogu.com.cn/problem/P3782)\n- [P3836 Nowruz](https://www.luogu.com.cn/problem/P3836)\n- [P4920 [WC2015]未来程序](https://www.luogu.com.cn/problem/P4920)\n- [P5402 [CTS2019]无处安放](https://www.luogu.com.cn/problem/P5402)\n- [P5418 [CTSC2016]NOIP十合一](https://www.luogu.com.cn/problem/P5418)\n- [P5600 【XR-4】尺规作图](https://www.luogu.com.cn/problem/P5600)\n\n#### Part 10.5.2 交互题\n\n> 在交互题中，选手程序需要通过与测评程序交互来完成任务。\n\n- [P1733 猜数（IO交互版）](https://www.luogu.com.cn/problem/P1733)\n- [P1947 猜数](https://www.luogu.com.cn/problem/P1947)\n- [P5208 [WC2019]I 君的商店](https://www.luogu.com.cn/problem/P5208)\n- [P5473 [NOI2019]I 君的探险](https://www.luogu.com.cn/problem/P5473)\n- [P6541 [WC2018]即时战略](https://www.luogu.com.cn/problem/P6541)\n- [P6558 [APIO2017]考拉的游戏](https://www.luogu.com.cn/problem/P6558)\n\n","tags":["题单"],"categories":["题单"]},{"title":"P2014 [CTSC1997] 选课","url":"/2022/07/01/0e6127f1ac11/","content":"\n# [CTSC1997] 选课\n\n## 题目描述\n\n在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？\n\n## 输入格式\n\n第一行有两个整数 $N$ , $M$ 用空格隔开。( $1 \\leq N \\leq 300$ , $1 \\leq M \\leq 300$ )\n\n接下来的 $N$ 行,第 $I+1$ 行包含两个整数 $k_i $和 $s_i$, $k_i$ 表示第I门课的直接先修课，$s_i$ 表示第I门课的学分。若 $k_i=0$ 表示没有直接先修课（$1 \\leq {k_i} \\leq N$ , $1 \\leq {s_i} \\leq 20$）。\n\n## 输出格式\n\n只有一行，选 $M$ 门课程的最大得分。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7  4\n2  2\n0  1\n0  4\n2  1\n7  1\n7  6\n2  2\n```\n\n### 样例输出 #1\n\n```\n13\n```\n\n## 思路\n\n课和课之间的关系构成森林。但是加入0节点后则构成一棵树（没有先修课的课程先修课序号为0），可以将0看作一门0学分的课程，这样就把所有课程的关系变为了一棵树。\n\n本题节点与节点之间不仅有树形结构的依赖关系，还有重量-价值的关系，可以联想到背包。\n\n那么如何在树上进行背包？\n\n设 $f[now][j][k]$ 表示为以 $now$ 为根，前 $j$ 个节点选 $k$ 门课的价值。\n\n如果前1个节点选1门课，那么就是选根节点，因此有： $f[now][1][1] = val[now] $\n\n可以推出状态转移方程：\n\n $f[now][j][k]=max(f[now][j-1][k],f[son][son节点所有节点][l]+f[now][j-1][k-l])$\n\n右边两种状态解释：\n\n$f[now][j-1][k]$ ： 不选当前节点。\n\n$ f[son][son节点所有节点][l]+f[now][j-1][k-l]$ ：在son节点中选 $l$ 个节点，在父亲节点中少选 $l$ 个节点。\n\n由于我们要先处理 $now$ 结点的子树，因此 $f[son][son节点所有节点][l]$ 是已知量。\n\n在处理第 $j$ 个节点时，前 $j-1$ 个节点都是已经处理好了的，因此带有 $j-1$ 的量不用考虑循环顺序问题。\n\n$l$ 是子树中选择节点的数量，它的数量一定小于总节点数，因此 $l<k$ ，因此倒着循环 $k$ ，可以使数组当前值与已经用到的值不受影响。（类似一维背包压维）\n\n最后得出状态转移方程：\n\n$f[now][j]=max(f[now][j],f[son][l]+f[now][j-l])$ \n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint f[310][310],cnt,head[1010];\nstruct edge{\n\tint to,nxt;\n}e[1010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dp(int x)\n{\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tdp(to);//从最深处的子节点开始向上逐一计算\n        //先计算子节点状态，用子节点状态推出父节点状态\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tfor(int j=m+1;j>=1;j--)//默认根节点为0且必取，相当于多一门课 类似一维背包压维\n\t\t{\n\t\t\tint to=e[i].to;//x的子节点\n            //f[x][j]代表以x为根的子树取j个节点的时候能取得的最大值\n            //第x门课和它之后的课的最大学分\n\t\t\tfor(int k=0;k<j;k++)//遍历重量\n\t\t\t{\n\t\t\t\tf[x][j]=max(f[x][j],f[to][k]+f[x][j-k]);\n                //f[to][k] x节点子树选了k门课\n                //f[x][j-k] 相应的，x就要少选k门课\n                //状态转移方程理解为：不选这个子树上的节点，或者选某些节点，同时少选其他节点（以取得最大值）\n                //由于子树先处理，因此f[to][k]是已经知道被处理出来的值\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint fa,v;\n\t\tcin>>fa>>v;\n\t\tf[i][1]=v;//初状态为只选这门课，那么值就等于该门课学分\n\t\tadd(fa,i);\n\t}\n\tdp(0);\n\tcout<<f[0][m+1];//以0为根选了m+1门课\n\treturn 0;\n } \n```","tags":["树形结构","树形dp","树形背包"],"categories":["题解"]},{"title":"P1122 最大子树和","url":"/2022/07/01/e8bfd67e2f67/","content":"# 最大子树和\n\n## 题目描述\n\n小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：\n\n一株奇怪的花卉，上面共连有$N $朵花，共有$N-1$条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。\n\n老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。\n\n## 输入格式\n\n第一行一个整数$N(1 ≤ N ≤ 16000)$。表示原始的那株花卉上共$N $朵花。\n\n第二行有$N $个整数，第$I$个整数表示第$I$朵花的美丽指数。\n\n接下来$N-1$行每行两个整数$a,b$，表示存在一条连接第$a$ 朵花和第$b$朵花的枝条。\n\n## 输出格式\n\n一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过$2147483647$。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7\n-1 -1 -1 1 1 1 0\n1 4\n2 5\n3 6\n4 7\n5 7\n6 7\n```\n\n### 样例输出 #1\n\n```\n3\n```\n\n## 提示\n\n【数据规模与约定】\n\n对于$60\\%$的数据，有$N≤1000$；\n\n对于$100\\%$的数据，有$N≤16000$。\n\n## 思路\n\n树形dp的基本思路：对每一个节点可以选择或者不选，选的节点可以选节点子树上的节点，不选的节点=放弃该节点整棵子树。\n\n因此对选与不选都要进行判断，说不定不选会放弃更多节点。\n\n$f[i][1]=max(f[i][1]+f[son][1],f[i][1]+f[son][0])$\n\n$f[i][0]=0$\n\n```cpp\nvoid dp(int now,int father)\n{\n\tf[now][0]=0;//不选这个节点，那么初始化为0\n\tf[now][1]=val[now];//选这个节点，初始化为这个结点的权值\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdp(to,now);//先算出下面结点的f，直到最后一个节点\n\t\t\tf[now][1]=max(f[now][1],f[now][1]+f[to][1]);//递归后一个个向上计算最大的值\n            //f[now][0]因为同时舍弃了子树因此不用计算\n\t\t}\n\t}\n}\n```\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=20010;\nstruct edge{\n\tint to,nxt;\n}e[N*2];\nint n,cnt,head[N*2],val[N],f[N][2],ans=-1145141919;\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dp(int now,int father)\n{\n\tf[now][0]=0;//不选这个节点，那么初始化为0\n\tf[now][1]=val[now];//选这个节点，初始化为这个结点的权值\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdp(to,now);//先算出下面结点的f，直到最后一个节点\n\t\t\tf[now][1]=max(f[now][1],f[now][1]+f[to][1]);//递归后一个个向上计算最大的值\n            //f[now][0]因为同时舍弃了子树因此不用计算\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>val[i];\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tadd(u,v),add(v,u);\n\t}\n\tdp(1,0);\n\tfor(int i=1;i<=n;i++)\n\t\tans=max(ans,f[i][1]);//小细节，最后的值一定是选了某个结点的f\n        //一开始把0和1都带进去，遇见全负会一个都不选wa\n        //理解起来很简单，最后的答案一定至少有一个节点，那么必定是某个选了的节点的f向两边衍生的树\n\tcout<<ans;\n\treturn 0;\n}\n```","tags":["树形结构","树形dp"],"categories":["题解"]},{"title":"P3398 仓鼠找sugar","url":"/2022/06/30/1a08171575b0/","content":"\n# 仓鼠找 sugar\n\n## 题目描述\n\n小仓鼠的和他的基（mei）友（zi）sugar住在地下洞穴中，每个节点的编号为1~n。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（a）到餐厅（b），而他的基友同时要从他的卧室（c）到图书馆（d）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？\n\n\n小仓鼠那么弱，还要天天被zzq大爷虐，请你快来救救他吧！\n\n## 输入格式\n\n第一行两个正整数n和q，表示这棵树节点的个数和询问的个数。\n\n接下来n-1行，每行两个正整数u和v，表示节点u到节点v之间有一条边。\n\n接下来q行，每行四个正整数a、b、c和d，表示节点编号，也就是一次询问，其意义如上。\n\n## 输出格式\n\n对于每个询问，如果有公共点，输出大写字母“Y”；否则输出“N”。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5 5\n2 5\n4 2\n1 3\n1 4\n5 1 5 1\n2 2 1 4\n4 1 3 4\n3 1 1 5\n3 5 1 4\n```\n\n### 样例输出 #1\n\n```\nY\nN\nY\nY\nY\n```\n\n## 提示\n\n本题时限1s，内存限制128M，因新评测机速度较为接近NOIP评测机速度，请注意常数问题带来的影响。\\_\\_\n\n\n20%的数据 n<=200,q<=200\n\n40%的数据 n<=2000,q<=2000\n\n70%的数据 n<=50000,q<=50000\n\n100%的数据 n<=100000,q<=100000\n\n## 思路\n画图+仔细思考可以发现规律：如果两条路径相交，那么一条路径端点的LCA必定在另一条路径上。那么如何证明一个点是否在一条路径上？想想数轴，如果一个点在某线段上，那么点到线段两端的距离=线段长度。在LCA中，可以采用差分来求出路径长度，即：\n\n$ dis(a,b)=abs(dep[LCA(a,b)]-dep[a])+abs(dep[LCA(a,b)]-dep[b])$\n\n用代码表示：\n\n```cpp\nint dis(int a,int b)\n{\n\tint c=lca(a,b);\n\treturn abs(dep[c]-dep[a])+abs(dep[c]-dep[b]);\n}\n\nint e=lca(a,b),f=lca(c,d);\n\t\tint disab=dis(a,b),discd=dis(c,d);\n\t\tif(dis(a,f)+dis(b,f)==disab || dis(c,e)+dis(d,e)==discd){//如果lca到路径两端距离=路径\n\t\t\tcout<<\"Y\\n\";\n\t\t}else cout<<\"N\\n\";\n```\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nint n,q,cnt,head[N*2],dep[N],fa[N][25];\nstruct edge{\n\tint to,next;\n}e[N*2];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].next=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int now,int father)\n{\n\tdep[now]=dep[father]+1;\n\tfa[now][0]=father;\n\tfor(int i=1;(1<<i)<=dep[now];i++)\n\t{\n\t\tfa[now][i]=fa[fa[now][i-1]][i-1];\n\t}\n\tfor(int i=head[now];i;i=e[i].next)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs(to,now);\n\t\t}\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n\t\tif(x==y)return x;\n\t}\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])\n\t\t{\n\t\t\tx=fa[x][i];\n\t\t\ty=fa[y][i];\n\t\t}\n\t}\n\treturn fa[x][0];\n}\nint dis(int a,int b)\n{\n\tint c=lca(a,b);\n\treturn abs(dep[c]-dep[a])+abs(dep[c]-dep[b]);\n}\nint main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tdfs(1,0);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tint e=lca(a,b),f=lca(c,d);\n\t\tint disab=dis(a,b),discd=dis(c,d);\n\t\tif(dis(a,f)+dis(b,f)==disab || dis(c,e)+dis(d,e)==discd){\n\t\t\tcout<<\"Y\\n\";\n\t\t}else cout<<\"N\\n\";\n\t}\n\treturn 0;\n}\n```","tags":["树形结构","最近公共祖先","倍增"],"categories":["题解"]},{"title":"算法学习笔记（1）-倍增求LCA","url":"/2022/06/30/16dd215545c0/","content":"\n# 【模板】最近公共祖先（LCA）\n\n## 题目描述\n\n如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。\n\n## 输入格式\n\n第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。\n\n接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。\n\n接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。\n\n## 输出格式\n\n输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5 5 4\n3 1\n2 4\n5 1\n1 4\n2 4\n3 2\n3 5\n1 2\n4 5\n```\n\n### 样例输出 #1\n\n```\n4\n4\n1\n4\n4\n```\n\n## 提示\n\n对于 $30\\%$ 的数据，$N\\leq 10$，$M\\leq 10$。\n\n对于 $70\\%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。\n\n对于 $100\\%$ 的数据，$N\\leq 500000$，$M\\leq 500000$。\n\n\n样例说明：\n\n该树结构如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2282.png) \n\n第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。\n\n第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。\n\n第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。\n\n第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。\n\n第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。\n\n故输出依次为 $4, 4, 1, 4, 4$。\n\n## 朴素思路\n\n给定两个点 $a,b$ ，其深度分别是 $d1, d2(d1>d2)$ ，先令d1逐层向上跳跃，直到 $d1=d2$ ，之后 $d1,d2$ 一起向上跳跃，直到跳跃到同一个点，那个点就是最近公共祖先。（如果 $d1=d2$ 时点就是同一个点，那么该点就是其最近公共祖先。 通过复杂度分析不难发现该算法的时间复杂度为 $ O(n)$ ,面对$n $次询问的时间复杂度为 $O(n^2)$，面对超过5000的数据范围就无法承受。\n\n是否有其他更好做法？\n\n## 倍增\n\n任意一个数字都可以用二进制的形式被表达出，例如 $7=4+2+1$ ，在这里$7=2^2+2^1+2^0$，我们可以使 $d1$每次向上跳跃的层数都是2的幂，例如要想上跳7层，第一次跳 $2^2$ 层 ，第二次跳 $2^1$ 层，此三次跳 $2^0$ 层。这就是倍增的思想，显然对于 $n$ 层跳跃，倍增法仅需跳跃 $log n$ 次，可以大大简化时间复杂度。\n\n### 预处理\n\n我们先用简单的数列来看一下倍增到底是如何实现的。\n\n$1,2,3,4,5,6,7,8,9,10$\n\n令 $f[1][x]$ 来代表 $1$ 之后 $2^x$ 是什么数字，通过分析可以发现：\n\n$f[1][0]=2, f[1][1]=3, f[1][2]=5, f[1][3]=9$\n\n同理，$f[2][0]=3, f[2][1]=4, f[2][2]=8, f[2][3]=10$\n\n同时，我们不难发现，通过幂函数的性质 $2^n=2^{n-1} +2^{n-1} $，可以得出递推式：$f[i][j]=f[f[i][j-1]][j-1]$，即向右跨出 $j$ 个格子等效于先向右跨出 $j-1$ 个格子，再在这个格子向右跨 $j-1$ 个格子。\n\n例：$f[1][4]=16=f[f[1][3]][3]=f[8][3]$。\n\n\n那么，对于一棵树，我们也能通过这种方法来预处理出第 $i$ 个结点向上 $2^n$ 层的结点是。先预处理出表格，在倍增是直接套用即可。\n\n即: $f[i][j]$ 代表 $i $ 节点向上跳跃 $2^j$ 个父亲。\n\n用dfs预处理出以上我们要求的信息，形成一张表格：\n```cpp\nvoid dfs(int now,int father)\n{\n\tdep[now]=dep[father]+1;//now结点的深度比父亲节点深度大1（往下一层）\n\tfa[now][0]=father;//now节点向上跳1层是父亲节点\n\tfor(int i=1;(1<<i)<=dep[now];i++)//他向上跳的层数肯定小于他自己的深度\n\t{\n\t\tfa[now][i]=fa[fa[now][i-1]][i-1];//递推，理由在上面解释\n\t}\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tif(e[i].to!=father)//向它的儿子进行dfs，找出儿子的一堆父亲\n\t\t\tdfs(e[i].to,now);\n\t}\n}\n```\n### 求LCA\n\n那么如何求LCA呢？\n\n现在我们已经有了一张预处理的表格，那么我们目前就要用这张预处理的表格来找出他们的祖先。想法和朴素的思路类似：先将深度较大的点跳到和另一个点同一高度，然后两个点同时用倍增法向上跳。\n\n要注意的是，每次跳跃的高度都是向上跳 $2^{n_{max}}$ 层，即每次要尽可能向上跳大的距离。但是有一个限制条件：这两个点在同时向上跳的时候，不能跳到相遇的点。道理很简单，两个点在同一层，它们尽可能向上跳正好跳到相遇的点，但是不能保证这个点下面的点不能相遇，这样这个点就不是最近的公共祖先了。因此要加上一个限制条件：这两个点向上跳以后不是同一个点。而要跳到不能再向上跳（两个点再向上跳 ( $2^0=1$ ) 层就能相遇），那此时任意点的父亲就是它们的最近公共祖先。\n\n```cpp\nint LCA(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);//默认depx>depy\n\tfor(int i=20;i>=0;i--)//从最大幂次开始尽可能向上跳\n\t{\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];//深度还大于y就接着往上跳\n\t\tif(x==y)return x;//在这一步就相遇说明y就是最近的公共祖先（此时y=x）\n\t}\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])//如果向上跳到的不是同一个点\n\t\t{\n\t\t\tx=fa[x][i];//一起向上跳2^i层\n\t\t\ty=fa[y][i];\n\t\t}\n\t}\n\treturn fa[x][0];//最近公共祖先就是x，y任意点的父亲\n}\n```\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge\n{\n\tint to,nxt;\n}e[500010<<1];\nint fa[500010][22],dep[500010],cnt,head[500010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int now,int father)\n{\n\t//cout<<now<<\"k\"<<endl;\n\tdep[now]=dep[father]+1;\n\tfa[now][0]=father;\n\tfor(int i=1;(1<<i)<=dep[now];i++)\n\t{\n\t\tfa[now][i]=fa[fa[now][i-1]][i-1];\n\t\t//cout<<fa[now][i]<<\" \"<<now<<\" \"<<i<<endl;\n\t}\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tif(e[i].to!=father)\n\t\t\tdfs(e[i].to,now);\n\t}\n}\nint LCA(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n\t\tif(x==y)return x;\n\t}\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])\n\t\t{\n\t\t\tx=fa[x][i];\n\t\t\ty=fa[y][i];\n\t\t}\n\t}\n\treturn fa[x][0];\n}\nint main()\n{\n\t//memset(head,-1,sizeof(head));\n\tint n,m,s;\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tadd(a,b);\n\t\tadd(b,a); \n\t}\n\tdfs(s,0);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tcout<<LCA(a,b)<<endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n","tags":["树形结构","最近公共祖先","倍增"],"categories":["笔记"]},{"title":"P5536 【XR-3】核心城市","url":"/2022/06/28/4c28eade2351/","content":"# 【XR-3】核心城市\n\n## 题目描述\n\nX 国有 $n$ 座城市，$n - 1$ 条长度为 $1$ 的道路，每条道路连接两座城市，且任意两座城市都能通过若干条道路相互到达，显然，城市和道路形成了一棵树。\n\nX 国国王决定将 $k$ 座城市钦定为 X 国的核心城市，这 $k$ 座城市需满足以下两个条件：\n\n1. 这 $k$ 座城市可以通过道路，在不经过其他城市的情况下两两相互到达。\n2. 定义某个非核心城市与这 $k$ 座核心城市的距离为，这座城市与 $k$ 座核心城市的距离的最小值。那么所有非核心城市中，与核心城市的距离最大的城市，其与核心城市的距离最小。你需要求出这个最小值。\n\n## 输入格式\n\n第一行 $2$ 个正整数 $n,k$。\n\n接下来 $n - 1$ 行，每行 $2$ 个正整数 $u,v$，表示第 $u$ 座城市与第 $v$ 座城市之间有一条长度为 $1$ 的道路。\n\n**数据范围：**\n\n- $1 \\le k < n \\le 10 ^ 5$。\n- $1 \\le u,v \\le n, u \\ne v$，保证城市与道路形成一棵树。\n\n## 输出格式\n\n一行一个整数，表示答案。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n6 3\n1 2\n2 3\n2 4\n1 5\n5 6\n```\n\n### 样例输出 #1\n\n```\n1\n```\n\n## 提示\n\n【样例说明】\n\n钦定 $1,2,5$ 这 $3$ 座城市为核心城市，这样 $3,4,6$ 另外 $3$ 座非核心城市与核心城市的距离均为 $1$，因此答案为 $1$。\n\n## 思路\n\n这道题的题目就有一点像在玩文字游戏的意思....\n\n简单来说：核心城市是一个团，其中每两个点都有链接。用yy能力把核心城市缩成一个点，要求的是所有点到核心城市点的最长距离的最小值。\n\n我们要做的是确定几个核心城市的位置，使得其他点到核心城市最长距离最小。\n\n先从简单的想起：假如就确定一个核心城市的位置，这个核心城市应该在哪？\n\n答案是整颗树直径的中点（可以理解为到每个最深结点的平均距离差值最小）。这时候到树上任意一点最大值最小。那么如果要令最大值最大，这个点应该在哪呢？\n\n答案是树的直径的端点。\n\n### 树的直径\n\n树的直径可以理解为树上最长的一条链。因此，接上文，如果在直径的端点，那么核心城市的距离就是树的直径（最长链），那最长距离必定最大。\n\n#### 如何求树的直径\n\n有两种方法：两次dfs（bfs）或者dp。dp方法不易求出树上的点，与我们要求出树的中心目的不符，在此仅介绍两次dfs做法。\n\n第一次dfs：任意选取一个点，开始dfs，搜索到最深处（树的直径的一个端点）\n\n第二次dfs：从树的端点开始dfs，dfs到最深处（树的另一个端点）\n\n这样求出来的就是最长链。在网上能搜到详细证明，在这里就不赘述，知道就行了。\n\n由于树的直径的中点必定在直径上（废话），因此可以在dfs的时候标记处整条直径，然后在直径上找出中点。\n\n两次dfs：\n```cpp\nvoid dfs1(int x,int father,int dep)\n{\n\tif(dep>mxdp)//mxdp是设置的目前最大深度，因为要找到最深的端点\n\t{\n\t\tmxdp=dep;\n\t\ttag=x;\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs1(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs2(int x,int father,int dep)\n{\n\tif(dep>zj)//直径，和mxdp其实可以用同一个变量。\n\t{\n\t\tzj=dep;\n\t\ttag=x;//标记出另一个端点的编号\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tfa[to]=x;//标记出每个点的父亲。方便之后沿着链来寻找中点\n\t\t\tdfs2(to,x,dep+1);\n\t\t}\n\t}\n}\n```\n为什么标记了父亲就能寻找到中点？因为我们通过第二次dfs可以找到另一个端点的编号，而在标记处该编号的父亲便可以通过寻找父亲一直寻找到直径的另一头。\n\n哪个是中点？直径长度一半就是中点。如果带有小数点 $0.5$ ，那说明有两个中点，无论哪个都可以。\n```cpp\nint mid=tag;//tag就是找出的另一个端点\n\tfor(int i=1;i<=zj/2;i++)\n\t\tmid=fa[mid];//找直径/2次自己的父亲就是中点\n```\n解决了中点的问题，我们想起来：核心城市并不是一个点，它是很多个点构成的点集。那么对于除了直径中点以外的点怎么处理呢？\n\n贪心！\n\n每个点到这个点可以到达的最深点都有一个距离。而这个距离就是可能的最长链的长度。该距离 $d = maxdeep[x]-deep[x]$ ，即是该点可到达最深深度-自己的深度。如果将其从大到小排序，如果有k个核心城市，那么前k个就是第k长的最长链，是要去掉的。而 $d[k+1]+1$ 是我们所要求的最长链的最小值。\n\n例：假设 $k=3$\n\n从核心城市到它能到达的最深点（应该是直径一端）的距离为 $d[1]$ 。\n\n第二个城市 $d[2]$ 。\n\n第三个城市 $d[3]$。\n\n那么第四个城市（除了核心城市以外的第一座城市，即除了核心城市以外自身到最深点的最长链）$=d[4]$\n\n为什么还要 $+1$ ？\n\n因为我们求的 $d$ 是该点本身到该点能到达的最深深度的距离，他还要连接到核心城市上，这里是 $1$ 的距离，因此最后答案要 $+1 $。\n\n代码中用了四次dfs：\n\n第一次求出直径的一端\n\n第二次求出直径的另一端\n\n找出中点\n\n第三次以中点为树根标记各个节点深度\n\n第四次寻找每个深度的 $d$\n\n中间其实可以省略一次dfs，但是我觉得四次dfs也挺清晰的。\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nstruct edge{\n\tint to,nxt;\n}e[200010];\nint head[200010],cnt,dept[100010],mxdp,tag,mid;\nint dis[100010],fa[100010],zj,maxdeep[100010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nbool cmp(int a,int b){\n\treturn a>b;\n}\nvoid dfs1(int x,int father,int dep)\n{\n\tif(dep>mxdp)\n\t{\n\t\tmxdp=dep;\n\t\ttag=x;\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs1(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs2(int x,int father,int dep)\n{\n\tif(dep>zj)\n\t{\n\t\tzj=dep;\n\t\ttag=x;\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tfa[to]=x;\n\t\t\tdfs2(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs3(int x,int father,int dep)\n{\n\tdept[x]=dep;\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs3(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs4(int x,int father)\n{\n\tmaxdeep[x]=dept[x];\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs4(to,x);\n\t\t\tmaxdeep[x]=max(maxdeep[x],maxdeep[to]);\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tadd(u,v),add(v,u);\n\t}\n\tdfs1(1,0,0);\n\tdfs2(tag,0,0);\n\tint mid=tag;\n\tfor(int i=1;i<=zj/2;i++)\n\t\tmid=fa[mid];\n\tdfs3(mid,0,0);\n\tdfs4(mid,0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tmaxdeep[i]-=dept[i];\n\t}\n\tsort(maxdeep+1,maxdeep+n+1,cmp);\n\tcout<<maxdeep[k+1]+1;\n\treturn 0;\n}\n```","tags":["树形结构","树的直径","贪心"],"categories":["题解"]},{"title":"P5018 [NOIP2018 普及组] 对称二叉树","url":"/2022/06/28/4d1511918017/","content":"\n# [NOIP2018 普及组] 对称二叉树\n\n## 题目描述\n\n一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： \n\n1.  二叉树； \n2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   \n\n下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  \n\n![](https://cdn.luogu.com.cn/upload/pic/43192.png)   \n\n现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。   \n\n注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。\n\n## 输入格式\n\n第一行一个正整数 $n$，表示给定的树的节点的数目，规定节点编号 $1 \\sim n$，其中节点 $1$ 是树根。 \n\n第二行 $n$ 个正整数，用一个空格分隔，第 $i$ 个正整数 $v_i$ 代表节点 $i$ 的权值。 \n\n接下来 $n$ 行，每行两个正整数 $l_i, r_i$，分别表示节点 $i$ 的左右孩子的编号。如果不存在左 / 右孩子，则以 $-1$ 表示。两个数之间用一个空格隔开。\n\n## 输出格式\n\n输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n2 \n1 3 \n2 -1 \n-1 -1\n```\n\n### 样例输出 #1\n\n```\n1\n```\n\n## 样例 #2\n\n### 样例输入 #2\n\n```\n10 \n2 2 5 5 5 5 4 4 2 3 \n9 10 \n-1 -1 \n-1 -1 \n-1 -1 \n-1 -1 \n-1 2 \n3 4 \n5 6 \n-1 -1 \n7 8\n```\n\n### 样例输出 #2\n\n```\n3\n```\n\n## 提示\n\n【输入输出样例 1 说明】  \n![](https://cdn.luogu.com.cn/upload/pic/43188.png)     \n最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   \n\n【输入输出样例 2 说明】   \n![](https://cdn.luogu.com.cn/upload/pic/43189.png)     \n最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 \n\n【数据规模与约定】    \n共 $25$ 个测试点。    \n$v_i ≤ 1000$。   \n测试点 $1 \\sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。   \n测试点 $4 \\sim 8, n ≤ 10$。  \n测试点 $9 \\sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。   \n测试点 $13 \\sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。  \n测试点 $17 \\sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。  \n测试点 $21 \\sim 25, n ≤ 10^6$。 \n \n本题约定： \n\n层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 \n \n 树的深度：树中节点的最大层次称为树的深度。 \n \n 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  \n ![](https://cdn.luogu.com.cn/upload/pic/43190.png)  \n完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  \n ![](https://cdn.luogu.com.cn/upload/pic/43191.png)\n\n\n ## 思路\n\n 树形结构的暴力，有助于提升对树的认知\n\n 目标：\n\n 1.判断二叉树结构是否对称\n\n 2.判断二叉树权值是否对称\n\n 3.判断二叉树的大小\n\n 把每个节点视作树的根，将其视作一棵二叉树，判断其结构、权值是否对称，计算其大小。通过递归可以得出。\n\n 判断二叉树对称：\n\n ```cpp\n bool check(int x,int y)\n{\n\tif(x==-1 && y==-1)return 1;\n\telse{\n\t\tif(x!=-1 && y!=-1 && val[x]==val[y] && check(ls[x],rs[y]) && check(ls[y],rs[x]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n ```\n ### 判断对称的条件：\n\n 1.左右都没有子树（都是-1），那么二叉树对称（只有自己节点，当然对称）\n\n 2.左右子树对称（结构对称且权值对称 $val[x]==val[y]$ ）。判断左右子树是否对称，可以采用1（该子树没有左右子树），或者2（该子树的左右子树对称），可以直接递归解决，即: $check(ls[x],rs[y])==1 且 check(ls[y],rs[x])==1 $ 。\n 令 $x$ 为该树左节点，$y$ 为该书右结点，则 $ls[x],rs[y]$ 代表其左节点的左子树和右节点的右子树，根据图片可以发现他们是满足对称的条件。另一个等式也是同样的道理\n\n 判断不对称：\n\n 1.只有一个子树存在\n\n 2.权值不等\n\n 3.左右子树不等\n\n ---------------------\n ### 判断树的子节点数\n\n 如果有左子树，加上左子树的节点数。对右子树同理。最后加上根节点（自己）\n\n```cpp\nint cnt(int x)\n{\n\tif(rs[x]!=-1)cnts[x]+=cnt(rs[x]);\n\tif(ls[x]!=-1)cnts[x]+=cnt(ls[x]);\n\treturn ++cnts[x];\n}\n```\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nint rs[1000100],ls[1000100],val[1000100],cnts[1000100];\nbool check(int x,int y)\n{\n\tif(x==-1 && y==-1)return 1;\n\telse{\n\t\tif(x!=-1 && y!=-1 && val[x]==val[y] && check(ls[x],rs[y]) && check(ls[y],rs[x]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint cnt(int x)\n{\n\tif(rs[x]!=-1)cnts[x]+=cnt(rs[x]);\n\tif(ls[x]!=-1)cnts[x]+=cnt(ls[x]);\n\treturn ++cnts[x];\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>val[i];\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>ls[i]>>rs[i];\n\tcnt(1);//默认1是根节点，从1号点开始找\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(check(ls[i],rs[i]))//经检查该树对称\n\t\t{\n\t\t\tans=max(ans,cnts[i]);//答案=目前最大值或者该树的节点数\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```","tags":["树形结构","递归"],"categories":["题解"]},{"title":"P1364 树的重心","url":"/2022/06/28/1b3206c4f64a/","content":"\n# 医院设置\n\n## 题目描述\n\n设有一棵二叉树，如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/166.png)\n\n其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在1 处，则距离和 $=4+12+2\\times20+2\\times40=136$；若医院建在 $3$ 处，则距离和 $=4\\times2+13+20+40=81$。\n\n## 输入格式\n\n第一行一个整数 $n$，表示树的结点数。\n\n接下来的 $n$ 行每行描述了一个结点的状况，包含三个整数 $w, u, v$，其中 $w$ 为居民人口数，$u$ 为左链接（为 $0$ 表示无链接），$v$ 为右链接（为 $0$ 表示无链接）。\n\n## 输出格式\n\n一个整数，表示最小距离和。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5\t\t\t\t\t\t\n13 2 3\n4 0 0\n12 4 5\n20 0 0\n40 0 0\n```\n\n### 样例输出 #1\n\n```\n81\n```\n\n## 提示\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$0 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^5$。\n\n## 思路\n\n思路1：数据范围  $1 \\leq n \\leq 100$ ，可以考虑Floyd求最短路，求出任意两个点间最短距离，然后从1到N穷举医院的位置，找出最小值。\n\n思路2：加入数据更大呢？如果 $1 \\leq n \\leq 10000$ ，Floyd+穷举的方法肯定行不通。引出概念：树的重心。\n\n什么是树的重心？\n### 1.树的重心的定义：\n\n树若以某点为根，使得该树最大子树的结点数最小，那么这个点则为该树的重心，一棵树可能有多个重心。\n\n### 2.树的重心的性质：\n\n1、树上所有的点到树的重心的距离之和是最短的，如果有多个重心，那么总距离相等。\n\n2、插入或删除一个点，树的重心的位置最多移动一个单位。\n\n3、若添加一条边连接2棵树，那么新树的重心一定在原来两棵树的重心的路径上。\n\n本题中只需要用到第一条性质，求出所有点（权）到树的重心的距离的最小值。\n\n### 3.如何求树的重心：\n\n动态规划求树的重心：定义 $f[i]$ 为以 $i$ 为根（医院）的总距离，$size[i]$ 为以 $i$为根的子树的总大小。\n\n那么有：$f[j] = f[i]+size[1]-2*size[j]$\n\n为什么？\n\n当根从 $i$ 变为 $j$ 时，根的子树到根的距离原先到 $i$ ，现在到 $j$ ，所有子树到根的距离都减小了1，而当前子树大小为 $size[j]$ ，因此减少的总距离为 $size[j]$ 。但是，除了子树之外的部分原先只要到 $i$ ，现在要到 $j$ 了，距离增加了1，因此增加的总距离为 $size[1]-size[j]$ 。于是可以得到：$f[j] = f[i]+size[1]-2*size[j]$ 。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n\tint to,next;\n}e[1010];\nint head[1010],n,pop[1010],cnt;\nint size[1010],ans=114514,f[1010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].next=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int x,int father,int dep)\n{\n\tsize[x]=pop[x];//因为本题中每个点有点权（人口），因此点权要计入树的大小。\n\tfor(int i=head[x];i;i=e[i].next)\n\t{\n\t\tif(e[i].to!=father)\n\t\t{\n\t\t\tdfs(e[i].to,x,dep+1);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t}\n\t}\n\tf[1]+=(pop[x]*dep);//f[1]代表到f[1]的总距离，之后从f[1]开始向后进行dp\n}\nvoid dp(int u,int father)\n{\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tif(e[i].to!=father)\n\t\t{\n\t\t\tf[e[i].to]=f[u]+size[1]-2*size[e[i].to];\n\t\t\tdp(e[i].to,u);\n\t\t}\n\t\tans=min(f[u],ans);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>pop[i];\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tif(u)add(i,u);\n\t\tif(v)add(i,v);\n\t}\n\tdfs(1,0,0);\n\tdp(1,0);\n\tcout<<ans;\n\treturn 0;\n}\n```\n","tags":["树形结构","树的重心","最短路"],"categories":["题解"]},{"title":"P1352 没有上司的舞会","url":"/2022/06/28/b1aaafc3fcd9/","content":"# 没有上司的舞会\n## 题目描述\n\n某大学有 $ n $ 个职员，编号为 $1\\ldots n$。 \n\n他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。\n\n现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。\n\n所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。\n\n\n## 输入格式\n\n输入的第一行是一个整数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。\n\n第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。\n\n\n## 输出格式\n\n输出一行一个整数代表最大的快乐指数。\n\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7\n1\n1\n1\n1\n1\n1\n1\n1 3\n2 3\n6 4\n7 4\n4 5\n3 5\n```\n\n### 样例输出 #1\n\n```\n5\n```\n\n## 提示\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1\\leq n \\leq 6 \\times 10^3$，$-128 \\leq r_i\\leq 127$，$1 \\leq l, k \\leq n$，且给出的关系一定是一棵树。\n\n## 思路\n\n对于每一个人，有两种状态：来参加聚会或者不来参加聚会。能否使用 $f[i]$ 来表示这个人的位置能获得的最大幸福指数？不行。因为他是否去参加聚会对他之后的人是会产生影响的，即这个问题里是有后效性的。无后效性是dp里的一个重要问题，如果 $f[i]$ 就能获得该位置的最大幸福度，根据动态规划的无后效性定义：在 $f[i]$ 之后的 $f[i+1] \\ldots f[i+n]$ 与 $f[i]$ 是没有关系的，但是这道题中是否选择 $i$ 会对之后的状态产生影响，与无后效性矛盾，因此不能用 $f[i]$ 表示状态来进行动态规划。\n\n那么怎么用动态规划来解决这道问题呢？\n\n由于后效性实际上是对之后状态的不清楚。即：如果使用 $f[i]$ 表示状态，我们无法确定的表示出状态（取还是不取都会影响）。因此尝试加一维：即用 $f[i][0]$ 和 $f[i][1]$ 来表示两种状态：在 $i$ 时取这个人和不取这个人，然后分别根据两种状态来进行dp，似乎就可以做下去了。\n\n当不取第 $i$ 个人时候，$f[i][0]$ 在最初等于 $ 0 $ （因为不取他自己也就不加上他自身的快乐值 $r_i$），然后在 $f[i][0]=0$ 的基础上进行累加，找出它的最大值，即 $f[i][0] = max(f[son][1],f[son][0])$ 。即这个状态等于 $0 + 它下属能取到的最大快乐值 $ 。同理，当取第 $i$ 个人的时候，$f[i][1]=r_i$ 。（取了自身，加上自己的快乐值 $r_i$ ），状态转移方程为 $f[i][1] = r_i + max(f[son][0],f[son][1])$ 。\n\n因此，对于每个人的两种状态都进行一次状态转移，因为是从根部往下进行转移，因此动态规划的起点在这棵树的根部。\n\n先找出根部：由于每两个人之间都有记录上司的关系，因此在输入的时候为下属定义一个 $bool$ 型数组，记录它是否有上司，最后记录到没有上司的那个点就是树的根部（大领导）。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> son[10010]; \nint f[10010][2],r[10010],v[10010];\nvoid dp(int x)\n{\n\tf[x][0]=0;\n\tf[x][1]=r[x];\n\tfor(int i=0;i<son[x].size();i++)\n\t{\n\t\tint nxt=son[x][i];\n\t\tdp(nxt);\n\t\tf[x][0]+=max(f[nxt][0],f[nxt][1]);\n\t\tf[x][1]+=f[nxt][0];\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>r[i];\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint l,k;\n\t\tcin>>l>>k;\n\t\tson[k].push_back(l);\n\t\tv[l]=1; //记录是否有上司\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!v[i])rt=i;\n\tdp(rt);\n\tcout<<max(f[rt][0],f[rt][1]);\n\treturn 0;\n}\n```","tags":["树形结构","树形dp"],"categories":["题解"]},{"title":"Hello World","url":"/2022/06/27/1fc55095b3bb/","content":"第一篇md博客试试水\n\n不会网站又404了吧\n\n好像没有404 找到之前一直404的原因了 大成功\n\n今天再调一调主题什么的乱七八糟的\n\n\n从下午两点开始整 整到下午六点 当时以为忽略每次推送CNAME消失而导致网页404直接把整个项目删除了又重新建了一个 解决了不知道多少奇奇怪怪的问题 终于感觉差不多搞好了\n\n目前用git推到github上的时候貌似还会经常出现网络问题(errno 10053和无法连接到github） 希望也能尽快解决吧\n\n----------\n\n2022/06/28 00：01\n\n之前本地预览hexo s可以正常浏览网页，但是部署之后一点除了主页之外的任何网页就寄，终于修好了，呜呜呜\n\n有点困，再修一会睡觉。7.4就要小学期学汇编语言了，怎么到今天都没人陪我玩游戏。\n\n\n----------\n\n2022/06/28 00:33\n\n把分类、标签、关于页面也弄出来了，大成功(bushi\n\n开森\n\n基础的网站算是搭好了\n\n------------\n\n2022/06/28 11:39\n\n解决了markdown不显示数学公式的问题\n\n------------------------\n\n2022/06/28 16:39\n\n更换了Mist主题，搭配canvas_nest感觉超级好看\n\n添加了搜索功能\n\n把代码块的样式美化成了Mac的样式\n\n添加了头像\n\n（这5个小时的工作内容）\n\n感觉美化工作也工作的差不多了！\n\n","tags":["碎碎念"],"categories":["随笔"]}]