<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"solstice621.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理(六)中央处理器">
<meta property="og:url" content="https://solstice621.github.io/2023/04/22/2a97cf6ad2c0/index.html">
<meta property="og:site_name" content="qzh保护基地">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://solstice621.github.io/images/typora/image-20230422201235640.png">
<meta property="og:image" content="https://solstice621.github.io/images/typora/image-20230510123814368.png">
<meta property="og:image" content="https://solstice621.github.io/images/typora/image-20230422211428245.png">
<meta property="og:image" content="https://solstice621.github.io/images/typora/image-20230510141937969.png">
<meta property="og:image" content="https://solstice621.github.io/images/typora/image-20230510155452829.png">
<meta property="og:image" content="https://solstice621.github.io/images/typora/image-20230510163414184.png">
<meta property="og:image" content="https://solstice621.github.io/images/typora/image-20230510163528949.png">
<meta property="article:published_time" content="2023-04-22T09:23:56.000Z">
<meta property="article:modified_time" content="2023-05-10T08:42:13.518Z">
<meta property="article:author" content="裘子涵">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://solstice621.github.io/images/typora/image-20230422201235640.png">

<link rel="canonical" href="https://solstice621.github.io/2023/04/22/2a97cf6ad2c0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机组成原理(六)中央处理器 | qzh保护基地</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qzh保护基地</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://solstice621.github.io/2023/04/22/2a97cf6ad2c0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_0021(20210820-200930).JPG">
      <meta itemprop="name" content="裘子涵">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qzh保护基地">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机组成原理(六)中央处理器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-22 17:23:56" itemprop="dateCreated datePublished" datetime="2023-04-22T17:23:56+08:00">2023-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-10 16:42:13" itemprop="dateModified" datetime="2023-05-10T16:42:13+08:00">2023-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
            <div class="post-description"></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="中央处理器">中央处理器</h2>
<h3 id="cpu的功能和基本结构">CPU的功能和基本结构</h3>
<p>CPU由运算器和控制器组成</p>
<p>控制器的功能是<strong>负责协调</strong>并<strong>控制</strong>计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令</p>
<p>运算器的功能是对数据进行<strong>加工</strong></p>
<p><strong>CPU的具体功能:</strong></p>
<ol type="1">
<li><p>指令控制 取指令、分析指令和执行指令</p></li>
<li>操作控制 CPU管理并产生由内存去除的每条指令的操作信号,把各种操作送往相应部件,控制这些部件按指令要求动作</li>
<li>时间控制 对各种操作加以时间上的控制<br>
</li>
<li>数据加工。对数据进行算术和逻辑运算。<br>
</li>
<li><p>中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。</p></li>
</ol>
<h3 id="cpu的基本结构">CPU的基本结构</h3>
<p><img src="/images/typora/image-20230422201235640.png" alt="image-20230422201235640"></p>
<h3 id="运算器">运算器</h3>
<p>运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理</p>
<ol type="1">
<li>算术逻辑单元。主要功能是进行算术/逻辑运算。<br>
</li>
<li>暂存寄存器。用于暂存从主存读来的数据<br>
</li>
<li>累加寄存器(ACC)。它是一个通用寄存器，用于暂时存放 ALU 运算的结果信息<br>
</li>
<li>通用寄存器组。如 AX、BX、CX、DX、SP 等，用于存放操作数和各种地址信息等。SP 是堆栈指针，用于指示栈顶的地址<br>
</li>
<li>程序状态字寄存器 溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等<br>
</li>
<li>移位器。对操作数或运算结果进行移位运算。<br>
</li>
<li>计数器。控制乘除运算的操作步数。</li>
</ol>
<h3 id="数据通路">数据通路</h3>
<h4 id="数据通路的功能">数据通路的功能</h4>
<p>数据在功能部件之间传送的路径被称为<strong>数据通路</strong></p>
<p>数据通路包括流经的部件,如<code>ALU,通用寄存器,状态寄存器</code>等等</p>
<p>数据通路描绘了信息从什么地方开始,经过了哪个寄存器或多路开关,最后传送到哪个寄存器</p>
<p>数据通路由控制部件控制,控制部件根据每条指令功能的不同生成对数据通路的控制信号</p>
<p>数据通路的功能是<strong>实现CPU内部的运算器与寄存器及寄存器之间的数据交换</strong></p>
<h4 id="数据通路的基本结构">数据通路的基本结构</h4>
<ol type="1">
<li><p>CPU内部单总线方式</p>
<p>将所有寄存器的输入端和输出端连接到一条公共通路上.</p>
<p>优点:结构简单</p>
<p>缺点:数据传输存在较多冲突现象,性能较低</p></li>
<li><p>CPU内部三总线方式:将所有的寄存器的输入端和输出端连接到多条公共通路上,可以在多个总线上传输不同的数据,提高效率</p></li>
<li><p>专用数据通路方式:根据指令执行过程的数据和地址的流动方向安排连接线路,避免使用共享总线,性能较高,但硬件量大</p></li>
</ol>
<p><img src="/images/typora/image-20230510123814368.png" alt="image-20230510123814368"></p>
<p>上图中,各部件用大写字母表示,字母+<code>in</code>表示该部件的允许输入控制信号;字母+<code>out</code>表示该部件的允许输出控制信号</p>
<ol type="1">
<li><p>寄存器之间的数据传送</p>
<p>通过CPU内部总线完成.以PC寄存器为例,实现传送操作的流程及控制信号:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PC-&gt;Bus 	PCout有效,PC内容送总线</span><br><span class="line">Bus-&gt;MAR	MARin有效,总线内容送MAR</span><br></pre></td></tr></table></figure></div></li>
<li><p>主存和CPU之间的数据传送</p>
<p>以CPU从主存读取指令为例</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS-&gt;Bus-&gt;MAR	PCout和MARin有效,现行指令地址-&gt;MAR</span><br><span class="line">1-&gt;R			CU发读命令</span><br><span class="line">MEM(MAR)-&gt;MDR	MDRin有效</span><br><span class="line">MDR-&gt;BUS-&gt;IR	MDRout和IRin有效,现行指令-&gt;IR</span><br></pre></td></tr></table></figure></div></li>
<li><p>执行算术或逻辑运算</p>
<p>ALU本身是没有内部存储功能的组合电路,在执行加法运算时相加的两个数必须在ALU的两个输入端同时有效.</p>
<p>先把一个操作数经CPU内部总线送入暂存器Y保存,Y的内容在ALU的左输入端始终有效,再将另一个操作数经总线直接送到ALU的右输入端,这样两个数都送入了ALU,运算结果暂存在暂存器Z中</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ad(IR)-&gt;Bus-&gt;MAR	MDRout和MDRin有效</span><br><span class="line">1-&gt;R				CU发读命令</span><br><span class="line">MEM-&gt;数据线-&gt;MDR	  操作数从存储器-&gt;数据线-&gt;MDR</span><br><span class="line">MDR-&gt;Bus-&gt;Y			MDRout和Yin有效,操作数-&gt;Y</span><br><span class="line">(ACC)+(Y)-&gt;Z		ACCout和ALUin有效,CU向ALU发加命令,结果-&gt;Z</span><br><span class="line">Z-&gt;ACC				Zout和ACCin有效,结果-&gt;ACC</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="控制器">控制器</h3>
<p>控制器是整个系统的指挥中枢</p>
<p>基本功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的</p>
<p>控制器由程序计数器（PC）、指令寄存器（IR）、指令译码器、存储器地址寄存器(MAR),存储器数据寄存器（MDR）、时序系统和微操作信号发生器等组成。</p>
<ol type="1">
<li>程序计数器。用于指出下一条指令在主存中的存放地址<br>
</li>
<li>指令寄存器。用于保存当前正在执行的那条指令<br>
</li>
<li>指令译码器。仅对操作码字段进行译码，向控制器提供特定的操作信号。<br>
</li>
<li>存储器地址寄存器。用于存放要访问的主存单元的地址。<br>
</li>
<li>存储器数据寄存器。用于存放向主存写入的信息或从主存读出的信息。<br>
</li>
<li>时序系统。用于产生各种时序信号，它们都由统一时钟（CLOCK）分频得到。<br>
</li>
<li>微操作信号发生器 根据 IR 的内容（指令）、PSW 的内容（状态信息）及时序信号产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种</li>
</ol>
<h3 id="控制器的功能和基本原理">控制器的功能和基本原理</h3>
<h4 id="控制器的结构和功能">控制器的结构和功能</h4>
<p><img src="/images/typora/image-20230422211428245.png" alt="image-20230422211428245"></p>
<p>通过数据总线,地址总线和控制总线连接在一起,虚线框内是控制器部件</p>
<h3 id="控制器的主要内容">控制器的主要内容</h3>
<ol type="1">
<li>从主存中取出一条指令，并指出下一条指令在主存中的位置<br>
</li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作<br>
</li>
<li>指挥并控制CPU、主存、输入和输出设备之间的数据流动方向</li>
</ol>
<p>根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制,两类控制器中的 PC 和 IR 是相同的</p>
<h3 id="硬布线控制器">硬布线控制器</h3>
<p>硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态,按时间的顺序发送一系列微操作控制信号.</p>
<p>硬布线控制器由复杂的组合逻辑们电路和一些触发器构成,又称为<strong>组合逻辑控制器</strong>.</p>
<h4 id="硬布线控制器单元图">硬布线控制器单元图</h4>
<p>指令操作码决定控制单元发出不同操作命令,为了简化控制单元(CU)的逻辑,将指令的操作码译码和节拍发生器从CU分离,得到简化的控制单元图:</p>
<p><img src="/images/typora/image-20230510141937969.png" alt="image-20230510141937969"></p>
<p>CU的输入信号来源:</p>
<ol type="1">
<li><p>经指令译码器译码产生的指令信息.</p>
<p>现行<strong>指令操作码决定了不同指令在执行周期完成的不同操作</strong>,因此<strong>指令的操作码字段是控制单元的输入信号</strong>,与时钟配合产生不同的控制信号</p></li>
<li><p>时序系统产生的机器周期和节拍信号.</p>
<p>为了使控制单元<strong>按一定先后顺序和节奏发出控制信号</strong>,控制单元必须受时钟控制.</p></li>
<li><p>来自执行单元的反馈信息(标志)</p></li>
</ol>
<h4 id="硬布线控制器的时序系统及微操作">硬布线控制器的时序系统及微操作</h4>
<ol type="1">
<li>时钟周期</li>
<li>机器周期</li>
<li>指令周期</li>
<li>微操作命令分析: 控制单元具有发出操作命令(控制信号)序列的功能.这些命令与指令有关,且需要按照一定次序发出,才能使机器有序工作.</li>
</ol>
<p>一执行程序过程中,对于不同指令,控制单元需发出各种不同的微操作命令.</p>
<p>一条指令分为3个工作周期:</p>
<ol type="1">
<li><p>取值周期</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PC-&gt;MAR			现行指令地址-&gt;MAR</span><br><span class="line">1-&gt;R			命令存储器读</span><br><span class="line">M(MAR)-&gt;MDR		现行指令从存储器读至MDR</span><br><span class="line">MDR-&gt;IR			现行指令-&gt;IR</span><br><span class="line">OP(IR)-&gt;CU		指令的操作码-&gt;CU译码</span><br><span class="line">(PC)+1-&gt;PC		形成下一条指令地址</span><br></pre></td></tr></table></figure></div></li>
<li><p>间址周期</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ad(IR)-&gt;MAR		将指令字中的地址码(形式地址)-&gt;MAR</span><br><span class="line">1-&gt;R			命令存储器读</span><br><span class="line">M(MAR)-&gt;MDR		将有效地址从存储器读至MDR</span><br></pre></td></tr></table></figure></div></li>
<li><p>执行周期</p>
<ol type="a">
<li>非访存指令</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CLA		清ACC</span><br><span class="line">COM		取反</span><br><span class="line">SHR		算术右移</span><br><span class="line">CSL		循环左移</span><br><span class="line">STP		停机指令</span><br></pre></td></tr></table></figure></div>
<ol start="2" type="a">
<li>访存指令</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD X	加法指令</span><br><span class="line">Ad(IR)-&gt;MAR,1-&gt;R</span><br><span class="line">M(MAR)-&gt;MDR</span><br><span class="line">(ACC)+(MDR)-&gt;ACC</span><br></pre></td></tr></table></figure></div>
<p>该过程执行一个加法指令（ADD X），将内存中的某个值（位于地址 X）加到累加器（ACC）中的值上。以下是对每一步的详细解释：</p>
<ol type="1">
<li><code>ADD X</code>：这是一条加法指令，表示将累加器（ACC）中的值与存储在内存地址 X 中的值相加。</li>
<li><code>Ad(IR)-&gt;MAR,1-&gt;R</code>：这一步执行两个操作。首先，将指令寄存器（IR）中的地址部分（Ad(IR)，即上一步中的 X）加载到内存地址寄存器（MAR）中。这个地址是即将被读取的内存地址。然后，控制单元向存储器发送读取（R）命令。</li>
<li><code>M(MAR)-&gt;MDR</code>：这一步是从内存（M）的 MAR 指定的地址读取数据，然后将数据存入内存数据寄存器（MDR）。简单来说，就是把地址 MAR 中的内存内容读到 MDR 中。</li>
<li><code>(ACC)+(MDR)-&gt;ACC</code>：这一步是将 ACC（累加器）和 MDR 中的值相加，并将结果存入 ACC。这个操作由算术逻辑单元（ALU）执行。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STA X	存数指令</span><br><span class="line">Ad(IR)-&gt;MAR,1-&gt;W</span><br><span class="line">ACC-&gt;MDR</span><br><span class="line">MDR-&gt;M(MAR)</span><br></pre></td></tr></table></figure></div>
<p>这是一个执行 <code>STA X</code>（将累加器内容存储到地址 X）指令的微指令序列。这条指令的功能是将累加器（ACC）中的值存储到内存地址 X 的位置。下面是这个过程的详细步骤：</p>
<ol type="1">
<li><p><code>Ad(IR)-&gt;MAR</code>：这条微指令将指令寄存器（IR）中的地址部分（Ad(IR)，即 X）加载到内存地址寄存器（MAR）中。这个地址是即将写入数据的内存地址。</p></li>
<li><p><code>1-&gt;W</code>：这条微指令是控制单元向存储器发送写入（W）命令，这将触发存储器在 MAR 中指定的地址写入数据。</p></li>
<li><p><code>ACC-&gt;MDR</code>：这条微指令是从 ACC（累加器）读取数据，然后将数据存入内存数据寄存器（MDR）。简单来说，就是把 ACC 中的内容读到 MDR 中。</p></li>
<li><p><code>MDR-&gt;M(MAR)</code>：这条微指令是将 MDR 中的数据写入到内存（M）的 MAR 指定的地址。这就完成了将 ACC 中的数据存储到内存的过程。</p></li>
</ol>
<p>总的来说，这些微指令描述了 <code>STA X</code> 指令的执行过程，即将 ACC 中的值存储到内存地址 X 的位置。这个过程涉及了许多计算机硬件的基本组件，包括 IR、MAR、ACC、MDR 等。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDA X	取数指令</span><br><span class="line">Ad(IR)-&gt;MAR,1-&gt;R</span><br><span class="line">M(MAR)-&gt;MDR</span><br><span class="line">MDR-&gt;ACC</span><br></pre></td></tr></table></figure></div>
<p>这些操作是执行 <code>LDA X</code>（Load ACC with X）指令的微指令序列。这条指令的功能是将内存地址 X 中的值加载到累加器（ACC）中。下面是这个过程的详细步骤：</p>
<ol type="1">
<li><code>Ad(IR)-&gt;MAR</code>：这条微指令将指令寄存器（IR）中的地址部分（Ad(IR)，即 X）加载到内存地址寄存器（MAR）中。这个地址是即将被读取的内存地址。</li>
<li><code>1-&gt;R</code>：这条微指令是控制单元向存储器发送读取（R）命令，这将触发存储器从 MAR 中指定的地址读取数据。</li>
<li><code>M(MAR)-&gt;MDR</code>：这条微指令是从内存（M）的 MAR 指定的地址读取数据，然后将数据存入内存数据寄存器（MDR）。简单来说，就是把地址 MAR 中的内存内容读到 MDR 中。</li>
<li><code>MDR-&gt;ACC</code>：这条微指令是将 MDR 中的数据加载到 ACC（累加器）。这就完成了将内存中的数据加载到 ACC 的过程。</li>
</ol>
<p>所以，是的，这些微指令组成了 <code>LDA X</code> 指令的执行过程。首先，从内存中获取位于 X 地址的值，然后将这个值加载到 ACC 中。这个过程涉及了许多计算机硬件的基本组件，包括 IR、MAR、ACC、MDR 等。</p>
<ol start="3" type="a">
<li>转移指令</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JMP X	无条件转移	Ad(IR)-&gt;PC</span><br><span class="line">BAN X	条件转移</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="cpu的控制方式">CPU的控制方式</h4>
<p>控制单元控制一条指令执行的过程,是依次执行一个确定的微操作序列的过程.</p>
<p>不同指令对应的微操作数和复杂程度不同,因此每条指令和每个微操作所需时间也不同.</p>
<p>主要有3种控制方式:</p>
<ol type="1">
<li><p>同步控制方式</p>
<p>系统有一个统一时钟,<strong>所有控制信号均来自这个统一的时钟信号</strong>(通常以最长的微操作序列和最繁琐的微操作作为标准)</p>
<p>采用<strong>完全统一的</strong>,<strong>具有相同时间间隔和相同数目的节拍</strong>作为机器周期来运行不同的指令</p>
<p>优点: 控制电路简单</p>
<p>缺点: 运行速度慢</p></li>
<li><p>异步控制方式</p>
<p>不存在基准时标信号,各部件按照自身固有速度工作,通过应答方式联络</p>
<p>优点: 运行速度快</p>
<p>缺点: 控制电路复杂</p></li>
<li><p>联合控制方式</p>
<p>介于同步与异步的折中,对不同的指令微操作采用大部分同步,小部分异步的方法</p></li>
</ol>
<h3 id="微程序控制器">微程序控制器</h3>
<p>微程序控制器采用存储逻辑实现,即<strong>微操作信号代码化</strong>,使<strong>每条机器指令转化成为一段微程序并存入一个专门的存储器</strong>(控制存储器)中.微操作控制信号由微指令产生.</p>
<h4 id="微程序控制基本概念">微程序控制基本概念</h4>
<p>微程序设计思想: 把<strong>每条机器指令编写成一个微程序,每个微程序包含若干微指令,每条微指令对应一个或几个微操作命令</strong>.</p>
<p>这些微程序可以<strong>存到一个控制存储器</strong>中,用<strong>寻址用户程序机器指令</strong>的办法来寻址每个为程序中的微指令</p>
<p>一些基本术语:</p>
<ol type="1">
<li><p>微命令与微操作</p>
<p>一条机器指令可以分解成一个微操作序列</p>
<p>微操作是计算机中最基本,<strong>不可分解</strong>的操作</p>
<p>微程序控制计算机中,控制部件向执行部件发出的各种控制命令称为微命令,它是<strong>构成控制序列的最小单位</strong></p></li>
<li><p>微指令与微周期</p>
<p><strong>微指令是若干微命令的集合</strong></p>
<p><strong>存放微指令的控制存储器的单元地址称为微地址</strong></p>
<p>微指令通常至少包含两部分信息:</p>
<ol type="1">
<li>操作控制字段(<strong>微操作码</strong>字段): 产生某一步操作所需的各种<strong>操作控制信号</strong>.</li>
<li>顺序控制字段(<strong>微地址码</strong>字段): 控制产生<strong>下一条要执行的微指令地址</strong>.</li>
</ol></li>
<li><p>主存储器与控制存储器</p>
<p>主存储器: 存放程序和数据,在CPU外部用RAM实现.</p>
<p>控制存储器(CM): 存放微程序,在CPU内部用ROM实现.</p></li>
<li><p>程序与微程序</p>
<p>程序是指令的有序集合,用于完成特定功能.</p>
<p>微程序是<strong>微指令的有序集合</strong>,<strong>一条指令的功能由一段微程序实现</strong>.</p></li>
</ol>
<p>总结: 微程序是<strong>由微指令组成的序列</strong>，其主要目的是<strong>描述和实现机器指令的功能</strong>。微程序可以被视为机器指令的实时解释器。微程序通常<strong>由计算机的设计者编制</strong>，并<strong>存储在控制存储器</strong>（通常是固定的、不可修改的存储器）中。</p>
<h4 id="微程序控制器组成和工作过程">微程序控制器组成和工作过程</h4>
<h5 id="微程序控制器的基本组成">微程序控制器的基本组成</h5>
<p><img src="/images/typora/image-20230510155452829.png" alt="image-20230510155452829"></p>
<ol type="1">
<li>控制存储器(CM)：微程序控制器的核心部件，用于<strong>存放各指令对应的微程序</strong>。</li>
<li>微指令寄存器：用于存放从CM中取出的微指令。它的位数同微指令字长相等。</li>
<li>微地址形成部件：用于产生初始微地址和后继微地址，以保证微指令的连续执行。</li>
<li>微地址寄存器：接受微地址形成部件送来的微地址，为在CM中读取微指令作准备。</li>
</ol>
<h5 id="微指令控制器的工作过程">微指令控制器的工作过程</h5>
<ol type="1">
<li><strong>执行取微指令公共操作</strong>：在机器开始运行时，微程序控制器会自动将取指微程序的入口地址（通常为控制存储器（CM）的 0 号单元）送入微程序计数器（CMAR），然后从 CM 中读出相应的微指令送入微指令寄存器（CMDR）。取指微程序执行完后，主存中的机器指令就已存入指令寄存器中。</li>
<li><strong>产生微程序的入口地址</strong>：然后，机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入 CMAR。</li>
<li><strong>执行微指令</strong>：从 CM 中逐条取出对应的微指令并执行。</li>
<li><strong>回到取指微程序的入口地址</strong>：执行完对应于一条机器指令的一个微程序后，控制器又回到取指微程序的入口地址，继续第一步，完成取下一条机器指令的公共操作。</li>
</ol>
<p>这个过程会一直循环，直到整个程序执行完毕。每一条机器指令的执行都是通过执行一系列的微指令来完成的，这些微指令是由微程序控制器控制的。</p>
<h5 id="微程序和机器指令">微程序和机器指令</h5>
<p>通常，一条机器指令对应一个微程序。</p>
<p>任何一条机器指令的取指令操作相同，因此可<strong>将取指令操作的微命令统一编成一个微程序</strong>。</p>
<p><em>如果指令系统中有n中机器指令，则控制存储器中的微程序数至少是n+1</em></p>
<h4 id="微指令的编码方式">微指令的编码方式</h4>
<p>又称微指令的<strong>控制方式</strong>，是指如何对微指令的控制字段进行编码，以形成控制信号</p>
<p>目标：<strong>在保证速度的情况下，尽量缩短微指令字长</strong>。</p>
<ol type="1">
<li><p>直接编码(直接控制)方式</p>
<p>无需译码，微指令的微命令字段中的每位都代表一个微命令。</p>
<p>选用或者不选用某个微指令，只需将该微命令的对应位设置成0或1即可。</p>
<p>每个微命令对应并控制数据通路中的一个微操作。</p>
<p>优点：简单，直观，执行速度快，操作并行性好。</p>
<p>缺点：字长过长，n个微指令要求操作字段有n位，造成控制存储器容量极大。</p></li>
</ol>
<p><img src="/images/typora/image-20230510163414184.png" alt="image-20230510163414184"></p>
<ol start="2" type="1">
<li><p>字段直接编码方式</p>
<p>将微命令字段分为若干小字段，把互斥微命令组合在同一字段中，相容微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关。</p>
<p><img src="/images/typora/image-20230510163528949.png" alt="image-20230510163528949"></p>
<p>优点：可以缩短指令字长</p>
<p>缺点：通过译码电路后再发出微命令，比直接编码方式慢。</p>
<p>微命令字段分段原则：</p>
<ol type="1">
<li>互斥性微命令在同一段内；相容性微命令分在不同段内。</li>
<li>每个小段包含的信息位不能太多，否则将<strong>增加译码线路复杂性和译码时间</strong>。</li>
<li>每个小段要<strong>留出一个状态</strong>，表示本字段不发出任何微命令。</li>
</ol></li>
<li><p>字段间接编码方式</p>
<p>字段间接编码，也称为隐式编码。在这种编码方式中，一个字段的微命令<strong>需要通过另一个字段中的微命令来解释</strong>，而不是直接通过字段本身来解释。虽然这种方式可以缩短微指令字长，但是它会削弱微指令的并行控制能力，通常作为字段直接编码方式的一种<strong>辅助手段</strong>使用。</p></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag"># 计算机组成原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/20/fc18d8a43620/" rel="prev" title="力扣416 分割等和子集">
      <i class="fa fa-chevron-left"></i> 力扣416 分割等和子集
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/24/f1ed81fcae40/" rel="next" title="力扣134 加油站">
      力扣134 加油站 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">中央处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">CPU的功能和基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">CPU的基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8"><span class="nav-number">1.3.</span> <span class="nav-text">运算器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="nav-number">1.4.</span> <span class="nav-text">数据通路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">1.4.1.</span> <span class="nav-text">数据通路的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.2.</span> <span class="nav-text">数据通路的基本结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.5.</span> <span class="nav-text">控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.</span> <span class="nav-text">控制器的功能和基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="nav-number">1.6.1.</span> <span class="nav-text">控制器的结构和功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="nav-number">1.7.</span> <span class="nav-text">控制器的主要内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.8.</span> <span class="nav-text">硬布线控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8D%95%E5%85%83%E5%9B%BE"><span class="nav-number">1.8.1.</span> <span class="nav-text">硬布线控制器单元图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%BE%AE%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.2.</span> <span class="nav-text">硬布线控制器的时序系统及微操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpu%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.3.</span> <span class="nav-text">CPU的控制方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.9.</span> <span class="nav-text">微程序控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.9.1.</span> <span class="nav-text">微程序控制基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%84%E6%88%90%E5%92%8C%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.9.2.</span> <span class="nav-text">微程序控制器组成和工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">微程序控制器的基本组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">微指令控制器的工作过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">微程序和机器指令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="nav-number">1.9.3.</span> <span class="nav-text">微指令的编码方式</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="裘子涵"
      src="/images/IMG_0021(20210820-200930).JPG">
  <p class="site-author-name" itemprop="name">裘子涵</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">裘子涵</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>

	<script type="text/javascript"
color="220,220,220" opacity='0.9' zIndex="-2" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
    </footer>
  </div>

  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
